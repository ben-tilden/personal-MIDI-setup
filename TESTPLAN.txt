# test plan
# NOTE that each file test is meant to be copied and pasted into SB - using this whole file will not function as expected

# xtouch

IF LOAD

  ASS G0 = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

  # local
  ALIAS I0 tempoMode
  ALIAS I1 arpValueMode

  # global
  ALIAS G0 channel
  ALIAS G2 arpPhraseToggle
  ALIAS G3 arpPhraseOnOffToggle
  ALIAS G4 tempoModeMod
  ALIAS G5 tempoPulse
  ALIAS G6 gate
  ALIAS G7 arpValueModeMod
  ALIAS G8 setPhrase
  ALIAS G9 waveguideToggle
  ALIAS GA drumParams
  ALIAS GE arpModeSwitched # gateOpened

  # assign local
  # NOTE if this isn't reset on each 'install', then it's technically possible it could increase to the value max
  ASS tempoMode = 0
  # NOTE if this isn't reset on each 'install', then it's technically possible it could decrease/increase to the value min/max
  ASS arpValueMode = 8000
END

# if it is a button push
IF MT == 90
	# if it is a knob 1 button push, increase tempo mode
	# if variable is too high, reset
	IF M1 == 00 7F
		MATH tempoMode = tempoMode + 1
		# set tempo mode to variable modulo 3
		MATH tempoModeMod = tempoMode % 4
		IF tempoModeMod == 0
			ASS tempoPulse = 24
			SEND BA 01 28
		END
		# set each tempoPulse to default value on switching
		# also send data to xtouch to reflect this
		IF tempoModeMod == 1
			ASS tempoPulse = 24
			SEND BA 01 0
		END
		IF tempoModeMod == 2
			ASS tempoPulse = 24
			SEND BA 01 53
		END
		IF tempoModeMod == 3
			ASS tempoPulse = 18
			SEND BA 01 53
		END
		# TEST
		LOG tempoModeMod tempoModeMod
		LOG tempoPulse tempoPulse
		# END TEST
	END

	# if it is a button 1 push
	IF M0 == 9A 08 7F
		# if arp then increase variable
		IF arpPhraseToggle == 0
			MATH arpValueMode = arpValueMode + 1
			# set value mode to variable modulo 11
			MATH arpValueModeMod = arpValueMode % B
			# NOTE uncommenting this makes clockNum, isOctave, and arpIndex reset whenever the arpMode changes
			# ASS arpModeSwitched = 1
		# if phrase then toggle setPhrase
		ELSE
			IF setPhrase == 0
				ASS setPhrase = 1
				SEND 90 00 01
			ELSE
				ASS setPhrase = 0
				SEND F0 BB BB 07 +F
			END
		END
		# TEST
		LOG arpValueMode arpValueModeMod
		LOG setPhrase setPhrase
		# END TEST
	END

	# if it is a button 9 push
	IF M0 == 9A 10 7F
		# if arp then decrease variable
		IF arpPhraseToggle == 0
			MATH arpValueMode = arpValueMode - 1
			# set value mode to variable modulo 11
			MATH arpValueModeMod = arpValueMode % B
		# if phrase then add rest to phrase sequence
		ELSE
		  SEND F0 AA AA F7 +F
		  # TEST
		  LOG REST_SYSEX_SENT
		  # END TEST
		END
		# TEST
		LOG arpValueMode arpValueModeMod
		# END TEST
	END

	# if it is a button 2 push toggle arp / phrase
	IF M1 == 09 7F
		IF arpPhraseToggle == 0
			ASS arpPhraseToggle = 1
			SEND 90 01 01
		ELSE
			ASS arpPhraseToggle = 0
			IF setPhrase == 1
				ASS setPhrase = 0
				SEND 90 00 00
				SEND F0 BB BB 07 +F
			END
		END
		# TEST
		IF arpPhraseToggle == 0
			LOG IS_ARP
		END
		IF arpPhraseToggle == 1
			LOG IS_PHRASE
		END
		LOG setPhrase setPhrase
		# END TEST
	END

	# if it is a button 10 push toggle button 2 selection on / off
	IF M1 == 11 7F
		IF arpPhraseOnOffToggle == 0
			ASS arpPhraseOnOffToggle = 1
			SEND 90 09 01
		ELSE
			ASS arpPhraseOnOffToggle = 0
		END
		# TEST
		IF arpPhraseOnOffToggle == 0
			LOG MODULE_OFF
		END
		IF arpPhraseOnOffToggle == 1
			LOG MODULE_ON
		END
		# END TEST
	END

	# if it is channel 1-6
	IF channel <= 6
		IF M1 == 07 7F
			IF waveguideToggle == 0
				ASS waveguideToggle = 1
			ELSE
				ASS waveguideToggle = 0
			END
			# TEST
			IF waveguideToggle == 0
				LOG WAVEGUIDE_STRING
			END
			IF waveguideToggle == 1
				LOG WAVEGUIDE_TUBE
			END
			# END TEST
		END
		# for all except the last, order is part 1, part 2, part 1 and 2
		# if it is button 5 - knobs control 'select'
		IF M1 == 0C 7F
			ASS drumParams = $14 $15 $16
			# TEST
			LOG drumParams drumParams
			# END TEST
		END
		# if it is button 6 - knobs control 'level'
		IF M1 == 0D 7F
			ASS drumParams = $17 $18 $19
			# TEST
			LOG drumParams drumParams
			# END TEST
		END
		# if it is button 7 - knobs control 'attack'
		IF M1 == 0E 7F
			ASS drumParams = $20 $21 $22
			# TEST
			LOG drumParams drumParams
			# END TEST
		END
		# if it is button 8 - knobs control 'release'
		IF M1 == 0F 7F
			ASS drumParams = $23 $24 $25
			# TEST
			LOG drumParams drumParams
			# END TEST
		END
		# if it is button 13 - knobs control 'pitch'
		IF M1 == 14 7F
			ASS drumParams = $26 $27 $28
			# TEST
			LOG drumParams drumParams
			# END TEST
		END
		# if it is button 14 - knobs control 'modAmount'
		IF M1 == 15 7F
			ASS drumParams = $29 $30 $31
			# TEST
			LOG drumParams drumParams
			# END TEST
		END
		# if it is button 15 - knobs control 'modRate'
		IF M1 == 16 7F
			ASS drumParams = $46 $47 $48
			# TEST
			LOG drumParams drumParams
			# END TEST
		END
		# order is decay, body, tune, send
		# if it is button 16 - knobs control 'waveguide'
		IF M1 == 17 7F
			ASS drumParams = $17 $18 $19 $103
			# TEST
			LOG drumParams drumParams
			# END TEST
		END
	END
END

# if it is a button note-off (important for lighting)
IF MT == 80
	IF M1 == 08 00
		IF arpPhraseToggle == 1
			IF setPhrase == 1
				SEND 90 00 01
			END
		END
	END

	IF M1 == 09 00
		IF arpPhraseToggle == 1
			SEND 90 01 01
		ELSE
			IF setPhrase == 0
				SEND 90 07 00
			END
		END
	END

	IF M1 == 11 00
		IF arpPhraseOnOffToggle == 1
			SEND 90 09 01
		END
	END
END

# if it is a knob turn
IF MT == B0
	# if knob is 1 (tempo)
	IF M1 == 1
		IF arpPhraseOnOffToggle == 1
			# if arp tempo mode is 0
			IF tempoModeMod == 0
				# if knob value is 0-11
				IF M2 < 12
					ASS tempoPulse = $48
				END
				# if knob value is 12-22
				IF M2 >= 12
					IF M2 < 23
						ASS tempoPulse = $36
					END
				END
				# if knob value is 23-33
				IF M2 >= 23
					IF M2 < 34
						ASS tempoPulse = $24
					END
				END
				# if knob value is 34-45
				IF M2 >= 34
					IF M2 < 46
						ASS tempoPulse = $18
					END
				END
				# if knob value is 46-57
				IF M2 >= 46
					IF M2 < 58
						ASS tempoPulse = $12
					END
				END
				# if knob value is 58-69
				IF M2 >= 58
					IF M2 < 70
						ASS tempoPulse = $9
					END
				END
				# if knob value is 70-81
				IF M2 >= 70
					IF M2 < 82
						ASS tempoPulse = $6
					END
				END
				# if knob value is 82-93
				IF M2 >= 82
					IF M2 < 94
						ASS tempoPulse = $4
					END
				END
				# if knob value is 94-104
				IF M2 >= 94
					IF M2 < 105
						ASS tempoPulse = $3
					END
				END
				# if knob value is 105-115
				IF M2 >= 105
					IF M2 < 116
						ASS tempoPulse = $2
					END
				END
				# if knob value is 116-127
				IF M2 >= 116
					ASS tempoPulse = $1
				END
			END
			# if arp tempo mode is 1
			IF tempoModeMod == 1
				# if knob value is 0-21
				IF M2 < 22
					ASS tempoPulse = $24
				END
				# if knob value is 22-42
				IF M2 >= 22
					IF M2 < 43
						ASS tempoPulse = $12
					END
				END
				# if knob value is 43-63
				IF M2 >= 43
					IF M2 < 64
						ASS tempoPulse = $9
					END
				END
				# if knob value is 64-84
				IF M2 >= 64
					IF M2 < 85
						ASS tempoPulse = $6
					END
				END
				# if knob value is 85-105
				IF M2 >= 85
					IF M2 < 106
						ASS tempoPulse = $4
					END
				END
				# if knob value is 106-127
				IF M2 >= 106
					ASS tempoPulse = $3
				END
			END
			# if arp tempo mode is 2
			IF tempoModeMod == 2
				# if knob value is 0-21
				IF M2 < 22
					ASS tempoPulse = $96
				END
				# if knob value is 22-42
				IF M2 >= 22
					IF M2 < 43
						ASS tempoPulse = $48
					END
				END
				# if knob value is 43-63
				IF M2 >= 43
					IF M2 < 64
						ASS tempoPulse = $24
					END
				END
				# if knob value is 64-84
				IF M2 >= 64
					IF M2 < 85
						ASS tempoPulse = $12
					END
				END
				# if knob value is 85-105
				IF M2 >= 85
					IF M2 < 106
						ASS tempoPulse = $6
					END
				END
				# if knob value is 106-127
				IF M2 >= 106
					ASS tempoPulse = $3
				END
			END
			# if arp tempo mode is 3
			IF tempoModeMod == 3
				# if knob value is 0-21
				IF M2 < 22
					ASS tempoPulse = $72
				END
				# if knob value is 22-42
				IF M2 >= 22
					IF M2 < 43
						ASS tempoPulse = $36
					END
				END
				# if knob value is 43-63
				IF M2 >= 43
					IF M2 < 64
						ASS tempoPulse = $18
					END
				END
				# if knob value is 64-84
				IF M2 >= 64
					IF M2 < 85
						ASS tempoPulse = $9
					END
				END
				# if knob value is 85-105
				IF M2 >= 85
					IF M2 < 106
						ASS tempoPulse = $4
					END
				END
				# if knob value is 106-127
				IF M2 >= 106
					ASS tempoPulse = $2
				END
			END
		END
	END
	# if knob is 2 (gate)
	# starting points: max will be ~5 seconds (5000), min will be .1 seconds (100)
	IF M1 == 2
		MATH gate = M3 * 39
		MATH gate = gate + 100
	END
END

# launchkey mini

SUBROUTINE INSERTION_SORT isOrder length
  ALIAS I10 i
  ALIAS I11 j
  ALIAS I12 jPlusOne
  ALIAS I13 keyVal
  ALIAS I14 keyBool
  ALIAS I15 isSetSort

  IF isOrder == 1
    ASS i = 10
    WHILE i < length
      ASS keyVal = JI10
      ASS keyBool = GI10
      MATH j = i - 1
      MATH jPlusOne = j + 1
      ASS isSetSort = 0
      IF j >= 0
        IF JI11 < keyVal
          ASS isSetSort = 1
        END
      END
      WHILE isSetSort == 1
        ASS JI12 = JI11
        ASS GI12 = GI11
        MATH j = j - 1
        MATH jPlusOne = j + 1
        ASS isSetSort = 0
        IF j >= 0
          IF JI11 < keyVal
            ASS isSetSort = 1
          END
        END
      END
      ASS JI12 = keyVal
      ASS GI12 = keyBool
      MATH i = i + 1
    END
  ELSE
    ASS i = 10
    WHILE i < length
      ASS keyVal = GI10
      ASS keyBool = JI10
      MATH j = i - 1
      MATH jPlusOne = j + 1
      ASS isSetSort = 0
      IF j >= 0
        IF GI11 < keyVal
          ASS isSetSort = 1
        END
      END
      WHILE isSetSort == 1
        ASS GI12 = GI11
        ASS JI12 = JI11
        MATH j = j - 1
        MATH jPlusOne = j + 1
        ASS isSetSort = 0
        IF j >= 0
          IF GI11 < keyVal
            ASS isSetSort = 1
          END
        END
      END
      ASS GI12 = keyVal
      ASS JI12 = keyBool
      MATH i = i + 1
    END
  END
END

IF LOAD

  # constant

  ALIAS 10 arpIndexOffset

  # local
  ALIAS I0 iter
  ALIAS I1 isSet
  ALIAS I2 arpIndex
  ALIAS I3 numPressedTotal
  ALIAS I4 max
  ALIAS I5 maxIndex
  ALIAS I6 secondMax
  ALIAS I7 secondMaxIndex
  ALIAS I8 tempPhraseVal
  ALIAS I9 phraseIndex

  # global
  ALIAS G1 numPressed
  ALIAS G2 arpPhraseToggle
  ALIAS G3 arpPhraseOnOffToggle
  ALIAS G7 arpValueModeMod
  ALIAS G8 setPhrase
  ALIAS GE gateOpened
  ALIAS GF phraseVal
  ALIAS G10 phraseLengthPlusOffset

  # assign local
  # NOTE technically K does not need to be reset here, since only L is parsed - doing so as good practice
  ASS J0 = 00 00 00 00 00 00 00 00 00 00
  ASS K0 = 00 00 00 00 00
  ASS L0 = 00 00 00 00 00

  ASS numPressedTotal = 0
  # needs to be set to a value too far for both negatives and positives to reach
  ASS tempPhraseVal = AAAA
  ASS phraseIndex = 2A
  
END

IF MT == B0
  IF M1 == 69 7F # TODO placeholder - two buttons at once? double tap?
    # on init, this should init the global array to something basic
    # NOTE init here?
    # consider making init file, where one sysex inits just the global array, the other all channels are cleared
    # channelmanage file? this would break with the one midi device to each SB instance
    # can also possibly save instances from multiple sessions using another StreamByter and +P

    # NOTE we could filter so that these messages only get sent to channels
    # this would depend on how much data an SB file could interpret at once, with keys and everything being passed through as well

    # NOTE depending on routing, we may just need to send one message
    # receiving a message that does not match the channel triggers an auto save (this may require some timer, since this might be a race condition)
    # signal previous channel file to save
    # signal next channel file to load
    # SEND F0 C4 MC G0 F7 +F

    # NOTE will need to send lighting to x touch for sure, but setting the global channel should be enough to change routing
    # NOTE need to review routing, because if only one channel can route through launchkeymini, only one channel can use these features at a time
    # this is fine (and expected) for live keyboard playing without latch, but will likely be an issue when using modstep

    # assign local variables
    ASS J0 = 00 00 00 00 00 00 00 00 00 00
    ASS K0 = 00 00 00 00 00
    ASS L0 = 00 00 00 00 00
    ASS numPressedTotal = 0
    ASS tempPhraseVal = AAAA
    ASS phraseIndex = 2A

    # assign global variables
    ASS G0 = MC

    # NOTE only necessary for implementing latch functionality
    # load local arrays for channel

    # NOTE ensure to block specific sysex input so it isn't passed out
  END
END

# if arp / phrase is on
IF arpPhraseOnOffToggle == 1
  # if arp / phrase is arp
  IF arpPhraseToggle == 0
    # if key is pressed
    IF MT == 90
      
      # setting arbitrary limit on number of keys pressed at a time to 10
      IF numPressed == 11
        ASS G20 = 00 00 00 00 00 00 00 00 00 00
        ASS J0 = 00 00 00 00 00 00 00 00 00 00
        ASS numPressed = 0
        ASS numPressedTotal = 0
        BLOCK
        EXIT
      END
      
      # add one to notes overall pressed
      MATH numPressedTotal = numPressedTotal + 1

      # store note value in first open spot in array
      MATH arpIndex = arpIndexOffset + numPressed
      ASS GI2 = M1
      ASS JI2 = numPressedTotal

      # sort array / hashmap according to ascending, descending, order pressed
      IF arpValueModeMod == 3
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod == 4
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod == 5
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod < 3
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod > 8
        INSERTION_SORT 1 numPressed
      END
      
      MATH numPressed = numPressed + 1

      IF numPressed == 1
        ASS gateOpened = 1
      END
      
      NX = XX +B
      
    END

    IF MT == 80
      # remove note value from array
      # decrease number of notes that need to be iterated through
      ASS iter = 10
      ASS isSet = 0
      WHILE isSet != 1
        # if iter is the note value, remove values
        IF GI0 == M1
          ASS GI0 = 0
          ASS JI0 = 0
          ASS isSet = 1
        END
        MATH iter = iter + 1
        IF iter == numPressed
          ASS isSet = 1
        END
      END
      
      # sort array / hashmap according to ascending, descending, order pressed
      IF arpValueModeMod == 3
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod == 4
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod == 5
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod < 3
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod > 8
        INSERTION_SORT 1 numPressed
      END
      
      MATH numPressed = numPressed - 1
      IF numPressed == 0
        ASS G20 = 00 00 00 00 00 00 00 00 00 00
        ASS J0 = 00 00 00 00 00 00 00 00 00 00
        ASS numPressedTotal = 0
      END
      
      NX = XX +B
      
    END
  # else isPhrase
  ELSE
    # if key pressed
    IF MT == 90
      
      # ASS gateOpened = 1 # NOTE uncommenting this would restart phrase whenever key pressed

      # setting arbitrary limit on number of keys pressed at a time to 5
      IF numPressed == 5
        ASS L0 = 00 00 00 00 00
        ASS numPressed = 0
        ASS numPressedTotal = 0
        BLOCK
        EXIT
      END
      
      # set initial note to calculate offset
      ASS phraseVal = M1
      
      # add to number of keys pressed
      MATH numPressed = numPressed + 1
      MATH numPressedTotal = numPressedTotal + 1
      
      # we need to have a while loop here to account for the user pressing and releasing keys in different orders
      # say user presses A, B, C, then lifts up B
      # this sets numPressed to 2, but when another key is pressed it will overwrite C if we continue linearly
      ASS iter = 1
      ASS isSet = 0
      WHILE isSet != 1
        IF LI0 == 0
          # add note value into K - this array's indices will all be >= 1
          ASS KI0 = M1
          # add note index in L to show it is pressed - this array's indices will all be >= 1
          ASS LI0 = numPressedTotal
          ASS isSet = 1
        END
        MATH iter = iter + 1
      END

      IF numPressed == 1
        ASS gateOpened = 1
      END
      
    END

    IF MT == 80
      # stop if no keys pressed
      MAT numPressed = numPressed - 1
      IF numPressed < 1
        ASS L0 = 00 00 00 00 00
        ASS numPressedTotal = 0
      END
      
      # find the max k value, or the most recent key pressed
      # if the j value, or note value of that max is M1, we need to change the phrase offset,
      # so reset the g values, setting G1 to the second most recent key pressed
      # while we are iterating, we need to set the k value of whichever key is pressed to zero so we can reuse that index
      ASS max = 0
      ASS secondMax = 0
      ASS iter = 1
      WHILE iter <= 5
        IF LI0 > max
          ASS secondMax = max
          ASS max = LI0
          ASS secondMaxIndex = maxIndex
          ASS maxIndex = iter
        ELSE
          IF LI0 > secondMax
            ASS secondMax = LI0
            ASS secondMaxIndex = iter
          END
        END
        IF KI0 == M1
          ASS LI0 = 0
        END
        MATH iter = iter + 1
      END
      IF KI5 == M1
        # set value equal to second most recent key pressed
        # ASS gateOpened = 1 # NOTE uncommenting this would restart phrase whenever key lifted
        ASS phraseVal = KI7
      END
      
    END

  END

END

IF setPhrase == 1
  IF MT == 90
    # because we're taking offset here, we need to record each step as the difference between it and the last step
    # if tempPhraseVal has a previous value (i.e. is not the first key pressed in the phrase)
    IF tempPhraseVal != AAAA
      MATH GI9 = M1 - tempPhraseVal
      ASS phraseLengthPlusOffset = phraseIndex
      MATH phraseIndex = phraseIndex + 1
      ASS tempPhraseVal = M1
    # else tempPhraseVal does not have a previous value, this is the first entered value, and no record in the global array is necessary
    ELSE
      ASS tempPhraseVal = M1
    END
    # if phrase is at max limit, end setPhrase
    IF phraseIndex > 39
      ASS setPhrase = 0
      ASS tempPhraseVal = AAAA
    END
  END
  # if phraseRest is sent
  # NOTE might need to filter the sysex messages here to prevent them from passing through and causing havoc
  IF M0 == F0 AA AA F7
    # assign value to AAAA, indicating a rest
    ASS GI9 = AAAA
    MATH phraseIndex = phraseIndex + 1

    # if phrase is at max limit, end setPhrase
    IF phraseIndex > 39
      ASS setPhrase = 0
      ASS tempPhraseVal = AAAA
    END
  END
  # ensure phraseIndex is reset when setPhrase is turned off from xtouch
  IF M0 == F0 BB BB 07
    ASS phraseIndex = AAAA
  END
  # NOTE could block whatever is inputted here
  # this would make sense if phrase was toggled and on, but not if this was not the case
END
