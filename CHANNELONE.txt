# channel one





# including original ARP.txt file here for reference

# FULL NO CLOCK
# TODO:
# Note limit
# Sorting by note order, ascending, descending depending on mode
# Adding octaves
# Adding individual gate knob for notes
# NOTE: this will definitely run into issues with single note arp, since the note off can possibly come after multiple clock sent
# Possibly investigate timing - being late on initial downbeat might not be preventing the second note from playing in order
# This is actually likely due to the order in which the keys are initially pressed - the first button pressed might be what is sent, then when the array is sorted it may be sorted into the second spot
# Add tempo halving / multiplying
# sort each time clock is sent via some process similar to selection sort? this could prevent the timing issue above

SUBROUTINE INSERTION_SORT_J length
  ALIAS I0 i
  ALIAS I1 j
  ALIAS I2 jPlusOne
  ALIAS I3 keyVal
  ALIAS I4 isSetSort
  ALIAS I5 keyBool
  ASS i = 1
  WHILE i < length
    ASS keyVal = JI0
    ASS keyBool = KI0
    MATH j = i - 1
    MATH jPlusOne = j + 1
    ASS isSetSort = 0
    IF j >= 0
      IF JI1 < keyVal
        ASS isSetSort = 1
      END
    END
    WHILE isSetSort == 1
      ASS JI2 = JI1
      ASS KI2 = KI1
      MATH j = j - 1
      MATH jPlusOne = j + 1
      ASS isSetSort = 0
      IF j >= 0
        IF JI1 < keyVal
          ASS isSetSort = 1
        END
      END
    END
    ASS JI2 = keyVal
    ASS KI2 = keyBool
    MATH i = i + 1
  END
END

#SUBROUTINE INSERTION_SORT_K length
#  ALIAS I0 i
#  ALIAS I1 j
#  ALIAS I2 jPlusOne
#  ALIAS I3 keyVal
#  ALIAS I4 isSet
#  ALIAS I5 keyBool
#  ASS i = 1
#  WHILE i < length
#    ASS keyVal = JI0
#    ASS keyBool = KI0
#    MATH j = i - 1
#    MATH jPlusOne = j + 1
#    ASS isSet = 0
#    IF j >= 0
#      IF JI1 < keyVal
#        ASS isSet = 1
#      END
#    END
#    WHILE isSet == 1
#      ASS JI2 = JI1
#      ASS KI2 = KI1
#      MATH j = j - 1
#      MATH jPlusOne = j + 1
#      ASS isSet = 0
#      IF j >= 0
#        IF JI1 < keyVal
#          ASS isSet = 1
#        END
#      END
#    END
#    ASS JI2 = keyVal
#    ASS KI2 = keyBool
#    MATH i = i + 1
#  END
#END

IF LOAD
  # array containing variables will be I
  # number of notes currently pressed does not matter here, since notes are only sent on clock, not on press
  # I6 will be number of notes that have been pressed total
  ASS I6 = 0
  ALIAS I6 numPressedTotal
  # I7 will be the iterator used
  ALIAS I7 iter
  # I8 will be a Boolean to run the note pressed while loop
  ALIAS I8 isSet
  # I9 will be the number of notes currently pressed
  ALIAS I9 numPressed
  # IA will be the index of the note to be played
  ALIAS IA noteIndex
  ASS noteIndex = 0
  # IB will be the clock reader
  ALIAS IB clock
  ASS clock = $-1
  # IC is numPressed - 1
  ALIAS IC numPressedMinusOne
  # ID is clockModulo
  ALIAS ID clockModulo
  # IE is gate
  ALIAS IE gate
  ASS gate = 0
  
  # array containing values will be J
  # array containing order pressed and signifying y or n will be K
  ASS J00 = 00 00 00 00 00 00 00 00 00 00 #$-1
  ASS K00 = 00 00 00 00 00 00 00 00 00 00 #$-1
  
END

IF MT == 90
  
  # setting arbitrary limit on number of keys pressed at a time to 10
  # IF numPressed == 11
  # ASS K0 = 00 00 00 00 00 00 00 00 00 00
  # ASS J0 = 00 00 00 00 00 00 00 00 00 00
  # ASS numHaveBeenPressed = 0
  # change global varIBble to turn off clock
  # BLOCK
  # EXIT
  # END
  
  # add one to notes overall pressed
  MAT numPressedTotal = numPressedTotal + 1
  
  # store note value in array
  ASS iter = 0
  ASS isSet = 0
  WHILE isSet != 1
    IF KI7 == 0
      ASS JI7 = M1
      ASS KI7 = numPressedTotal
      ASS isSet = 1
    END
    MATH iter = iter + 1
  END
  
  # sort array / hashmap according to ascending, descending, order pressed
  # IF button is pressed
  # INSERTION_SORT_K numPressed
  # ELSE
  INSERTION_SORT_J numPressed
  # END
  
  MATH numPressed = numPressed + 1
  IF numPressed == 1
    ASS gate = 1
  END
  
  NX = XX +B
  
END

IF MT == 80
  # remove note value from array
  # decrease number of notes that need to be iterated through
  ASS iter = 0
  ASS isSet = 0
  WHILE isSet != 1
    IF JI7 == M1
      ASS JI7 = 0
      ASS KI7 = 0
      ASS isSet = 1
    END
    MATH iter = iter + 1
    IF iter == numPressed
      ASS isSet = 1
    END
  END
  
  # sort array / hashmap according to ascending, descending, order pressed
  # IF button is pressed
  # INSERTION_SORT_K numPressed
  # ELSE
  INSERTION_SORT_J numPressed
  # END
  
  MATH numPressed = numPressed - 1
  IF numPressed == 0
    ASS gate = 0
    ASS clock = -1
    ASS noteIndex = 0
    ASS numPressedTotal = 0
    ASS K0 = 00 00 00 00 00 00 00 00 00 00
    ASS J0 = 00 00 00 00 00 00 00 00 00 00
  END
  
  NX = XX +B
  
END

IF M0 == F8
  IF gate == 1
    IF clock == $23
      ASS clock = 0
    ELSE
      MATH clock = clock + 1
    END
    MATH clockModulo = clock % 24
    IF clockModulo == 0
      MATH numPressedMinusOne = numPressed - 1
      # IF descending
      IF noteIndex < numPressedMinusOne
        MATH noteIndex = noteIndex + 1
      ELSE
        ASS noteIndex = 0
      END
      # ELSE ascending or order pressed
      #IF noteIndex > 0
      #  MATH noteIndex = noteIndex - 1
      #ELSE
      #  ASS noteIndex = numPressed
      #END
      SEND 90 JIA 64
      SEND 80 JIA 64 +D500
    END
  END
  F8 = F8 +B
END
