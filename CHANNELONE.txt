# channel one

# this instance will constantly be receiving clock, the question will be whether it responds to it or not
# there will be another service receiving note in - if arpPhraseOnOffToggle is on, notes will be processed, otherwise, they will not

# note that the assumption here is that the global array information will be used, not the local array
# the local array will just be used for storage

# possible future updates - addings 'reverse' and 'bounce' for phrase (stochastic etc. whatever)

# need to reassign arpIndex whenever mode is changed

# NOTE maxVal for clockNum is based off 227 * 288 = floor(65,535 / 288) * (ffff / lcm of all possible tempoPulse)

# arpTypes
# 1: ascending one octave
# 2: ascending two octave
# 3: ascending three octave
# 4: descending one octave
# 5: descending two octave
# 6: descending three octave
# 7: random one octave
# 8: random two octave
# 9: random three octave
# 10: order pressed one octave
# 11: order pressed two octave
# 12: order pressed three octave

IF LOAD
  # local
  ALIAS I0 maxValClockNum
  ALIAS I1 clockNum
  ALIAS I2 clockNumMod
  ALIAS I3 arpIndex
  ALIAS I4 isOctave
  ALIAS I5 isOctaveMod
  ALIAS I6 arpOctaveValue
  ALIAS I7 phraseValSend
  ALIAS I8 phraseIndex

  # global
  ALIAS G0 channel
  ALIAS G1 numPressed
  ALIAS G2 arpPhraseToggle
  ALIAS G3 arpPhraseOnOffToggle
  ALIAS G5 tempoPulse
  ALIAS G6 gate
  ALIAS G7 arpValueModeMod
  ALIAS GD velocity
  ALIAS GE gateOpened
  ALIAS GF phraseVal
  ALIAS G10 phraseLengthPlusOffset

  # assign local
  ASS maxValClockNum = FF60
  ASS clockNum = 0
  ASS isOctave = 0
END

# if channel is this channel (one)
IF channel == 1
  # if message is clock
  IF M0 == F8
    # if gate is open (numPressed is greater than zero)
    IF numPressed > 0
      # if arpPhraseOnOffToggle is on
      IF arpPhraseOnOffToggle == 1
        # process midi clock
        # maxVal = (floor of (ffff / lcm of all possible tempoPulse)) * lcm of all possible tempoPulse
        IF clockNum == maxValClockNum
          ASS clockNum = 0
        END
        IF gateOpened = 1
          ASS clockNum = 0 # NOTE might need to be reconfigured if clock signal is too fast for processing, as this may reset clock inadvertantly
        END
        MATH clockNumMod = clockNum % tempoPulse
        # if clockNum modulo the number set from above is zero, allow clock
        IF clockNumMod == 0
          # if isArp
          IF arpPhraseToggle == 0

            # if value mode is 0 (asc 1)
            IF arpValueModeMod == 0
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                MATH arpIndex = numPressed + 20
                ASS gateOpened = 0
              END
              # arpIndex will initially be set to numPressed + 32, but after it's set to numPressed + 32 - 1, it will be automatically decreased each run through
              # this decrease stops once we go under 32 - at that point it's reset
              MATH arpIndex = arpIndex - 1
              IF arpIndex == 1F
                MATH arpIndex = numPressed + 20
              END
              SEND 90 GI3 velocity
              SEND 80 GI3 velocity +DG6
            END
            # if value mode is 1 (asc 2)
            IF arpValueModeMod == 1
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                MATH arpIndex = numPressed + 20
                ASS isOctave = 0
                ASS gateOpened = 0
              END
              # if not isOctave, business as usual
              IF isOctave == 0
                MATH arpIndex = arpIndex - 1
                IF arpIndex == 1F
                  ASS arpIndex = numPressed + 20
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                ASS isOctave = 1
              # if isOctave, add 12 semitones and send that instead
              ELSE
                MATH arpOctaveValue = GI3 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                ASS isOctave = 0
              END
            END
            # if value mode is 2 (asc 3)
            IF arpValueModeMod == 2
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                MATH arpIndex = numPressed + 20
                ASS isOctave = 0
                ASS gateOpened = 0
              END
              MATH isOctaveMod = isOctave % 3
              # if isOctaveMod is 0, business as usual
              IF isOctaveMod == 0
                MATH arpIndex = arpIndex - 1
                IF arpIndex == 1F
                  MATH arpIndex = numPressed + 20
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 1, add 12 semitones and send that instead
              IF isOctaveMod == 1
                MATH arpOctaveValue = GI3 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 2, add 24 semitones and send that instead
              IF isOctaveMod == 2
                MATH arpOctaveValue = GI3 + $24 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
            END
            # if value mode is 3 (desc 1)
            IF arpValueModeMod == 3
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                ASS arpIndex = 1F
                ASS gateOpened = 0
              END
              # arpIndex will initially be set to 31, but after it's set to 32, it will be automatically increased each run through
              # this increase stops once we go over numPressed - at that point it's reset
              MATH arpIndex = arpIndex + 1
              MATH numPressedOffset = numPressed + 20
              IF arpIndex >= numPressedOffset
                ASS arpIndex = 1F
              END
              SEND 90 GI3 velocity
              SEND 80 GI3 velocity +DG6
            END
            # if value mode is 4 (desc 2)
            IF arpValueModeMod == 4
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                ASS arpIndex = 1F
                ASS isOctave = 0
                ASS gateOpened = 0
              END
              # if not isOctave, business as usual
              IF isOctave == 0
                MATH arpIndex = arpIndex + 1
                MATH numPressedOffset = numPressed + 20
                IF arpIndex >= numPressedOffset
                  ASS arpIndex = 1F
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                ASS isOctave = 1
              # if isOctave, add 12 semitones and send that instead
              ELSE
                MATH arpOctaveValue = GI3 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                ASS isOctave = 0
              END
            END
            # if value mode is 5 (desc 3)
            IF arpValueModeMod == 5
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                ASS arpIndex = 1F
                ASS isOctave = 0
                ASS gateOpened = 0
              END
              MATH isOctaveMod = isOctave % 3
              # if isOctaveMod is 0, business as usual
              IF isOctaveMod == 0
                MATH arpIndex = arpIndex + 1
                MATH numPressedOffset = numPressed + 20
                IF arpIndex >= numPressedOffset
                  ASS arpIndex = 1F
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                ASS isOctave = 1
              END
              # if isOctaveMod is 1, add 12 semitones and send that instead
              IF isOctaveMod == 1
                MATH arpOctaveValue = GI3 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 2, add 24 semitones and send that instead
              IF isOctaveMod == 2
                MATH arpOctaveValue = GI3 + $24 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # NOTE could use if else here, have chosen not to because I think this is more readable
              # NOTE also might be able to multiply isOctaveMod by 12, add, and always send arpOctaveValue
              # NOTE could make this a subroutine
            END
            # if value mode is 6 (rand 1)
            IF arpValueModeMod == 6
              MATH arpIndex = RFF % numPressed
              SEND 90 GI3 velocity
              SEND 80 GI3 velocity +DG6
            END
            # if value mode is 7 (rand 2)
            IF arpValueModeMod == 7
              # NOTE this is completely random - thus ignoring the note played before it - the octave will not necessarily match up with previous note
              MATH arpIndex = RFF % numPressed
              MATH isOctaveMod = RFF % 2
              # if not isOctaveMod, business as usual
              IF isOctaveMod == 0
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
              # if isOctaveMod, add 12 semitones and send that instead
              ELSE
                MATH arpOctaveValue = GI3 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
              END
            END
            # if value mode is 8 (rand 3)
            IF arpValueModeMod == 8
              MATH arpIndex = RFF % numPressed
              MATH isOctaveMod = RFF % 3
              # if isOctaveMod is 0, business as usual
              IF isOctave == 0
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
              END
              # if isOctaveMod is 1, add 12 semitones and send that instead
              IF isOctave == 1
                MATH arpOctaveValue = GI3 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
              END
              # if isOctaveMod is 2, add 24 semitones and send that instead
              IF isOctave == 2
                MATH arpOctaveValue = GI3 + $24 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
              END
            END
            # NOTE this currently appears the same as the general asc - this is because the way they are sorted will be the same
            # if value mode is 9 (order 1)
            IF arpValueModeMod == 9
              IF gateOpened == 1
                MATH arpIndex = numPressed + 20
                ASS gateOpened = 0
              END
              # arpIndex will initially be set to numPressed + 32, but after it's set to numPressed + 32 - 1, it will be automatically decreased each run through
              # this decrease stops once we go under 32 - at that point it's reset
              MATH arpIndex = arpIndex - 1
              IF arpIndex == 1F
                MATH arpIndex = numPressed + 20
              END
              SEND 90 GI3 velocity
              SEND 80 GI3 velocity +DG6
            END
            # if value mode is 20 (order 2)
            IF arpValueModeMod == A
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                MATH arpIndex = numPressed + 20
                ASS isOctave = 0
                ASS gateOpened = 0
              END
              # if not isOctave, business as usual
              IF isOctave == 0
                MATH arpIndex = arpIndex - 1
                IF arpIndex == 1F
                  MATH arpIndex = numPressed + 20
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                ASS isOctave = 1
              # if isOctave, add 12 semitones and send that instead
              ELSE
                MATH arpOctaveValue = GI3 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                ASS isOctave = 0
              END
            END
            # if value mode is 11 (order 3)
            IF arpValueModeMod == B
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                MATH arpIndex = numPressed + 20
                ASS isOctave = 0
                ASS gateOpened = 0
              END
              MATH isOctaveMod = isOctave % 3
              # if isOctaveMod is 0, business as usual
              IF isOctaveMod == 0
                MATH arpIndex = arpIndex - 1
                IF arpIndex == 1F
                  MATH arpIndex = numPressed + 20
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 1, add 12 semitones and send that instead
              IF isOctaveMod == 1
                MATH arpOctaveValue = GI3 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 2, add 24 semitones and send that instead
              IF isOctaveMod == 2
                MATH arpOctaveValue = GI3 + $24 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
            END
          # else isPhrase
          # because we need the phrase to be relative, we'll need the global array to contain offset, not note value
          # offset will be used in conjunction with note in, also stored in the global array
          # additionally, -1 implies a rest, so nothing will be played
          ELSE
            # if gateOpened, or if first instance of clock since first key was pressed
            IF gateOpened == 1
              MATH phraseIndex = 2A
              ASS gateOpened = 0
            END
            # if phrase offset is not a rest
            IF GI8 != AAAA
              MATH phraseValSend = phraseVal + GI8
              SEND 90 phraseValSend velocity
              SEND 80 phraseValSend velocity +DG6
            END
            IF phraseIndex != phraseLengthPlusOffset
              MATH phraseIndex = phraseIndex + 1
            ELSE
              ASS phraseIndex = 2A
            END
          END
        ELSE
          XX = XX +B
        END
        MATH clockNum = clockNum + 1
      ELSE
        XX = XX +B
      END
    ELSE
      XX = XX +B 
    END
  ELSE
    XX = XX +B
  END
ELSE
  XX = XX +B
END
