# channel one

# this instance will constantly be receiving clock, the question will be whether it responds to it or not
# there will be another service receiving note in - if arpPhraseOnOffToggle is on, notes will be processed, otherwise, they will not

# note that the assumption here is that the global array information will be used, not the local array
# the local array will just be used for storage

# possible future updates - addings 'reverse' and 'bounce' for phrase (stochastic etc. whatever)

# need to reassign arpIndex whenever mode is changed

# NOTE will need to assign isOctave as 0 whenever mode is changed - might need to make global
# NOTE this is the same with arpIndex

# NOTE maxVal for clockNum is based off 227 * 288 = floor(65,535 / 288) * (ffff / lcm of all possible tempoPulse)

# arpTypes
# 1: ascending one octave
# 2: ascending two octave
# 3: ascending three octave
# 4: descending one octave
# 5: descending two octave
# 6: descending three octave
# 7: random one octave
# 8: random two octave
# 9: random three octave
# 10: order pressed one octave
# 11: order pressed two octave
# 12: order pressed three octave

# NOTE j (arp values) offset is 10 (16) and k (arp order pressed) is 1A (26)

IF LOAD
  # local
  ALIAS I0 maxValClockNum
  ALIAS I1 clockNum
  ALIAS I2 clockNumMod
  ALIAS I3 arpIndex
  ALIAS I4 isOctave
  ALIAS I5 isOctaveMod
  ALIAS I6 arpOctaveValue
  ALIAS I7 phraseValSend

  # global
  ALIAS G0 channel
  ALIAS G1 numPressed
  ALIAS G2 arpPhraseToggle
  ALIAS G3 arpPhraseOnOffToggle
  ALIAS G5 tempoPulse
  ALIAS G6 gate
  ALIAS G7 arpValueModeMod
  ALIAS GD velocity
  # ALIAS GX phraseLengthPlusOffset (likely global)
  # ALIAS GY phraseIndex
  # ALIAS GZ phraseVal

  # assign local
  ASS maxValClockNum = FF60
  ASS clockNum = 0
  ASS arpIndex = 0F # TODO this needs to be rethought, since arpIndex will only be 10 when arp is ascending - I believe this will have to be global
  # NOTE this is for asc and order
  # NOTE arpIndex = numPressed + 10 ($16) for desc
  # NOTE arpIndex val doesn't matter for random
  ASS isOctave = 0
END

# if channel is this channel (one)
IF channel == 1
  # if message is clock
  IF M0 == F8
    # if gate is open (numPressed is greater than zero)
    IF numPressed > 0
      # if arpPhraseOnOffToggle is on
      IF arpPhraseOnOffToggle == 1
        # process midi clock
        # maxVal = (floor of (ffff / lcm of all possible tempoPulse)) * lcm of all possible tempoPulse
        IF clockNum == maxValClockNum
          ASS clockNum = 0
        END
        MATH clockNumMod = clockNum % tempoPulse
        # if clockNum modulo the number set from above is zero, allow clock
        IF clockNumMod == 0
          # if isArp
          IF arpPhraseToggle == 0
            # note that this entire process is tricky due to possible ordering of values
            # it is automatically descending
            # these will need to be saved in the global array

            # if value mode is 0 (asc 1)
            IF arpValueModeMod == 0
              # arpIndex will initially be set to numPressed + 16, but after it's set to numPressed + 16 - 1, it will be automatically decreased each run through
              # this decrease stops once we go under 16 - at that point it's reset
              MATH arpIndex = arpIndex - 1
              IF arpIndex == 0F
                MATH arpIndex = numPressed + 10
              END
              SEND 90 GI3 velocity
              SEND 80 GI3 velocity +DG6
            END
            # if value mode is 1 (asc 2)
            IF arpValueModeMod == 1
              # if not isOctave, business as usual
              IF isOctave == 0
                MATH arpIndex = arpIndex - 1
                IF arpIndex == 0F
                  ASS arpIndex = numPressed + 10
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                ASS isOctave = 1
              # if isOctave, add 12 semitones and send that instead
              ELSE
                MATH arpOctaveValue = GI3 + $12 # TODO see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                ASS isOctave = 0
              END
            END
            # if value mode is 2 (asc 3)
            IF arpValueModeMod == 2
              MATH isOctaveMod = isOctave % 3
              # if isOctaveMod is 0, business as usual
              IF isOctaveMod == 0
                MATH arpIndex = arpIndex - 1
                IF arpIndex == 0F
                  ASS arpIndex = numPressed + 10
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 1, add 12 semitones and send that instead
              IF isOctaveMod == 1
                MATH arpOctaveValue = GI3 + $12 # TODO see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 2, add 24 semitones and send that instead
              IF isOctaveMod == 2
                MATH arpOctaveValue = GI3 + $24 # TODO see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
            END
            # if value mode is 3 (desc 1)
            IF arpValueModeMod == 3
              # arpIndex will initially be set to 15, but after it's set to 16, it will be automatically increased each run through
              # this increase stops once we go over numPressed - at that point it's reset
              MATH arpIndex = arpIndex + 1
              IF arpIndex >= numPressed
                ASS arpIndex = 10
              END
              SEND 90 GI3 velocity
              SEND 80 GI3 velocity +DG6
            END
            # if value mode is 4 (desc 2)
            IF arpValueModeMod == 4
              # if not isOctave, business as usual
              IF isOctave == 0
                MATH arpIndex = arpIndex + 1
                IF arpIndex >= numPressed
                  ASS arpIndex = 10
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                ASS isOctave = 1
              # if isOctave, add 12 semitones and send that instead
              ELSE
                MATH arpOctaveValue = GI3 + $12 # TODO see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                ASS isOctave = 0
              END
            END
            # if value mode is 5 (desc 3)
            IF arpValueModeMod == 5
              MATH isOctaveMod = isOctave % 3
              # if isOctaveMod is 0, business as usual
              IF isOctaveMod == 0
                MATH arpIndex = arpIndex + 1
                IF arpIndex >= numPressed
                  ASS arpIndex = 10
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                ASS isOctave = 1
              END
              # if isOctaveMod is 1, add 12 semitones and send that instead
              IF isOctaveMod == 1
                MATH arpOctaveValue = GI3 + $12 # TODO see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 2, add 24 semitones and send that instead
              IF isOctaveMod == 2
                MATH arpOctaveValue = GI3 + $24 # TODO see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # NOTE could use if else here, have chosen not to because I think this is more readable
              # NOTE also might be able to multiply isOctaveMod by 12, add, and always send arpOctaveValue
              # NOTE could make this a subroutine
            END
            # if value mode is 6 (rand 1)
            IF arpValueModeMod == 6
              MATH arpIndex = RFF % numPressed
              SEND 90 GI3 velocity
              SEND 80 GI3 velocity +DG6
            END
            # if value mode is 7 (rand 2)
            IF arpValueModeMod == 7
              # NOTE this is completely random - thus ignoring the note played before it - the octave will not necessarily match up with previous note
              MATH arpIndex = RFF % numPressed
              MATH isOctaveMod = RFF % 2
              # if not isOctaveMod, business as usual
              IF isOctaveMod == 0
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
              # if isOctaveMod, add 12 semitones and send that instead
              ELSE
                MATH arpOctaveValue = GI3 + $12 # TODO see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
              END
            END
            # if value mode is 8 (rand 3)
            IF arpValueModeMod == 8
              MATH arpIndex = RFF % numPressed
              MATH isOctaveMod = RFF % 3
              # if isOctaveMod is 0, business as usual
              IF isOctave == 0
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
              END
              # if isOctaveMod is 1, add 12 semitones and send that instead
              IF isOctave == 1
                MATH arpOctaveValue = GI3 + $12 # TODO see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
              END
              # if isOctaveMod is 2, add 24 semitones and send that instead
              IF isOctave == 2
                MATH arpOctaveValue = GI3 + $24 # TODO see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
              END
            END
            # NOTE this currently appears the same as the general asc - this is because the way they are sorted will be the same
            # if value mode is 9 (order 1)
            IF arpValueModeMod == 9
              # arpIndex will initially be set to numPressed + 16, but after it's set to numPressed + 16 - 1, it will be automatically decreased each run through
              # this decrease stops once we go under 16 - at that point it's reset
              MATH arpIndex = arpIndex - 1
              IF arpIndex == 0F
                MATH arpIndex = numPressed + 10
              END
              SEND 90 GI3 velocity
              SEND 80 GI3 velocity +DG6
            END
            # if value mode is 10 (order 2)
            IF arpValueModeMod == A
              # if not isOctave, business as usual
              IF isOctave == 0
                MATH arpIndex = arpIndex - 1
                IF arpIndex == 0F
                  ASS arpIndex = numPressed + 10
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                ASS isOctave = 1
              # if isOctave, add 12 semitones and send that instead
              ELSE
                MATH arpOctaveValue = GI3 + $12 # TODO see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                ASS isOctave = 0
              END
            END
            # if value mode is 11 (order 3)
            IF arpValueModeMod == B
              MATH isOctaveMod = isOctave % 3
              # if isOctaveMod is 0, business as usual
              IF isOctaveMod == 0
                MATH arpIndex = arpIndex - 1
                IF arpIndex == 0F
                  ASS arpIndex = numPressed + 10
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 1, add 12 semitones and send that instead
              IF isOctaveMod == 1
                MATH arpOctaveValue = GI3 + $12 # TODO see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 2, add 24 semitones and send that instead
              IF isOctaveMod == 2
                MATH arpOctaveValue = GI3 + $24 # TODO see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
            END
          # else isPhrase
          # because we need the phrase to be relative, we'll need the global array to contain offset, not note value
          # offset will be used in conjunction with note in, also stored in the global array
          # additionally, -1 implies a rest, so nothing will be played
          ELSE
            MATH phraseValSend = phraseVal + GGX
            SEND 90 phraseValSend velocity # TODO
            SEND 80 phraseValSend velocity +DG6 # TODO
            IF phraseIndex != phraseLengthPlusOffset
              MATH phraseIndex = phraseIndex + 1
            ELSE
              MATH phraseIndex = 24 # NOTE may need to be changed if array k is removed
            END
          END
        ELSE
          XX = XX +B
        END
      ELSE
        XX = XX +B
      END
    ELSE
      XX = XX +B 
    END
  ELSE
    XX = XX +B
  END
ELSE
  XX = XX +B
END
