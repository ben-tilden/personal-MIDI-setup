# channel one

# this instance will constantly be receiving clock, the question will be whether it responds to it or not
# there will be another service receiving note in - if arpPhraseOnOffToggle is on, notes will be processed, otherwise, they will not

# note that the assumption here is that the global array information will be used, not the local array
# the local array will just be used for storage

# possible future updates - addings 'reverse' and 'bounce' for phrase (stochastic etc. whatever)

# arpTypes
# 1: ascending one octave
# 2: ascending two octave
# 3: ascending three octave
# 4: descending one octave
# 5: descending two octave
# 6: descending three octave
# 7: random one octave
# 8: random two octave
# 9: random three octave
# 10: order pressed one octave
# 11: order pressed two octave
# 12: order pressed three octave

# clockNum
# clockNumMod
# randMod
# arpPhraseOnOffToggle
# arpPhraseToggle
# arpValueModeMod
# phraseIndex
# phraseIndexInit
# phraseLength
# numPressed
# isOctave (make sure to reset whenever arpMode is changed - either that or add more variables)
# velocity
# arpOctaveValue

# if channel is this channel (one)
IF G0 == 1
  # if message is clock
  IF M0 == F8
    # if arpPhraseOnOffToggle is on
    IF arpPhraseOnOffToggle == 1
      # process midi clock
      # note that this MAXVAL will be relative to tempoPulse - we can set constant(s?) based on a factor of all tempoPulse options
      IF clockNum == # TODO find stand in MAXVAL
        ASS clockNum = 0
      END
      MATH clockNumMod = clockNum % tempoPulse
      # if clockNum modulo the number set from above is zero, allow clock
      IF clockNumMod == 0
        # if isArp
        IF arpPhraseToggle == 0
          # note that this entire process is tricky due to possible ordering of values
          # it is automatically descending
          # array j would contain the values locally
          # array k would contain the order pressed locally
          # it looks like these will need to be saved in the global array

          #MATH numPressedMinusOne = numPressed - 1
          #IF arpIndex < numPressedMinusOne
          #  MATH arpIndex = arpIndex + 1
          #ELSE
          #  ASS arpIndex = 0
          #END
          # ELSE ascending or order pressed
          #IF arpIndex > 0
          #  MATH arpIndex = arpIndex - 1
          #ELSE
          #  ASS arpIndex = numPressed
          #END
          #SEND 90 JIA 64
          #SEND 80 JIA 64 +D500

          # if value mode is 0 (asc 1)
          IF arpValueModeMod == 0

          END
          # if value mode is 1 (asc 2)
          IF arpValueModeMod == 1

          END
          # if value mode is 2 (asc 3)
          IF arpValueModeMod == 2

          END
          # if value mode is 3 (desc 1)
          IF arpValueModeMod == 3
            # arpIndex will initially be set to -1, but after it's set to zero, it will be automatically increased each run through
            # this increase stops once we go past numPressed - at that point it's reset
            MATH arpIndex = arpIndex + 1
            IF arpIndex >= numPressed
              ASS arpIndex = 0
            END
            # SEND 90 G(arpIndex) (velocity)
            # SEND 80 G(arpIndex) (velocity) +D(gate)
          END
          # if value mode is 4 (desc 2)
          IF arpValueModeMod == 4
            # if not isOctave, business as usual
            IF isOctave == 0
              MATH arpIndex = arpIndex + 1
              IF arpIndex >= numPressed
                ASS arpIndex = 0
              END
              # SEND 90 G(arpIndex) (velocity)
              # SEND 80 G(arpIndex) (velocity) +D(gate)
              ASS isOctave = 1
            # if isOctave, add 12 semitones and send that instead
            ELSE
              MATH arpOctaveValue = G(arpIndex) + $12 # TODO see if this should be -12 or +12
              # SEND 90 arpOctaveValue (velocity)
              # SEND 80 arpOctaveValue (velocity) +D(gate)
              ASS isOctave = 0
            END
          END
          # if value mode is 5 (desc 3)
          IF arpValueModeMod == 5
            MATH isOctaveMod = isOctave % 3
            # if isOctaveMod is 0, business as usual
            IF isOctaveMod == 0
              MATH arpIndex = arpIndex + 1
              IF arpIndex >= numPressed
                ASS arpIndex = 0
              END
              # SEND 90 G(arpIndex) (velocity)
              # SEND 80 G(arpIndex) (velocity) +D(gate)
              MATH isOctave = isOctave + 1
            END
            # if isOctaveMod is 1, add 12 semitones and send that instead
            IF isOctaveMod == 1
              MATH arpOctaveValue = G(arpIndex) + $12 # TODO see if this should be -12 or +12
              # SEND 90 arpOctaveValue (velocity)
              # SEND 80 arpOctaveValue (velocity) +D(gate)
              MATH isOctave = isOctave + 1
            END
            # if isOctaveMod is 2, add 24 semitones and send that instead
            IF isOctaveMod == 2
              MATH arpOctaveValue = G(arpIndex) + $24
              # SEND 90 arpOctaveValue (velocity)
              # SEND 80 arpOctaveValue (velocity) +D(gate)
              MATH isOctave = isOctave + 1
            END
            # NOTE could use if else here, have chosen not to because I think this is more readable
            # NOTE also might be able to multiply isOctaveMod by 12, add, and always send arpOctaveValue
          END
          # if value mode is 6 (rand 1)
          IF arpValueModeMod == 6
           # MATH randMod = RFF % numNotes 
          END
          # if value mode is 7 (rand 2)
          IF arpValueModeMod == 7

          END
          # if value mode is 8 (rand 3)
          IF arpValueModeMod == 8

          END
          # if value mode is 9 (order 1)
          IF arpValueModeMod == 9
           # MATH randMod = RFF % numNotes 
          END
          # if value mode is 10 (order 2)
          IF arpValueModeMod == A

          END
          # if value mode is 11 (order 3)
          IF arpValueModeMod == B

          END
        # else isPhrase
        ELSE
          # SEND 90 G(phraseIndex) (velocity)
          # SEND 80 G(phraseIndex) (velocity) +D(gate)
          IF phraseIndex != phraseLength
            MATH phraseIndex = phraseIndex + 1
          ELSE
            MATH phraseIndex = phraseIndexInit
          END
        END
      ELSE
        XX = XX +B
      END
    ELSE
      XX = XX +B
    END
  ELSE
    XX = XX +B
  END
ELSE
  XX = XX +B
END


# including original ARP.txt file here for reference
# also including what was build out in XTOUCH.txt

# this is code that this file will not have to deal with, since it deals directly with clock / note in
# clockNum
# clockNumMod
# randMod

# if it is a clock input
IF M0 == F8
 IF arpPhraseOnOffToggle == 1
   # if arp / phrase is on
   # note that this MAXVAL will be relative to tempoPulse - we can set constant(s?) based on a factor of all tempoPulse options
   IF clockNum == # TODO find stand in MAXVAL
     ASS clockNum = 0
   END
   MATH clockNumMod = clockNum % tempoPulse
   # if clockNum modulo the number set from above is zero, allow clock
   IF clockNumMod == 0
     # if isArp
     IF arpPhraseToggle == 0
       # if value mode is 0 (asc 1)
       IF arpValueModeMod == 0

       END
       # if value mode is 1 (asc 2)
       IF arpValueModeMod == 1

       END
       # if value mode is 2 (asc 3)
       IF arpValueModeMod == 2

       END
       # if value mode is 3 (desc 1)
       IF arpValueModeMod == 3

       END
       # if value mode is 4 (desc 2)
       IF arpValueModeMod == 4

       END
       # if value mode is 5 (desc 3)
       IF arpValueModeMod == 5

       END
       # if value mode is 6 (rand 1)
       IF arpValueModeMod == 6
         # MATH randMod = RFF % numNotes 
       END
       # if value mode is 7 (rand 2)
       IF arpValueModeMod == 7

       END
       # if value mode is 8 (rand 3)
       IF arpValueModeMod == 8

       END
     # else isPhrase
     ELSE
     
     END
   # else block clock
   ELSE

   END

 ELSE
 END

 F8 = XX +B

 # add one to clockNum
 MATH clockNum = clockNum + 1
END

# FULL NO CLOCK
# TODO:
# Note limit
# Sorting by note order, ascending, descending depending on mode
# Adding octaves
# Adding individual gate knob for notes
# NOTE: this will definitely run into issues with single note arp, since the note off can possibly come after multiple clock sent
# Possibly investigate timing - being late on initial downbeat might not be preventing the second note from playing in order
# This is actually likely due to the order in which the keys are initially pressed - the first button pressed might be what is sent, then when the array is sorted it may be sorted into the second spot
# Add tempo halving / multiplying
# sort each time clock is sent via some process similar to selection sort? this could prevent the timing issue above

SUBROUTINE INSERTION_SORT_J length
  ALIAS I0 i
  ALIAS I1 j
  ALIAS I2 jPlusOne
  ALIAS I3 keyVal
  ALIAS I4 isSetSort
  ALIAS I5 keyBool
  ASS i = 1
  WHILE i < length
    ASS keyVal = JI0
    ASS keyBool = KI0
    MATH j = i - 1
    MATH jPlusOne = j + 1
    ASS isSetSort = 0
    IF j >= 0
      IF JI1 < keyVal
        ASS isSetSort = 1
      END
    END
    WHILE isSetSort == 1
      ASS JI2 = JI1
      ASS KI2 = KI1
      MATH j = j - 1
      MATH jPlusOne = j + 1
      ASS isSetSort = 0
      IF j >= 0
        IF JI1 < keyVal
          ASS isSetSort = 1
        END
      END
    END
    ASS JI2 = keyVal
    ASS KI2 = keyBool
    MATH i = i + 1
  END
END

#SUBROUTINE INSERTION_SORT_K length
#  ALIAS I0 i
#  ALIAS I1 j
#  ALIAS I2 jPlusOne
#  ALIAS I3 keyVal
#  ALIAS I4 isSet
#  ALIAS I5 keyBool
#  ASS i = 1
#  WHILE i < length
#    ASS keyVal = JI0
#    ASS keyBool = KI0
#    MATH j = i - 1
#    MATH jPlusOne = j + 1
#    ASS isSet = 0
#    IF j >= 0
#      IF JI1 < keyVal
#        ASS isSet = 1
#      END
#    END
#    WHILE isSet == 1
#      ASS JI2 = JI1
#      ASS KI2 = KI1
#      MATH j = j - 1
#      MATH jPlusOne = j + 1
#      ASS isSet = 0
#      IF j >= 0
#        IF JI1 < keyVal
#          ASS isSet = 1
#        END
#      END
#    END
#    ASS JI2 = keyVal
#    ASS KI2 = keyBool
#    MATH i = i + 1
#  END
#END

IF LOAD
  # array containing variables will be I
  # number of notes currently pressed does not matter here, since notes are only sent on clock, not on press
  # I6 will be number of notes that have been pressed total
  ASS I6 = 0
  ALIAS I6 numPressedTotal
  # I7 will be the iterator used
  ALIAS I7 iter
  # I8 will be a Boolean to run the note pressed while loop
  ALIAS I8 isSet
  # I9 will be the number of notes currently pressed
  ALIAS I9 numPressed
  # IA will be the index of the note to be played
  ALIAS IA arpIndex
  ASS arpIndex = 0
  # IB will be the clock reader
  ALIAS IB clock
  ASS clock = $-1
  # IC is numPressed - 1
  ALIAS IC numPressedMinusOne
  # ID is clockModulo
  ALIAS ID clockModulo
  # IE is gate
  ALIAS IE gate
  ASS gate = 0
  
  # array containing values will be J
  # array containing order pressed and signifying y or n will be K
  ASS J00 = 00 00 00 00 00 00 00 00 00 00 #$-1
  ASS K00 = 00 00 00 00 00 00 00 00 00 00 #$-1
  
END

IF MT == 90
  
  # setting arbitrary limit on number of keys pressed at a time to 10
  # IF numPressed == 11
  # ASS K0 = 00 00 00 00 00 00 00 00 00 00
  # ASS J0 = 00 00 00 00 00 00 00 00 00 00
  # ASS numHaveBeenPressed = 0
  # change global varIBble to turn off clock
  # BLOCK
  # EXIT
  # END
  
  # add one to notes overall pressed
  MAT numPressedTotal = numPressedTotal + 1
  
  # store note value in array
  ASS iter = 0
  ASS isSet = 0
  WHILE isSet != 1
    IF KI7 == 0
      ASS JI7 = M1
      ASS KI7 = numPressedTotal
      ASS isSet = 1
    END
    MATH iter = iter + 1
  END
  
  # sort array / hashmap according to ascending, descending, order pressed
  # IF button is pressed
  # INSERTION_SORT_K numPressed
  # ELSE
  INSERTION_SORT_J numPressed
  # END
  
  MATH numPressed = numPressed + 1
  IF numPressed == 1
    ASS gate = 1
  END
  
  NX = XX +B
  
END

IF MT == 80
  # remove note value from array
  # decrease number of notes that need to be iterated through
  ASS iter = 0
  ASS isSet = 0
  WHILE isSet != 1
    IF JI7 == M1
      ASS JI7 = 0
      ASS KI7 = 0
      ASS isSet = 1
    END
    MATH iter = iter + 1
    IF iter == numPressed
      ASS isSet = 1
    END
  END
  
  # sort array / hashmap according to ascending, descending, order pressed
  # IF button is pressed
  # INSERTION_SORT_K numPressed
  # ELSE
  INSERTION_SORT_J numPressed
  # END
  
  MATH numPressed = numPressed - 1
  IF numPressed == 0
    ASS gate = 0
    ASS clock = -1
    ASS arpIndex = 0
    ASS numPressedTotal = 0
    ASS K0 = 00 00 00 00 00 00 00 00 00 00
    ASS J0 = 00 00 00 00 00 00 00 00 00 00
  END
  
  NX = XX +B
  
END

IF M0 == F8
  IF gate == 1
    IF clock == $23
      ASS clock = 0
    ELSE
      MATH clock = clock + 1
    END
    MATH clockModulo = clock % $24
    IF clockModulo == 0
      MATH numPressedMinusOne = numPressed - 1
      # IF descending
      IF arpIndex < numPressedMinusOne
        MATH arpIndex = arpIndex + 1
      ELSE
        ASS arpIndex = 0
      END
      # ELSE ascending or order pressed
      #IF arpIndex > 0
      #  MATH arpIndex = arpIndex - 1
      #ELSE
      #  ASS arpIndex = numPressed
      #END
      SEND 90 JIA 64
      SEND 80 JIA 64 +D500
    END
  END
  F8 = F8 +B
END
