// launchkey mini (mk2)

@OnLoad

  // minimal layout
  ShowLayout 4

  // timer
  SetTimerInterval 200

  // constant
  phraseSysexOffsetConstant = 42 // NOTE artifact of initial SB setup - could be cleaned up

  channel = 1 // channel specific

  Call @InitVariables

@End

// timer

@OnTimer
  latchTiming = 1
  StopTimer
  ResetTimer
@End

// sysex reception

@OnSysex

  ReceiveSysex sysexData

  // ALLOW 11 C1
  // BLOCK CC 0F 01 FF 3F 9F (+ xtouch program change, key presses, key releases, and CC's)
  if sysexData[0] <> 0x11 and sysexData[0] <> 0xC1
    Exit

  elseif sysexData[1] = 0xEE
    SendMIDIOut sysexData[2], sysexData[3], sysexData[4]
    Exit

  // clock message triggered by host clock starting
  elseif sysexData[0] = 0x7D and sysexData[1] = 0x01
    Exit

  elseif sysexData[1] = 0x01
    arpPhraseToggle = sysexData[2]
    // if module is currently on
    if arpPhraseOnOffToggle = 1
      // need to open gate so that there's a smooth transition here
      sendData = [0xCC, 0x19, 0x60]
      SendSysex sendData, 3
    endif
    Exit

  elseif sysexData[1] = 0x02
    arpPhraseOnOffToggle = sysexData[2]
    if arpPhraseOnOffToggle = 1 and keysPressed > 0
      // need to open gate so that there's a smooth transition here
      sendData = [0xCC, 0x19, 0x60]
      SendSysex sendData, 3
    elseif keysPressed > 0 and latch = 1
      for i = 0 to keysPressed - 1
        SendMIDINoteOn channel, keyValuesPressed[i], velocity
        // NOTE bad timing here can prevent latch from picking up the value - can be avoided fairly consistently with arpMute
        // the delayed noteOff can come at just the wrong time
        // this mostly occurs when gate is longer and is mostly noticeable when there are fewer notes
        // this can be avoided by using infiniteGate when transitioning to latch
      endfor
    endif
    Exit

  elseif sysexData[1] = 0x05
    velocity = sysexData[2]
    Exit

  elseif sysexData[1] = 0x06
    arpValueModeMod = sysexData[2]
    Exit

  // NOTE should setPhrase turn latch off? Not currently the case
  elseif sysexData[1] = 0x07
    setPhrase = sysexData[2]
    if setPhrase = 0
      phraseIndex = 0
      tempPhraseVal = 43690
    endif
    Exit

  elseif sysexData[1] = 0x0B
    latch = sysexData[2]
    if latch = 0 and keysPressed > 0
      for i = 0 to keysPressed - 1
        keyValuesPressed[i] = 0
        keyOrderPressed[i] = 0
      endfor

      keysPressed = 0
      keysPressedTotal = 0

      sendData = [0xCC, 0x20]
      for i = 2 to 11
        sendData[i] = keyValuesPressed[i - 2]
      endfor
      SendSysex sendData, 12

      sendData = [0xCC, 0x00, keysPressed]
      SendSysex sendData, 3

    elseif keysPressed > 0
      // handle if latch turned on after notes have been pressed
      // NOTE at this point, this is more of an edge case
      StartTimer
      latchTiming = 0
      for i = 0 to keysPressed - 1
        latchkeysPressed = latchKeysPressed + 1
      endfor
    endif
    Exit

  // if phraseRest is sent
  elseif sysexData[1] = 0x1A and setPhrase = 1
    // NOTE could add this code to a handler and use here and below - doesn't change that much
    // assign value to 128, indicating a rest
    phraseValues[phraseIndex] = 128 // 2E57

    phraseTemp = phraseIndex + phraseSysexOffsetConstant // artifact of initial SB setup - could be changed
    sendData = [0xCC, phraseTemp, phraseValues[phraseIndex]]
    SendSysex sendData, 3

    sendData = [0xCC, 0x0A, phraseIndex] // phraseLength - 1, or last index of phrase
    SendSysex sendData, 3

    phraseIndex = phraseIndex + 1
    // if phrase is at max limit, end setPhrase
    if phraseIndex > 31
      setPhrase = 0
      sendData = [0xFF, 0x07, setPhrase]
      SendSysex sendData, 3
      phraseIndex = 0
      tempPhraseVal = 43690
    endif

  endif

@End

// end sysex reception

@OnMIDICC
  // channel changed on release - should be released when hold released on launchkey
  // NOTE pressing a button / key and changing the channel before note off is not supported
  // channel change should use two hands, so hoping this will not come up

  // NOTE currently there is no overlap between launchkey's CC buttons and other CC out we're going for
  // if a situation arises where this is the case, we'll need to remap launchkey initially

  // full reset - channel irrelevant
  if MIDIByte2 = 0x68 and MIDIByte3 = 0x7F
    Call @InitVariables
    Exit

  elseif MIDIChannel <> channel
    Exit

  elseif MIDIByte2 = 0x7F
    // this causes issues with launchkey if velocity is zero, since it registers as a note off
    if MIDIByte3 = 0
      keyPressVelocity = 1
    else
      keyPressVelocity = MIDIByte3
    endif

  elseif MIDIByte2 = 0x6B and MIDIByte3 = 0x00

    // send channel change sysex
    sendData = [0xFF, 0x1E, 0xCC]
    SendSysex sendData, 3

    // send channel sysex
    sendData = [0x3F, 0x4B, channel]
    SendSysex sendData, 3

    Exit

  // arp mute
  elseif MIDIByte2 = 0x6C and MIDIByte3 = 0x7F
    arpMute = 1
    sendData = [0xCC, 0x4A, arpMute]
    SendSysex sendData, 3
    Exit

  elseif MIDIByte2 = 0x6C and MIDIByte3 = 0x00
    arpMute = 0
    sendData = [0xCC, 0x4A, arpMute]
    SendSysex sendData, 3
    Exit

  // infinite gate
  elseif MIDIByte2 = 0x6D and MIDIByte3 = 0x7F
    infiniteGate = (infiniteGate + 1) % 2
    sendData = [0xCC, 0x4C, infiniteGate] // currently inconsistent notation, since this also is used by processing filter
    SendSysex sendData, 3
    Exit

  // channel reset
  elseif MIDIByte2 = 0x6A and MIDIByte3 = 0x7F
    Call @InitVariables

  endif

@End

@InitVariables
  // reset sysex variables

  arpPhraseToggle = 0
  arpPhraseOnOffToggle = 0
  arpValueModeMod = 0
  arpMute = 0
  velocity = 100
  keyPressVelocity = 100
  latch = 0

  for i = 0 to 9
    keyValuesPressed[i] = 0
  endfor
  keysPressed = 0

  for i = 0 to 31
    phraseValues[i] = 0
  endfor
  setPhrase = 0
  phraseVal = 60
  phraseIndex = 0

  // reset local

  for i = 0 to 9
    keyOrderPressed[i] = 0
  endfor
  keysPressedTotal = 0

  tempPhraseVal = 43690 // fka AAAA; needs to be set to a value too far for both negatives and positives to reach
  overload = 0

  latchTiming = 1
  latchKeysPressed = 0

  // reset xtouch lighting and params and, indirectly, lfo and launchkey mapping filter
  sendData = [0xFF, 0x1B, 0x00]
  SendSysex sendData, 3

  // reset channel information, processing filter, and xtouch mapping filter
  sendData = [0xCC, 0x1C, 0x00]
  SendSysex sendData, 3

@End

@OnMIDINoteOn

  // don't process any non-channel data
  if MIDIChannel <> channel
    Exit
  endif

  // RESET

  // if reset (keys pressed limit exceeded), handle differently
  if overload = 1
    keysPressed = keysPressed + 1
    if latch = 1
      latchKeysPressed = latchKeysPressed + 1
    endif
    sendData = [0xCC, 0x00, keysPressed]
    SendSysex sendData, 3
    Exit
  endif

  // setting arbitrary limit on number of keys pressed at a time to 10 (using 10 as comparator here because keysPressed has not yet been increased)
  if keysPressed = 10
    Call @gateReset
    overload = 1
    arpMute = 1
    sendData = [0xCC, 0x4A, arpMute]
    SendSysex sendData, 3
    // necessary so that keysPressed does not go past zero by mistake, as we have not yet incremented for this key press
    keysPressed = keysPressed + 1
    if latch = 1
      latchKeysPressed = latchKeysPressed + 1
    endif
    sendData = [0xCC, 0x00, keysPressed]
    SendSysex sendData, 3

    Exit
  endif

  // LATCH

  if latch = 1
    if latchTiming = 1 // no need to send notes / reset arrays if no keys are currently recognized as pressed
      StartTimer
      latchTiming = 0
      // reset arrays and send note releases
      if keysPressed > 0 // necessary because for loops include 0 on 'for i = 0 to 0'
        for i = 0 to keysPressed - 1
          // NOTE ideally would not have to send MIDINoteOff from launchkey, due to possible issues it can create in processing
          // this is currently handled, however
          SendMIDINoteOff channel, keyValuesPressed[i], 0x00
          keyValuesPressed[i] = 0
          keyOrderPressed[i] = 0
        endfor
        keysPressed = 0
        keysPressedTotal = 0
      endif
    endif
    latchKeysPressed = latchKeysPressed + 1
  endif

  // PHRASE

  // set initial note to calculate offset
  phraseVal = MIDINote
  sendData = [0xCC, 0x08, phraseVal]
  SendSysex sendData, 3

  // ALL

  // add one to notes overall pressed
  keysPressedTotal = keysPressedTotal + 1

  // store note value in first open spot in array
  // NOTE this uses keysPressed, which should be set to 0 before first key is pressed
  keyValuesPressed[keysPressed] = MIDINote
  keyOrderPressed[keysPressed] = keysPressedTotal

  // add one to current notes pressed
  // NOTE this is done before sorting to make sure proper length is parsed
  // this is done after array assignment so that the alignment with keysPressed is accurate in setting
  keysPressed = keysPressed + 1
  sendData = [0xCC, 0x00, keysPressed]
  SendSysex sendData, 3

  // ARP

  // sort array / hashmap according to ascending, descending, order pressed
  Call @InsertionSort
  sendData = [0xCC, 0x20]
  for i = 2 to 11
    sendData[i] = keyValuesPressed[i - 2]
  endfor
  SendSysex sendData, 12

  // ALL

  if keysPressed >= 1
    // gateOpened
    sendData = [0xCC, 0x19, 0x60]
    SendSysex sendData, 3
  endif

  if setPhrase = 1
    // because we're taking offset here, we need to record each step as the difference between it and the last step
    // if tempPhraseVal has a previous value (i.e. is not the first key pressed in the phrase)
    // NOTE max phrase length at this point is 32
    if tempPhraseVal = 43690 // AAAA
      tempPhraseVal = MIDINote
    endif

    phraseValues[phraseIndex] = MIDINote - tempPhraseVal

    phraseTemp = phraseIndex + phraseSysexOffsetConstant // artifact of initial SB setup - could be changed
    sendData = [0xCC, phraseTemp, phraseValues[phraseIndex]]
    SendSysex sendData, 3

    sendData = [0xCC, 0x0A, phraseIndex] // phraseLength - 1, or last index of phrase
    SendSysex sendData, 3

    phraseIndex = phraseIndex + 1
    // if phrase is at max limit, end setPhrase 
    if phraseIndex > 31
      setPhrase = 0
      sendData = [0xFF, 0x07, setPhrase]
      SendSysex sendData, 3
      phraseIndex = 0
      tempPhraseVal = 43690
    endif
    // NOTE could block whatever is inputted here, to prevent notes from passing through while the phrase is running
    // this would make sense if phrase was toggled and on, but not if this was not the case
  endif

  if arpPhraseOnOffToggle <> 1
    SendMIDIOut MIDIByte1, MIDIByte2, keyPressVelocity
  endif

@End


@OnMIDINoteOff

  // don't process any non-channel data
  if MIDIChannel <> channel
    Exit
  endif

  // if reset (key pressed limit exceeded), handle differently
  if overload = 1
    keysPressed = keysPressed - 1
    if latch = 1
      latchKeysPressed = latchKeysPressed - 1
    endif
    sendData = [0xCC, 0x00, keysPressed]
    SendSysex sendData, 3
    if keysPressed = 0
      overload = 0
      arpMute = 0
      sendData = [0xCC, 0x4A, arpMute]
      SendSysex sendData, 3
    endif
    SendMIDIThru
    Exit
  endif

  // LATCH

  if latch = 1 or latchKeysPressed <> 0
    latchKeysPressed = latchKeysPressed - 1
    Exit
  endif

  // ALL (max for PHRASE)

  // find the max order value, or the most recent key pressed
  // if the note value of that max is M1, we need to change the phrase offset
  // while we are iterating, we need to set the order value of whichever key is released to zero so we can reuse that index
  max = 0
  valOfMax = 0
  secondMax = 0
  valOfSecondMax = 0
  for i = 0 to keysPressed - 1
    if keyOrderPressed[i] > max
      secondMax = max
      valOfSecondMax = valOfMax
      max = keyOrderPressed[i]
      valOfMax = keyValuesPressed[i]
    ELSE
      if keyOrderPressed[i] > secondMax
        secondMax = keyOrderPressed[i]
        valOfSecondMax = keyValuesPressed[i]
      endif
    endif
    if keyValuesPressed[i] = MIDINote
      keyValuesPressed[i] = 0
      keyOrderPressed[i] = 0
    endif
  endfor

  // PHRASE

  if valOfMax = MIDINote
    // set value equal to second most recent key pressed
    // gateOpened = 1 // NOTE uncommenting this and sending sysex would restart phrase whenever key lifted
    phraseVal = valOfSecondMax
    sendData = [0xCC, 0x08, phraseVal]
    SendSysex sendData, 3
  endif

  // ARP

  // sort array / hashmap according to ascending, descending, order pressed
  Call @InsertionSort
  sendData = [0xCC, 0x20]
  for i = 2 to 11
    sendData[i] = keyValuesPressed[i - 2]
  endfor
  SendSysex sendData, 12

  // ALL

  // subtract one from current notes pressed
  // NOTE this is done after sorting to make sure any removed values are pushed out
  keysPressed = keysPressed - 1
  sendData = [0xCC, 0x00, keysPressed]
  SendSysex sendData, 3

  if keysPressed = 0
    Call @gateReset
  elseif keysPressed > 0 and arpPhraseToggle = 1
    // gateOpened - only send if phrase
    sendData = [0xCC, 0x19, 0x60]
    SendSysex sendData, 3
  endif

  if arpPhraseOnOffToggle <> 1
    SendMIDIThru
  endif

@End

@gateReset
  for i = 0 to 9
    keyValuesPressed[i] = 0
  endfor
  sendData = [0xCC, 0x20]
  for i = 2 to 11
    sendData[i] = keyValuesPressed[i - 2]
  endfor
  SendSysex sendData, 12
  for i = 0 to 9
    keyOrderPressed[i] = 0
  endfor
  keysPressedTotal = 0
  phraseVal = 60
  sendData = [0xCC, 0x08, phraseVal]
  SendSysex sendData, 3
@End

@InsertionSort

  // sort by value
  if arpValueModeMod < 6 and keysPressed > 1
    for i = 1 to keysPressed - 1

      keyVal = keyValuesPressed[i]
      keyOrder = keyOrderPressed[i]

      j = i - 1
      // NOTE stopLoop necessary because conditionals for loops check simultaneously and not sequentially
      // can do this here because j will never be less than zero at this point
      if j > -1 and keyValuesPressed[j] < keyVal
        stopLoop = 0
      else
        stopLoop = 1
      endif

      while stopLoop = 0
        keyValuesPressed[j + 1] = keyValuesPressed[j]
        keyOrderPressed[j + 1] = keyOrderPressed[j]
        j = j - 1
        if j < 0
          stopLoop = 1
        elseif keyValuesPressed[j] >= keyVal
          stopLoop = 1
        endif
      endwhile

      keyValuesPressed[j + 1] = keyVal
      keyOrderPressed[j + 1] = keyOrder
    endfor

  // sort by keys pressed
  elseif arpValueModeMod > 8 and keysPressed > 1
    for i = 1 to keysPressed - 1

      keyVal = keyValuesPressed[i]
      keyOrder = keyOrderPressed[i]

      j = i - 1
      // NOTE stopLoop necessary because conditionals for loops check simultaneously and not sequentially
      // can do this here because j will never be less than zero at this point
      if j > -1 and keyOrderPressed[j] < keyOrder
        stopLoop = 0
      else
        stopLoop = 1
      endif

      while stopLoop = 0
        keyOrderPressed[j + 1] = keyOrderPressed[j]
        keyValuesPressed[j + 1] = keyValuesPressed[j]
        j = j - 1
        if j < 0
          stopLoop = 1
        elseif keyOrderPressed[j] >= keyOrder
          stopLoop = 1
        endif
      endwhile

      keyValuesPressed[j + 1] = keyVal
      keyOrderPressed[j + 1] = keyOrder
    endfor

  endif

@End
