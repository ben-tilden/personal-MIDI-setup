// sysex messages sent here:

// ALLOW | F0 01    0D    val1 val2 F7 lfoKnob
// ALLOW | F0 01    0E    val1 val2 F7 lfoSync
// ALLOW | F0 01    0F    val1 val2 F7 lfoBase
// ALLOW | F0 01    10    val1 val2 F7 lfoInvert
// ALLOW | F0 01    11    val1 val2 F7 lfoOnOff
// ALLOW | F0 01    12    val  F7      lfoMuteAll
// ALLOW | F0 01    13    val1 val2 F7 lfoType
// ALLOW | F0 01    14    val  F7      lfoReset
// ALLOW | F0 01    15    00   F7      lfoResetAll
// ALLOW | F0 01    16    val1 val2 F7 lfoRate
// ALLOW | F0 01    17    val1 val2 F7 lfoDepth
// ALLOW | F0 01    18    val1 F7      lfoTempo
// ALLOW | F0 01    19    00   F7      lfoInit

//order of modulation doesn't matter for bottom
//BOTTOM: 31.75 * (1 + sin(rx)) * (1 + sin(rx))
//ORIGINAL: (63.5 * sin(rx) + 63.5) * (.5 * sin(rx) + .5)

//middle is r2 modulating r1
//MIDDLE: 31.75 * sin(r1x) * (1 + sin(r2x)) + 63.5
//ORIGINAL: 63.5 * sin(r1x) * (.5 * sin(r2x) + .5) + 63.5

// NOTE tip: when using chain modulation, often the best results come from alternating inversion among the lfos

@OnSysex
  ReceiveSysex data
  // TEST
  Log data[0], { }, data[1], { }, data[2], { }, data[3]
  // END TEST

  // set target knob for lfo
  if data[1] = 13

    // NOTE could add multiple sources of modulation for lfos in the future if desired
    // NOTE chain modulating data will not be sent for lfo 1 - (see '# ensure attempting to chain modulate from lfo 1 exits gracefully')
    if data[3] < 8
      lfoTargetKnob[data[2]] = data[3] + 1 // need to add one since knob turn input is +1 from knob push input
    else
      lfoTargetKnob[data[2]] = data[3] - 13 // need to subtract 13 since knob turn input is -13 (18 - B) from knob push input
    endif

    // TEST
    // ensure target knob set correctly for lfo
    Log {Knob }, lfoTargetKnob[data[2]]
    Log {lfo }, data[2]
    // END TEST

  // set lfo to sync with tempo / not
  elseif data[1] = 14

    lfoSync[data[2]] = data[3]

    // TEST
    // ensure sync set correctly for lfo
    Log {Sync }, lfoSync[data[2]]
    Log {lfo }, data[2]
    // END TEST

  // set lfo to bottom / middle
  elseif data[1] = 15

    lfoBase[data[2]] = data[3]

    // TEST
    // ensure base set correctly for lfo
    Log {Base }, lfoBase[data[2]]
    Log {lfo }, data[2]
    // END TEST

  // set lfo to invert output values
  elseif data[1] = 16

    lfoInvert[data[2]] = data[3]

    // TEST
    // ensure invert set correctly for lfo
    Log {Invert }, lfoInvert[data[2]]
    Log {lfo }, data[2]
    // END TEST

  // turn off or on lfo
  elseif data[1] = 17

    lfoOnOff[data[2]] = data[3]

    // uncomment to restart on turning lfo on
    //if data[3] = 1
    //  ResetLfo data[2]
    //endif

    // TEST
    // ensure on/off set correctly for lfo
    Log {OnOff }, lfoOnOff[data[2]]
    Log {lfo }, data[2]
    // END TEST

  // mute all lfos
  elseif data[1] = 18

    lfoMuteAll = data[2]

    // TEST
    // ensure muteAll set correctly
    Log {lfoMuteAll }, lfoMuteAll
    // END TEST

  // setting lfo type
  elseif data[1] = 19

    if data[3] = 0
      setLFOType data[2], {Sine}
    elseif data[3] = 1
      setLFOType data[2], {Cosine}
    elseif data[3] = 2
      setLFOType data[2], {Square}
    elseif data[3] = 3
      setLFOType data[2], {Triangle}
    elseif data[3] = 4
      setLFOType data[2], {RampUp}
    elseif data[3] = 5
      setLFOType data[2], {RampDown}
    elseif data[3] = 6
      setLFOType data[2], {SH}
    endif

    // TEST
    // ensure type set correctly for lfo
    Log {Type }, data[3]
    Log {lfo }, data[2]
    // END TEST

  // restarting lfo
  elseif data[1] = 20

    ResetLfo data[2]

    // TEST
    // ensure lfo correctly restarts
    Log {Restart }, data[2]
    // END TEST

  // restarting all lfos
  elseif data[1] = 21

    for lfo = 0 to 3
      ResetLfo lfo
    endfor

    // TEST
    // ensure all lfos correctly restart
    Log {RestartAll }
    // END TEST

  // update lfo rate
  elseif data[1] = 22

    if lfoSync[lfo] = 1 and HostRunning = 1
      // +/- 16th notes = 9 total options
      for x = 0 to 8
        if data[3] >= syncVal[x] and data[3] < syncVal[x + 1]
          // hz for sync = hosttempo / 60 (times multiples of 2)
          lfoRate[data[2]] = (HostTempo / 60) * (Pow 2, -4 + x)
          SetupLFO data[2], 0, 127, no, lfoRate[data[2]]
        endif
      endfor
    else
      lfoRate[data[2]] = data[3] / 31.75
      SetupLFO data[2], 0, 127, no, lfoRate[data[2]]
    endif

    // TEST
    // ensure rate set correctly for lfo
    // ensure rate set correctly for lfo with sync on
    Log {Rate }, lfoRate[data[2]]
    Log {lfo }, data[2]
    // END TEST

  // update lfo depth
  elseif data[1] = 23

    lfoDepth[data[2]] = data[3] / 127

    // TEST
    // ensure depth set correctly for lfo
    Log {Depth }, lfoDepth[data[2]]
    Log {lfo }, data[2]
    // END TEST

  // update tempoMode
  elseif data[1] = 24

    tempoMode = data[2]

    // TEST
    // ensure tempoMode set correctly
    Log {tempoMode }, tempoMode
    // END TEST

  // init
  elseif data[1] = 29

    // SetMetroPPQN 20 is the metric we're going off here
    SetTimerInterval 25 // set for 120bpm ((60000 / bpm) / 20)
    StartTimer
    // init variables
    lfoTargetKnob = [0, 0, 0, 0]
    lfoSync = [0, 0, 0, 0]
    lfoBase = [0, 0, 0, 0]
    lfoInvert = [0, 0, 0, 0]
    lfoOnOff = [0, 0, 0, 0]
    lfoMuteAll = 0
    lfoRate = [0, 0, 0, 0]
    lfoDepth = [0, 0, 0, 0]
    lfoVal = [0, 0, 0, 0]
    SetupLFO 0, 0, 0, no, 0
    SetupLFO 1, 0, 0, no, 0
    SetupLFO 2, 0, 0, no, 0
    SetupLFO 3, 0, 0, no, 0
    tempoMode = 0
    tempoIndex = 0
    tempoZeroIndex = 0
    lfoView = 0
    // init constants
    syncVal = [0, 14, 28, 42, 56, 70, 84, 98, 112, 128]
    modeTempo = [24, 1, 26, 51, 76, 101] // 5
    modeZeroTempo = [12, 1, 14, 27, 40, 53, 66, 79, 92, 105, 118] // 10

    // TEST
    // ensure init received
    Log {lfo init}
    // END TEST

  endif
@End

@Onload
  // SetMetroPPQN 20 is the metric we're going off here
  SetTimerInterval 25 // set for 120bpm ((60000 / bpm) / 20)
  StartTimer
  // init variables
  lfoTargetKnob = [0, 0, 0, 0]
  lfoSync = [0, 0, 0, 0]
  lfoBase = [0, 0, 0, 0]
  lfoInvert = [0, 0, 0, 0]
  lfoOnOff = [0, 0, 0, 0]
  lfoMuteAll = 0
  lfoRate = [0, 0, 0, 0]
  lfoDepth = [0, 0, 0, 0]
  lfoVal = [0, 0, 0, 0]
  SetupLFO 0, 0, 0, no, 0
  SetupLFO 1, 0, 0, no, 0
  SetupLFO 2, 0, 0, no, 0
  SetupLFO 3, 0, 0, no, 0
  tempoMode = 0
  tempoIndex = 0
  tempoZeroIndex = 0
  lfoView = 0
  // init constants
  syncVal = [0, 14, 28, 42, 56, 70, 84, 98, 112, 128]
  modeTempo = [24, 1, 26, 51, 76, 101] // 5
  modeZeroTempo = [12, 1, 14, 27, 40, 53, 66, 79, 92, 105, 118] // 10
  // TEST
  // ensure load is correct
  Log {Load}
  logLFOs = 0
  // END TEST
@End

// uncomment this and elsewhere to set timer to send at different rates depending on tempo
//@OnHostStart
//  SetTimerInterval ((60000 / HostTempo) / 20)
//  Log {Host On: }, HostTempo
//@End

@OnTimer
  // uncomment this and elsewhere to set timer to send at different rates depending on tempo
  //if HostRunning = 1
  //  SetTimerInterval ((60000 / HostTempo) / 20) // would it hurt to make this constant?
  //endif
  //SetMetroPPQN if necessary
  if lfoMuteAll = 0
    for lfo = 3 to 0
      if lfoOnOff[lfo] = 1

        // TEST
        if logLFOs = 1
          Log {---OnTimer for loop iteration Start---}
          Log {lfoNum }, lfo
          Log {lfoVal BeforeGet }, lfoVal[lfo]
        endif
        // END TEST

        lfoVal[lfo] = GetLFOValue lfo

        // TEST
        if logLFOs = 1
          Log {lfoVal AfterGet }, lfoVal[lfo]
        endif
        // END TEST

        // handle chain modulating both rate (3) and depth (4)
        if lfoTargetKnob[lfo + 1] = 4 and lfoOnOff[lfo + 1] = 1
          // NOTE still unsure if this is the exact equation - seems to be extremely slightly lagging, but don't know why
          // overall arbitrary anyway
          SetupLFO lfo, 0, 127, no, (lfoVal[lfo + 1] / 127) * lfoRate[lfo] * 2
        elseif lfoTargetKnob[lfo + 1] = 5 and lfoOnOff[lfo + 1] = 1
          // NOTE for both of these, there is a conversion of the values to a sin wave that goes from -1 to 1
          // see equation at top
          if lfoBase[lfo] = 0
            // TEST
            // ensure base taken into consideration
            if logLFOs = 1
              Log {lfoBase bottom}, lfoBase[lfo]
            endif
            // END TEST
            // lfoVal[lfo] = 31.75 * (1 + ((lfoVal[lfo] / 63.5) - 1)) * (1 + ((lfoVal[lfo + 1] / 63.5) - 1))
            lfoVal[lfo] = 31.75 * (lfoVal[lfo] / 63.5) * (lfoVal[lfo + 1] / 63.5)
          else
            // TEST
            // ensure base taken into consideration
            if logLFOs = 1
              Log {lfoBase middle}, lfoBase[lfo]
            endif
            // END TEST
            // lfoVal[lfo] = 31.75 * ((lfoVal[lfo] / 63.5) - 1) * (1 + ((lfoVal[lfo + 1] / 63.5) - 1)) + 63.5
            lfoVal[lfo] = 31.75 * ((lfoVal[lfo] / 63.5) - 1) * (lfoVal[lfo + 1] / 63.5) + 63.5
          endif
        endif

        // TEST
        // ensure value takes depth into consideration
        if logLFOs = 1
          Log {BeforeDepth }, lfoVal[lfo]
        endif
        // END TEST

        lfoVal[lfo] = lfoVal[lfo] * lfoDepth[lfo]

        // TEST
        if logLFOs = 1
          Log {AfterDepth }, lfoVal[lfo]
        endif
        // END TEST

        if lfoInvert[lfo]

          // TEST
          // ensure value inverts
          if logLFOs = 1
            Log {BeforeInvert }, lfoVal[lfo]
          endif
          // END TEST

          lfoVal[lfo] = lfoVal[lfo] * -1 + 127

          // TEST
          if logLFOs = 1
            Log {AfterInvert }, lfoVal[lfo]
          endif
          // END TEST

        endif

        if lfoTargetKnob[lfo] = 1
          if tempoMode = 0
            tempoZeroIndex = Round (lfoVal[lfo] / 12.7)
            lfoVal[lfo] = modeZeroTempo[tempoZeroIndex]
          else
            tempoIndex = Round (lfoVal[lfo] / 25.4)
            lfoVal[lfo] = modeTempo[tempoIndex]
          endif
          // TEST
          // ensure tempo modulation works as expected
          if logLFOs = 1
            Log {tempoZeroIndex }, tempoZeroIndex
            Log {tempoMode }, tempoMode
            Log {tempoLfo }, lfo
            Log {tempoLfoVal }, lfoVal[lfo]
          endif
          // END TEST
        endif

        if lfoTargetKnob[lfo] <> 4 and lfoTargetKnob[lfo] <> 5
          SendMIDICC 10, lfoTargetKnob[lfo], lfoVal[lfo]
        endif

        // TEST
        SetXYValues 64, lfoVal[lfoView]
        if logLFOs = 1
          Log {---OnTimer for loop iteration End---}
        endif
        // END TEST
      endif
    endfor
  endif
@End

@OnPadDown
  lfoView = LastPad
  // TEST
  if logLFOs = 1
    logLFOs = 0
  else
    logLFOs = 1
  endif
  //END TEST
@End
