# launchkey mini (mk2)

# if phrase and arp are off, notes will be passed through as expected

IF LOAD

  SUBROUTINE INSERTION_SORT isOrder length
    ALIAS IF9 i
    ALIAS IFA j
    ALIAS IFB jPlusOne
    ALIAS IFC keyVal
    ALIAS IFD keyBool
    ALIAS IFE isSetSort
    ALIAS IFF lengthOffset

    MATH lengthOffset = length + 20

    IF isOrder == 1
      ASS i = 21
      WHILE i < lengthOffset
        ASS keyVal = KIF9
        ASS keyBool = JIF9
        MATH j = i - 1
        MATH jPlusOne = j + 1
        ASS isSetSort = 0
        IF j >= 20
          IF KIFA < keyVal
            ASS isSetSort = 1
          END
        END
        WHILE isSetSort == 1
          ASS KIFB = KIFA
          ASS JIFB = JIFA
          MATH j = j - 1
          MATH jPlusOne = j + 1
          ASS isSetSort = 0
          IF j >= 20
            IF KIFA < keyVal
              ASS isSetSort = 1
            END
          END
        END
        ASS KIFB = keyVal
        ASS JIFB = keyBool
        MATH i = i + 1
      END
    ELSE
      ASS i = 21
      WHILE i < lengthOffset
        ASS keyVal = JIF9
        ASS keyBool = KIF9
        MATH j = i - 1
        MATH jPlusOne = j + 1
        ASS isSetSort = 0
        IF j >= 20
          IF JIFA < keyVal
            ASS isSetSort = 1
          END
        END
        WHILE isSetSort == 1
          ASS JIFB = JIFA
          ASS KIFB = KIFA
          MATH j = j - 1
          MATH jPlusOne = j + 1
          ASS isSetSort = 0
          IF j >= 20
            IF JIFA < keyVal
              ASS isSetSort = 1
            END
          END
        END
        ASS JIFB = keyVal
        ASS KIFB = keyBool
        MATH i = i + 1
      END
    END
  END

  # global

  ALIAS G0 channel

  # constant

  ALIAS 04 channelVal # channel specific (obviously)
  ALIAS 20 arpIndexOffset
  ALIAS C8 latchInterval

  # local

  ALIAS I0 channelCC
  ALIAS I1 channelNoteOn
  ALIAS I2 channelNoteOff
  ALIAS I3 iter
  ALIAS I4 arpIndex
  ALIAS I5 numPressedTotal
  ALIAS I6 max
  ALIAS I7 valOfMax
  ALIAS I8 secondMax
  ALIAS I9 valOfSecondMax
  ALIAS IA tempPhraseVal
  ALIAS IB overload
  ALIAS IC phraseTemp
  ALIAS ID initLatch
  ALIAS IE latchTiming

  # sysex

  ALIAS J0 numPressed
  ALIAS J1 arpPhraseToggle
  ALIAS J2 arpPhraseOnOffToggle
  ALIAS J5 velocity
  ALIAS J6 arpValueModeMod
  ALIAS J7 setPhrase
  ALIAS J8 phraseVal
  ALIAS J9 phraseIndex
  ALIAS JA phraseLengthPlusOffset
  ALIAS JB latch

  # assign sysex variables

  ASS numPressed = 0
  ASS arpPhraseToggle = 0
  ASS arpPhraseOnOffToggle = 0
  ASS velocity = 64
  ASS arpValueModeMod = 0
  ASS setPhrase = 0
  ASS phraseVal = 3C
  ASS phraseIndex = 2A
  ASS phraseLengthPlusOffset = 2A
  ASS latch = 0
  ASS J20 = 00 00 00 00 00 00 00 00 00 00 # arp values (J10 J11 J12 J13 J14 J15 J16 J17 J18 J19)
  ASS J2A = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # phrase sequence (J2A J2B J2C J2D J2E J2F J30 J31 J32 J33 J34 J35 J36 J37 J38 J39 ETC.)

  # assign local

  # these are only defined here, since they are essentially constants - will not change past this
  MATH channelCC = B0 + channelVal
  MATH channelNoteOn = 90 + channelVal
  MATH channelNoteOff = 80 + channelVal

  ASS K20 = 00 00 00 00 00 00 00 00 00 00

  ASS numPressedTotal = 0
  ASS arpIndex = arpIndexOffset
  # needs to be set to a value too far for both negatives and positives to reach
  ASS tempPhraseVal = AAAA
  ASS overload = 0
  ASS initLatch = 1

  # reset xtouch lighting and params
  SEND F0 FF 1B 00 F7 +F

  # reset channel information
  SEND F0 CC 1C 00 F7 +F

END

# sysex reception

IF M0 == F0

  IF M2 == 01
    ASS arpPhraseToggle = M3
    # if module is currently on
    IF arpPhraseOnOffToggle == 1
      # need to open gate so that there's a smooth transition here
      # SEND SYSEX
      SEND F0 CC 19 60 F7 +F
      # END SYSEX
    END
    BLOCK
    EXIT
  END

  IF M2 == 02
    ASS arpPhraseOnOffToggle = M3
    # will need to send note release if latch is on
    IF latch == 1
      IF arpPhraseOnOffToggle == 1
        ASS iter = arpIndexOffset
        WHILE iter < arpIndex
          SEND channelNoteOff JI3 00
          MATH iter = iter + 1
        END
        # need to open gate so that there's a smooth transition here
        # SEND SYSEX
        SEND F0 CC 19 60 F7 +F
        # END SYSEX
      ELSE
        ASS iter = arpIndexOffset
        WHILE iter < arpIndex
          SEND channelNoteOn JI3 velocity
          MATH iter = iter + 1
        END
      END
    END
    BLOCK
    EXIT
  END

  IF M2 == 05
    ASS velocity = M3
    BLOCK
    EXIT
  END

  IF M2 == 06
    ASS arpValueModeMod = M3
    BLOCK
    EXIT
  END

  # NOTE should setPhrase turn latch off?
  IF M2 == 07
    ASS setPhrase = M3
    IF setPhrase == 0
      ASS phraseIndex = 2A
      ASS tempPhraseVal = AAAA
      FX = XX +B
    END
    BLOCK
    EXIT
  END

  IF M2 == 0B
    ASS latch = M3
      IF latch == 0
        ASS iter = arpIndexOffset
        WHILE iter < arpIndex
          SEND channelNoteOff JI3 00
          ASS JI3 = 0
          ASS KI3 = 0
          MATH iter = iter + 1
        END
        ASS numPressed = 0
        ASS numPressedTotal = 0
        ASS arpIndex = arpIndexOffset
        # SEND SYSEX
        SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
        # END SYSEX
        # SEND SYSEX
        SEND F0 CC 00 numPressed F7 +F
        # END SYSEX
      END
    BLOCK
    EXIT
  END
END

# end sysex reception

IF MT == B0
  # channel changed on release - should be released when hold released on launchkey
  # NOTE pressing a button / key and changing the channel before note off is not supported
  # channel change should use two hands, so hoping this will not come up
  # NOTE because this is what changes the hardware filter, the hardware filter will not properly filter out the channel change from any channel - needs to be set to receive channel specific channel change messages
  IF M0 == channelCC 6B 00

    # send channel change sysex
    # SEND SYSEX
    SEND F0 FF 1E CC F7 +F
    # END SYSEX

    # change channel variable here
    # NOTE currently global, but could change to sysex
    ASS channel = MC

    BLOCK
    EXIT
  END

  # full reset
  IF M1 == 68 7F

    # reset sysex variables

    ASS numPressed = 0
    ASS arpPhraseToggle = 0
    ASS arpPhraseOnOffToggle = 0
    ASS velocity = 64
    ASS arpValueModeMod = 0
    ASS setPhrase = 0
    ASS phraseVal = 3C
    ASS phraseIndex = 2A
    ASS phraseLengthPlusOffset = 2A
    ASS latch = 0
    ASS J20 = 00 00 00 00 00 00 00 00 00 00 # arp values (J10 J11 J12 J13 J14 J15 J16 J17 J18 J19)
    ASS J2A = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # phrase sequence (J2A J2B J2C J2D J2E J2F J30 J31 J32 J33 J34 J35 J36 J37 J38 J39 ETC.)

    # reset local

    ASS K20 = 00 00 00 00 00 00 00 00 00 00

    ASS numPressedTotal = 0
    ASS arpIndex = arpIndexOffset
    # needs to be set to a value too far for both negatives and positives to reach
    ASS tempPhraseVal = AAAA
    ASS overload = 0
    ASS initLatch = 1

    # reset xtouch lighting and params
    SEND F0 FF 1B 00 F7 +F

    # reset channel information
    SEND F0 CC 1C 00 F7 +F

    BLOCK
    EXIT
  END

  # channel reset
  IF M1 == 6A 7F

    # reset sysex variables

    ASS numPressed = 0
    ASS arpPhraseToggle = 0
    ASS arpPhraseOnOffToggle = 0
    ASS velocity = 64
    ASS arpValueModeMod = 0
    ASS setPhrase = 0
    ASS phraseVal = 3C
    ASS phraseIndex = 2A
    ASS phraseLengthPlusOffset = 2A
    ASS latch = 0
    ASS J20 = 00 00 00 00 00 00 00 00 00 00 # arp values (J10 J11 J12 J13 J14 J15 J16 J17 J18 J19)
    ASS J2A = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # phrase sequence (J2A J2B J2C J2D J2E J2F J30 J31 J32 J33 J34 J35 J36 J37 J38 J39 ETC.)

    # reset local

    ASS K20 = 00 00 00 00 00 00 00 00 00 00

    ASS numPressedTotal = 0
    ASS arpIndex = arpIndexOffset
    # needs to be set to a value too far for both negatives and positives to reach
    ASS tempPhraseVal = AAAA
    ASS overload = 0
    ASS initLatch = 1

    # reset xtouch lighting and params
    SEND F0 FF 1B 00 F7 +F

    # reset channel information
    SEND F0 CC 1C 00 F7 +F

    BLOCK
    EXIT
  END
END

IF M0 == channelNoteOn
  LOG channelNoteOn channelNoteOn
  LOG MT MT
  LOG M0 M0

  # RESET

  # if reset (key pressed limit exceeded), handle differently
  IF overload == 1
    MATH numPressed = numPressed + 1
    # SEND SYSEX
    SEND F0 CC 00 numPressed F7 +F
    # END SYSEX
    BLOCK
    EXIT
  END

  # setting arbitrary limit on number of keys pressed at a time to 10 (using 10 as comparator here because numPressed has not yet been increased)
  IF numPressed == A
    ASS J20 = 00 00 00 00 00 00 00 00 00 00
    # SEND SYSEX
    SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
    # END SYSEX
    ASS K20 = 00 00 00 00 00 00 00 00 00 00
    ASS overload = 1
    ASS numPressedTotal = 0
    ASS arpIndex = arpIndexOffset
    # necessary so that numPressed does not go past zero by mistake, as we have not yet incremented for this key press
    MATH numPressed = numPressed + 1
    # SEND SYSEX
    SEND F0 CC 00 numPressed F7 +F
    # END SYSEX
    ASS phraseVal = 3C
    # SEND SYSEX
    SEND F0 CC 08 phraseVal F7 +F
    # END SYSEX


    BLOCK
    EXIT
  END

  # LATCH

  IF latch == 1
    ASS latchTiming = T0
    # initLatch essentially performs timer reset, since timer is only reset on scene load
    # it prevents the overly large timer from being relevant on first ASS
    # if key press is NOT within time limit
    IF initLatch == 0
      IF latchTiming > latchInterval
        # reset arrays and send note releases
        ASS iter = arpIndexOffset
        WHILE iter < arpIndex
          # NOTE if the note value is the same as a value that has just been pressed, we need to resend the value, since that is what will be happening with any other overlapping values pressed
          SEND channelNoteOff JI3 00
          IF M1 == JI3
            SEND channelNoteOn JI3 velocity
          END
          ASS JI3 = 0
          ASS KI3 = 0
          MATH iter = iter + 1
        END
        ASS numPressed = 0
        ASS numPressedTotal = 0
        ASS arpIndex = arpIndexOffset
      END
    ELSE
      ASS initLatch = 0
    END
  END

  # PHRASE

  # set initial note to calculate offset
  ASS phraseVal = M1
  # SEND SYSEX
  SEND F0 CC 08 phraseVal F7 +F
  # END SYSEX

  # ALL

  # add one to notes overall pressed
  MATH numPressedTotal = numPressedTotal + 1

  # store note value in first open spot in array
  # NOTE this uses arpIndex, which should be set to arpIndexOffset before first key is pressed
  # after first key is pressed, arpIndex will be increased by numPressed (see below)
  ASS JI4 = M1
  ASS KI4 = numPressedTotal

  # add one to current notes pressed
  # NOTE this is done before sorting to make sure proper length is parsed
  # this is done after array assignment so that the alignment with arpIndex is accurate in setting
  MATH numPressed = numPressed + 1
  # SEND SYSEX
  SEND F0 CC 00 numPressed F7 +F
  # END SYSEX

  # NOTE this could also be MATH arpIndex = arpIndexOffset + numPressed
  MATH arpIndex = arpIndex + 1

  # ARP

  # sort array / hashmap according to ascending, descending, order pressed
  IF arpValueModeMod < 6
    INSERTION_SORT 0 numPressed
  END
  IF arpValueModeMod > 8
    INSERTION_SORT 1 numPressed
  END
  # SEND SYSEX
  SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
  # END SYSEX

  # ALL

  IF numPressed == 1
    # gateOpened
    # SEND SYSEX
    SEND F0 CC 19 60 F7 +F
    # END SYSEX
  END
  # TEST TRY
  #IF numPressed > 1
  #  ASS gateOpened = 2
  #END
  # END TEST TRY


  IF arpPhraseOnOffToggle == 1
    # only block notes if setPhrase is zero - if it's one, we need the setPhrase if statement to process the note
    IF setPhrase == 0
      NX = XX +B
    END
  END

END


LOG channelNoteOnPre channelNoteOn
LOG channelNoteOffPre channelNoteOff
LOG M0 M0
IF M0 == channelNoteOff
  LOG channelNoteOff channelNoteOff
  LOG MT MT
  LOG M0 M0

  # if reset (key pressed limit exceeded), handle differently
  IF overload == 1
    MATH numPressed = numPressed - 1
    # SEND SYSEX
    SEND F0 CC 00 numPressed F7 +F
    # END SYSEX
    IF numPressed == 0
      ASS overload = 0
    END
    BLOCK
    EXIT
  END

  # LATCH

  IF latch == 1
    BLOCK
    EXIT
  END

  # ALL (max for PHRASE)

  # find the max l value, or the most recent key pressed
  # if the k value, or note value of that max is M1, we need to change the phrase offset
  # while we are iterating, we need to set the l value of whichever key is released to zero so we can reuse that index
  ASS max = 0
  ASS valOfMax = 0
  ASS secondMax = 0
  ASS valOfSecondMax = 0
  ASS iter = arpIndexOffset
  WHILE iter < arpIndex
    IF KI3 > max
      ASS secondMax = max
      ASS valOfSecondMax = valOfMax
      ASS max = KI3
      ASS valOfMax = JI3
    ELSE
      IF KI3 > secondMax
        ASS secondMax = KI3
        ASS valOfSecondMax = JI3
      END
    END
    IF JI3 == M1
      ASS JI3 = 0
      ASS KI3 = 0
    END
    MATH iter = iter + 1
  END

  # PHRASE


  IF valOfMax == M1
    # set value equal to second most recent key pressed
    # ASS gateOpened = 1 # NOTE uncommenting this and sending sysex would restart phrase whenever key lifted
    ASS phraseVal = valOfSecondMax
    # SEND SYSEX
    SEND F0 CC 08 phraseVal F7 +F
    # END SYSEX
  END

  # ARP

  # sort array / hashmap according to ascending, descending, order pressed
  IF arpValueModeMod < 6
    INSERTION_SORT 0 numPressed
  END
  IF arpValueModeMod > 8
    INSERTION_SORT 1 numPressed
  END
  # SEND SYSEX
  SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
  # END SYSEX

  # ALL

  # subract one from current notes pressed
  # NOTE this is done after sorting to make sure any removed values are pushed out
  MATH numPressed = numPressed - 1
  # SEND SYSEX
  SEND F0 CC 00 numPressed F7 +F
  # END SYSEX

  MATH arpIndex = arpIndex - 1

  IF numPressed == 0
    ASS J20 = 00 00 00 00 00 00 00 00 00 00
    # SEND SYSEX
    SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
    # END SYSEX
    ASS K20 = 00 00 00 00 00 00 00 00 00 00
    ASS numPressedTotal = 0
    ASS arpIndex = arpIndexOffset
    ASS phraseVal = 3C
    # SEND SYSEX
    SEND F0 CC 08 phraseVal F7 +F
    # END SYSEX
  END


  IF arpPhraseOnOffToggle == 1
    NX = XX +B
  END

END

# NOTE could add these if statements to if statements above - I think this is slightly more readable
IF setPhrase == 1
  IF M0 == channelNoteOn
    # because we're taking offset here, we need to record each step as the difference between it and the last step
    # if tempPhraseVal has a previous value (i.e. is not the first key pressed in the phrase)
    # NOTE max phrase length at this point is 30
    IF tempPhraseVal == AAAA
      ASS tempPhraseVal = M1
    END
    MATH JJ9 = M1 - tempPhraseVal
    MATH phraseTemp = JJ9 / 100
    # SEND SYSEX
    SEND F0 CC phraseIndex phraseTemp JJ9 F7 +F
    # END SYSEX
    ASS phraseLengthPlusOffset = phraseIndex
    # SEND SYSEX
    SEND F0 CC 0A phraseLengthPlusOffset F7 +F
    # END SYSEX
    MATH phraseIndex = phraseIndex + 1
  END
  # if phraseRest is sent
  IF M2 == 1A 2E
    # assign value to 2E57, indicating a rest
    ASS JJ9 = 2E57
    # NOTE could remove math and hard code in 2E57
    MATH phraseTemp = JJ9 / 100
    # SEND SYSEX
    SEND F0 CC phraseIndex phraseTemp JJ9 F7 +F
    # END SYSEX
    ASS phraseLengthPlusOffset = phraseIndex
    # SEND SYSEX
    SEND F0 CC 0A phraseLengthPlusOffset F7 +F
    # END SYSEX
    MATH phraseIndex = phraseIndex + 1
  END
  # if phrase is at max limit, end setPhrase
  IF phraseIndex > 47
    ASS setPhrase = 0
    # SEND SYSEX
    SEND F0 FF 07 setPhrase F7 +F
    # END SYSEX
    ASS phraseIndex = 2A
    ASS tempPhraseVal = AAAA
  END
  FX = XX +B
  # block notes if phrase is on, since keypresses then should not make a noise
  IF arpPhraseOnOffToggle == 1
    NX = XX +B
  END
  # NOTE could block whatever is inputted here, to prevent notes from passing through while the phrase is running
  # this would make sense if phrase was toggled and on, but not if this was not the case
END
