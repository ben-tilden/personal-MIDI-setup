// channel one

// only happens when multiple note are pressed?
// TODO velocity might need to be sent separately for FM


@OnLoad

  // minimal layout
  ShowLayout 4

  // constant

  // NOTE maxVal for clockNum is based off 227 * 288 = floor(65,535 / 288) * (ffff / lcm of all possible tempoPulse)
  channel = 0 // channel specific (obviously)
  maxValClockNumNorm = 61560
  maxValClockNumEdge = 65400

  clockNum = 0
  isOctave = 0
  maxValClockNum = maxValClockNumNorm

  arpMode = 0
  modFactor = 1
  phraseSysexOffsetConstant = 42 // artifact of initial SB setup - could be changed

@End

// sysex reception

@OnSysex

  ReceiveSysex sysexData


  // ALLOW CC C1
  // BLOCK 11 0F 01 FF 3F (+ xtouch program change, key presses, key releases, and CC's)
  if sysexData[0] > 0xFC or sysexData[0] = 0x11 or sysexData[0] < 0xC1
    Exit

  // clock message triggered by host clock starting
  elseif sysexData[0] = 0x7D and sysexData[1] = 0x01
    Exit

  elseif sysexData[1] = 0x00
    numPressed = sysexData[2]
    if numPressed = 0
      // NOTE clockNum used to be reset by gateOpened, but was causing issues of multiple notes getting fired milliseconds apart (and overlapping in an awkward way)
      clockNum = 0
    endif
    Exit

  elseif sysexData[1] = 0x01
    arpPhraseToggle = sysexData[2]
    Exit

  elseif sysexData[1] = 0x02
    arpPhraseOnOffToggle = sysexData[2]
    Exit

  elseif sysexData[1] = 0x03
    tempoPulse = sysexData[2]
    if tempoPulse = 150 // 0x96
      maxValClockNum = maxValClockNumEdge
    else
      maxValClockNum = maxValClockNumNorm
    endif
    Exit

  elseif sysexData[1] = 0x04
    gate = sysexData[2] * 256 + sysexData[3] // 0x100
    Exit

  elseif sysexData[1] = 0x05
    velocity = sysexData[2]
    Exit

  elseif sysexData[1] = 0x06
    arpValueModeMod = sysexData[2]

    if arpValueModeMod = 0 or arpValueModeMod = 1 or arpValueModeMod = 2
      arpMode = 0 // asc
    elseif arpValueModeMod = 3 or arpValueModeMod = 4 or arpValueModeMod = 5
      arpMode = 1 // desc
    elseif arpValueModeMod = 6 or arpValueModeMod = 7 or arpValueModeMod = 8
      arpMode = 2 // rand
    elseif arpValueModeMod = 9 or arpValueModeMod = 10 or arpValueModeMod = 11
      arpMode = 3 // ord
    endif

    if arpMode = 0 or arpMode = 3 // asc, order
      initIndex = numPressed - 1 
      endIndex = 0
      iterConstant = -1
      arpIndex = initIndex
      octaveOffset = -1
    elseif arpMode = 1 // desc
      initIndex = 0
      endIndex = numPressed - 1
      iterConstant = 1
      arpIndex = initIndex
      octaveOffset = -1
    endif

    if arpValueModeMod = 0 or arpValueModeMod = 3 or arpValueModeMod = 6 or arpValueModeMod = 9
      modfactor = 1
    elseif arpValueModeMod = 1 or arpValueModeMod = 4 or arpValueModeMod = 7 or arpValueModeMod = 10
      modfactor = 2
    elseif arpValueModeMod = 2 or arpValueModeMod = 5 or arpValueModeMod = 8 or arpValueModeMod = 11
      modfactor = 3
    endif

    Exit

  elseif sysexData[1] = 0x08
    phraseVal = sysexData[2]
    Exit

  elseif sysexData[1] = 0x0A
    phraseLength = sysexData[2]
    Exit

  elseif sysexData[1] = 0x19
    gateOpened = 1
    Exit

  elseif sysexData[1] = 0x20
    for i = 2 to 11
      arpValues[i - 2] = sysexData[i]
    endfor
    Exit

  elseif sysexData[1] > 41 and sysexData[1] < 72
    // reset phraseValues if we're restarting
    if sysexData[1] = 42
      for i = 0 to 31
        phraseOffsetValues[i] = 0
      endfor
    endif
    setPhraseIndex = sysexData[1] - phraseSysexOffsetConstant // artifact of initial SB setup - could be changed
    if sysexData[2] <= 128
      phraseOffsetValues[setPhraseIndex] = sysexData[2]
    elseif sysexData[2] > 128
      phraseOffsetValues[setPhraseIndex] = sysexData[2] + -256 // negative value
    endif

    Exit

  elseif sysexData[1] = 0x4A
    arpMute = sysexData[2]
    Exit

  // reset channel when init sysex received
  elseif sysexData[1] = 0x1C and sysexData[2] = 0x00
    // (re)set sysex variables
    // NOTE could move this also into the init load for completeness (or remove local from init load?)

    numPressed = 0
    arpPhraseToggle = 0
    arpPhraseOnOffToggle = 0
    tempoPulse = 36 // 0x24
    gate = 0
    velocity = 100 // 0x64
    arpValueModeMod = 0
    phraseVal = 0
    phraseLength = 0
    gateOpened = 0
    arpMute = 0
    for i = 0 to 9
      arpValues[i] = 0
    endfor
    for i = 0 to 31
      phraseOffsetValues[i] = 0
    endfor

    // reset necessary local variables
    clockNum = 0
    isOctave = 0
    maxValClockNum = maxValClockNumNorm

  endif

@End

// end sysex reception

@HandleClockPattern
  octaveOffset = (octaveOffset + 1) % modFactor
  arpValSend = arpValues[arpIndex] + octaveOffset * 12
  SendMIDINoteOn channel, arpValSend, velocity
  SendMIDINoteOff channel, arpValSend, velocity, gate
  if octaveOffset = modFactor - 1 // NOTE a couple of ways to do this // TODO test
    if arpIndex = endIndex
      arpIndex = initIndex
    else
      arpIndex = arpIndex + iterConstant
    endif
  endif
@End

@HandleClockRandom
  octaveOffset = random 0, modFactor - 1
  arpIndex = random 0, numPressed - 1
  arpValSend = arpValues[arpIndex] + octaveOffset * 12
  SendMIDINoteOn channel, arpValSend, velocity
  SendMIDINoteOff channel, arpValSend, velocity, gate
@End

@OnMIDIInput
  if arpPhraseOnOffToggle = 1 and numPressed > 0 and MIDIByte1 = 0xF8
    // process midi clock
    // maxVal = (floor of (ffff / lcm of all possible tempoPulse)) * lcm of all possible tempoPulse
    if clockNum = maxValClockNum
      clockNum = 0
    endif

    if gateOpened = 1
      arpMute = 0
    endif

    if clockNum % tempoPulse = 0 // note sent - allow clock
      // if isArp
      if arpPhraseToggle = 0 and arpMute = 0

        // if gateOpened, or if first instance of clock since first key was pressed
        if gateOpened = 1 // NOTE could make handler out of the following, since used twice
          if arpMode = 0 or arpMode = 3 // asc, order
            initIndex = numPressed - 1 
            endIndex = 0
            iterConstant = -1
            arpIndex = initIndex
            octaveOffset = -1
          elseif arpMode = 1 // desc
            initIndex = 0
            endIndex = numPressed - 1
            iterConstant = 1
            arpIndex = initIndex
            octaveOffset = -1
          endif
          gateOpened = 0
        endif

        if arpMode = 2 // rand
          Call @HandleClockRandom
        else
          Call @HandleClockPattern
        endif

      // else isPhrase
      // because we need the phrase to be relative, we'll need the global array to contain offset, not note value
      elseif arpPhraseToggle = 1 and arpMute = 0
        // if gateOpened, or if first instance of clock since first key was pressed
        if gateOpened = 1
          phraseIndex = 0
          gateOpened = 0
        endif
        // if phrase offset is not a rest
        if phraseOffsetValues[phraseIndex] <> 128
          phraseValSend = phraseVal + phraseOffsetValues[phraseIndex]
          SendMIDINoteOn channel, phraseValSend, velocity
          SendMIDINoteOff channel, phraseValSend, velocity, gate
        endif
        if phraseIndex <> phraseLength // NOTE this is really phraseLength - 1
          phraseIndex = phraseIndex + 1
        else
          phraseIndex = 0
        endif
      endif
    endif
    clockNum = clockNum + 1
  endif

@End
