// sysex messages sent here:

// ALLOW | F0 01    0D    val1 val2 F7 lfoKnob
// ALLOW | F0 01    0E    val1 val2 F7 lfoSync
// ALLOW | F0 01    0F    val1 val2 F7 lfoBase
// ALLOW | F0 01    10    val1 val2 F7 lfoInvert
// ALLOW | F0 01    11    val1 val2 F7 lfoOnOff
// ALLOW | F0 01    12    val  F7      lfoMuteAll
// ALLOW | F0 01    13    val1 val2 F7 lfoType
// ALLOW | F0 01    14    val  F7      lfoReset
// ALLOW | F0 01    15    00   F7      lfoResetAll
// ALLOW | F0 01    16    val1 val2 F7 lfoRate
// ALLOW | F0 01    17    val1 val2 F7 lfoDepth

//order of modulation doesn't matter for bottom
//BOTTOM: 31.75 * (1 + sin(rx)) * (1 + sin(rx))
//ORIGINAL: (63.5 * sin(rx) + 63.5) * (.5 * sin(rx) + .5)

//middle is r2 modulating r1
//MIDDLE: 31.75 * sin(r1x) * (1 + sin(r2x)) + 63.5
//ORIGINAL: 63.5 * sin(r1x) * (.5 * sin(r2x) + .5) + 63.5

// NOTE tip: when using chain modulation, often the best results come from alternating inversion among the lfos

// TODO need to handle lfo init from launchkey / xtouch

@OnSysex
  ReceiveSysex data
  // TEST
  Log data[0], { }, data[1], { }, data[2], { }, data[3]
  // END TEST

  // set target knob for lfo
  if data[1] = 13

    // NOTE could add multiple sources of modulation for lfos in the future if desired
    // NOTE chain modulating data will not be sent for lfo 1 - (see '# ensure attempting to chain modulate from lfo 1 exits gracefully')
    lfoTargetKnob[data[2]] = data[3] + 1 // need to add one since knob turn input is +1 from knob push input

    // TEST
    // ensure target knob set correctly for lfo
    Log {Knob }, lfoTargetKnob[data[2]]
    Log {lfo }, data[2]
    // END TEST

  // set lfo to sync with tempo / not
  elseif data[1] = 14

    lfoSync[data[2]] = data[3]

    // TEST
    // ensure sync set correctly for lfo
    Log {Sync }, lfoSync[data[2]]
    Log {lfo }, data[2]
    // END TEST

  // set lfo to bottom / middle
  elseif data[1] = 15

    lfoBase[data[2]] = data[3]

    // TEST
    // ensure base set correctly for lfo
    Log {Base }, lfoBase[data[2]]
    Log {lfo }, data[2]
    // END TEST

  // set lfo to invert output values
  elseif data[1] = 16

    lfoInvert[data[2]] = data[3]

    // TEST
    // ensure invert set correctly for lfo
    Log {Invert }, lfoInvert[data[2]]
    Log {lfo }, data[2]
    // END TEST

  // turn off or on lfo
  elseif data[1] = 17

    lfoOnOff[data[2]] = data[3]

    // uncomment to restart on turning lfo on
    //if data[3] = 1
    //  ResetLfo data[2]
    //endif

    // TEST
    // ensure on/off set correctly for lfo
    Log {OnOff }, lfoOnOff[data[2]]
    Log {lfo }, data[2]
    // END TEST

  // mute all lfos
  elseif data[1] = 18

    lfoMuteAll = data[2]

    // TEST
    // ensure muteAll set correctly
    Log {lfoMuteAll }, lfoMuteAll
    // END TEST

  // setting lfo type
  elseif data[1] = 19

    if data[3] = 0
      setLFOType data[2], {Sine}
    elseif data[3] = 1
      setLFOType data[2], {Cosine}
    elseif data[3] = 2
      setLFOType data[2], {Square}
    elseif data[3] = 3
      setLFOType data[2], {Triangle}
    elseif data[3] = 4
      setLFOType data[2], {RampUp}
    elseif data[3] = 5
      setLFOType data[2], {RampDown}
    elseif data[3] = 6
      setLFOType data[2], {SH}
    endif

    // TEST
    // ensure type set correctly for lfo
    Log {Type }, data[3]
    Log {lfo }, data[2]
    // END TEST

  // restarting lfo
  elseif data[1] = 20

    ResetLfo data[2]

    // TEST
    // ensure lfo correctly restarts
    Log {Restart }, data[2]
    // END TEST

  // restarting all lfos
  elseif data[1] = 21

    for lfo = 0 to 3
      ResetLfo lfo
    endfor

    // TEST
    // ensure all lfos correctly restart
    Log {RestartAll }
    // END TEST

  // update lfo rate
  elseif data[1] = 22

    if lfoSync[lfo] = 1 and HostRunning = 1
      // +/- 16th notes = 9 total options
      for x = 0 to 8
        if data[3] >= syncVal[x] and data[3] < syncVal[x + 1]
          // hz for sync = hosttempo / 60 (times multiples of 2)
          lfoRate[data[2]] = (HostTempo / 60) * (Pow 2, -4 + x)
          SetupLFO data[2], 0, 127, no, lfoRate[data[2]]
        endif
      endfor
    else
      lfoRate[data[2]] = data[3] / 31.75
      SetupLFO data[2], 0, 127, no, lfoRate[data[2]]
    endif

    // TEST
    // ensure rate set correctly for lfo
    // ensure rate set correctly for lfo with sync on
    Log {Rate }, lfoRate[data[2]]
    Log {lfo }, data[2]
    // END TEST

  // update lfo depth
  elseif data[1] = 23

    lfoDepth[data[2]] = data[3] / 127

    // TEST
    // ensure depth set correctly for lfo
    Log {Depth }, lfoDepth[data[2]]
    Log {lfo }, data[2]
    // END TEST

  endif
@End

@Onload
  //SetMetroPPQN 20
  SetTimerInterval 25 // set for 120bpm ((60000 / bpm) / 20)
  StartTimer
  // init variables
  lfoTargetKnob = [0, 0, 0, 0]
  lfoSync = [0, 0, 0, 0]
  lfoBase = [0, 0, 0, 0]
  lfoInvert = [0, 0, 0, 0]
  lfoOnOff = [0, 0, 0, 0]
  lfoMuteAll = 0
  lfoRate = [0, 0, 0, 0]
  lfoDepth = [0, 0, 0, 0]
  lfoVal = [0, 0, 0, 0]
  syncVal = [0, 14, 28, 42, 56, 70, 84, 98, 112, 128]
  SetupLFO 0, 0, 0, no, 0
  SetupLFO 1, 0, 0, no, 0
  SetupLFO 2, 0, 0, no, 0
  SetupLFO 3, 0, 0, no, 0
  // TEST
  // ensure load is correct
  Log {Load}
  logLFOs = 0
  // END TEST
@End

@OnHostStart
  SetTimerInterval ((60000 / HostTempo) / 20)
  Log {Host On: }, HostTempo
@End

@OnTimer
  if HostRunning = 1
    SetTimerInterval ((60000 / HostTempo) / 20) // would it hurt to make this constant?
  endif
  //SetMetroPPQN if necessary
  if lfoMuteAll = 0
    for lfo = 3 to 0
      if lfoOnOff[lfo] = 1

        // TEST
        if logLFOs = 1
          Log {---OnTimer for loop iteration Start---}
          Log {lfoNum }, lfo
          Log {lfoVal BeforeGet }, lfoVal[lfo]
        endif
        // END TEST

        lfoVal[lfo] = GetLFOValue lfo

        // TEST
        if logLFOs = 1
          Log {lfoVal AfterGet }, lfoVal[lfo]
        endif
        // END TEST

        // handle chain modulating both rate (3) and depth (4)
        if lfoTargetKnob[lfo + 1] = 4 and lfoOnOff[lfo + 1] = 1
          SetupLFO lfo, 0, 127, lfoSync[lfo], lfoVal[lfo + 1] / 31.75 // NOTE there may be a way to do this transition more smoothly
        elseif lfoTargetKnob[lfo + 1] = 5 and lfoOnOff[lfo + 1] = 1
          // NOTE for both of these, there is a conversion of the values to a sin wave that goes from -1 to 1
          // see equation at top
          if lfoBase[lfo] = 0
            // lfoVal[lfo] = 31.75 * (1 + ((lfoVal[lfo] / 63.5) - 1)) * (1 + ((lfoVal[lfo + 1] / 63.5) - 1))
            lfoVal[lfo] = 31.75 * (lfoVal[lfo] / 63.5) * (lfoVal[lfo + 1] / 63.5)
          else
            // lfoVal[lfo] = 31.75 * ((lfoVal[lfo] / 63.5) - 1) * (1 + ((lfoVal[lfo + 1] / 63.5) - 1)) + 63.5
            lfoVal[lfo] = 31.75 * ((lfoVal[lfo] / 63.5) - 1) * (lfoVal[lfo + 1] / 63.5) + 63.5
          endif
        endif

        // TEST
        // ensure value takes depth into consideration
        if logLFOs = 1
          Log {BeforeDepth }, lfoVal[lfo]
        endif
        // END TEST

        lfoVal[lfo] = lfoVal[lfo] * lfoDepth[lfo]

        // TEST
        if logLFOs = 1
          Log {AfterDepth }, lfoVal[lfo]
        endif
        // END TEST

        if lfoInvert[lfo]

          // TEST
          // ensure value inverts
          if logLFOs = 1
            Log {BeforeInvert }, lfoVal[lfo]
          endif
          // END TEST

          lfoVal[lfo] = lfoVal[lfo] * -1 + 127

          // TEST
          if logLFOs = 1
            Log {AfterInvert }, lfoVal[lfo]
          endif
          // END TEST

        endif

        if lfoTargetKnob[lfo] <> 4 and lfoTargetKnob[lfo] <> 5
          SendMIDICC 10, lfoTargetKnob[lfo], lfoVal[lfo]
        endif

        // TEST
        SetXYValues 64, lfoVal[0]
        if logLFOs = 1
          Log {---OnTimer for loop iteration End---}
        endif
        // END TEST
      endif
    endfor
  endif
@End

// TEST
@OnPadDown
  if logLFOs = 1
    logLFOs = 0
  else
    logLFOs = 1
  endif
@End
//END TEST
