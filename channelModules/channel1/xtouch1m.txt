// xtouch mini

@OnLoad

  // timer interval is .05 second

  SetTimerInterval 50

  // minimal layout

  ShowLayout 4

  // constant
  // 1, 2, 3, 4, 6, 9, 18, 24, 36, 54, 72, 114, 150
  tempoMode0Vals = [0x48, 0x36, 0x24, 0x18, 0x12, 0x09, 0x06, 0x04, 0x03, 0x02, 0x01]
  tempoMode1Vals = [0x24, 0x12, 0x09, 0x06, 0x04, 0x03]
  tempoMode2Vals = [0x96, 0x48, 0x24, 0x12, 0x06, 0x03]
  tempoMode3Vals = [0x72, 0x36, 0x18, 0x09, 0x04, 0x02]

  gateFactorArr = [1, 2, 5, 16, 32, 64]

  // channel specific constant

  channel = 0
  channelCC = channel + 176 

  drumButtons = [0, 1, 2, 3, 8, 9, 10, 11]

  drumParam1 = [14, 17, 20, 23, 26, 29, 46, 117]
  drumParam2 = [15, 18, 21, 24, 27, 30, 47, 118]
  drumParam3 = [16, 19, 22, 25, 28, 31, 48, 119]

  // assign local

  Call @InitVariables

@End

@InitVariables

  tempoMode = 0

  gateMode = 0

  setLfo = 0

  lfoType = [0, 0, 0, 0]
  lfoNum = 0

  gateFactor = 1
  programChange = 0

  knobPush = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  knobTurn = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  groupKnobPush = 0

  FillArray sendKnobTemp, -1, 16
  FillArray sendPushReset, -1, 16

  // assign channel specific variables

  // NOTE pushReset array is used for lighting storage for push control - these are init values
  // channel specific
  pushReset = [0x0E, 0x00, 0x64, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]

  // 0x40 and drumParams are channel specific
  // lfoRate and lfoDepth are not used (in addition to drumParams)
  // could be changed easily in the future if desired - might be cleaner, more scaleable - but have no usage for them at this point
  knobCurrentVal = [0x24, 0x00, 0x64, 0xFFFF, 0xFFFF, 0x40, 0x00, 0x00, 0xFFFF, 0xFFFF, 0xFFFF, 0x00, 0x00, 0x00, 0x00, 0x00]

  // first set of 0xFFFF are not sent, second set are drumParams (init drumParamCurrent at 0), third set are unspecified
  // technically most of these are constants, but putting this here due to drumParams
  knobSendVals = [0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0A, 0x34, 0x33, 0x0E, 0x0F, 0x10, 0x67, 0x31, 0x32, 0xFFFF, 0xFFFF]

  pitchQuantize = 0
  waveguideToggle = 0
  previousDrumVal = 0
  previousTrackingMode = 5
  drumParamCurrent = 0

  drumParam1CurrentVal = [0, 0, 0, 0, 0, 0, 0, 0]
  drumParam2CurrentVal = [0, 0, 0, 0, 0, 0, 0, 0]
  drumParam3CurrentVal = [0, 0, 0, 0, 0, 0, 0, 0]

@End

// timerVal is 1-4 (inclusive) - init:
// change program to b, init b, change program to a, init a
// timerVal is 5-8 (inclusive) - channelChange:
// change program to b, clear and add new channel for b, change program to a, clear and add new channel for a
// timerVal is 9-12 (inclusive) - setLfo off, if knob is 'B' mode:
// change program to a, turn buttonFlash off, change program to a, init lighting
// timerVal is 13-16 (inclusive) - groupKnobPush off:
// change program to b, set knob values, change program to a, init lighting
// NOTE could technically remove the need for a filter if we timed ResetCurrentModeLighting with its own conditional
@OnTimer
  if timerVal = 1 or timerVal = 5 or timerVal = 13 or timerVal = 11 // 1-4 for init
    // reset lights for mode 'B'
    SendMIDIOut 0xC0, 0x01
    timerVal = timerVal + 1

  elseif timerVal = 2
    // loop until this is done for all sixteen buttons
    resetKnobs = 1
    knobLightingCCOffset = 11
    Call @ResetCurrentModeLighting

    // send init drum lighting
    sendData = [0x0F, 0xEE, 0x90, 0x00, 0x01]
    SendSysex sendData, 5

    // send init trackingMode lighting
    sendData = [0x0F, 0xEE, 0x90, 0x05, 0x01]
    SendSysex sendData, 5

    timerVal = timerVal + 1

  elseif timerVal = 3 or timerVal = 7 or timerVal = 15 or timerVal = 9
    // change program back to 'A'
    SendMIDIOut 0xC0, 0x00

    timerVal = timerVal + 1

  elseif timerVal = 4
    // loop until this is done for all sixteen buttons
    resetKnobs = 1
    knobLightingCCOffset = 1
    Call @ResetCurrentModeLighting

    // (re)set sysex variables
    // NOTE could move this also into the init load for completeness (or remove local from init load?)

    arpPhraseToggle = 0
    arpPhraseOnOffToggle = 0
    tempoPulse = 0x24
    arpValueMode = 0
    setPhrase = 0
    latch = 0
    padMode = 0
    lfoNumMod = 0
    trackingMode = 0 // channel specific
    lfoTypeMod = 0
    lfoRate = [0, 0, 0, 0]
    lfoDepth = [0, 0, 0, 0]
    lfoOnOffToggle = [0, 0, 0, 0]
    lfoSync = [0, 0, 0, 0]
    lfoBase = [0, 0, 0, 0]
    lfoInvert = [0, 0, 0, 0]
    lfoKnob = [0x26, 0x26, 0x26, 0x26] // NOTE set not to modulate anything initially
    lfoMuteAll = 0

    // reset necessary local variables

    Call @InitVariables

    // send init tempo lighting
    sendData = [0x0F, 0xEE, 0xBA, 0x01, 26]
    SendSysex sendData, 5
    // send init velocity lighting
    sendData = [0x0F, 0xEE, 0xBA, 0x03, 100]
    SendSysex sendData, 5

    // channel specific

    // NOTE could likely just use a for loop with knobCurrent
    // send init pan lighting
    sendData = [0x0F, 0xEE, 0xBA, 0x06, 0x40]
    SendSysex sendData, 5

    // end channel specific

    StopTimer
    ResetTimer
    timerVal = 0

  elseif timerVal = 6 // 5 handled above (channel change)
    // need to reset lights from other channel
    // loop until this is done for all sixteen buttons
    resetKnobs = 0
    knobLightingCCOffset = 0 // not used here
    Call @ResetCurrentModeLighting

    // channel specific

    // send trackingMode lighting
    sendData = [0x0F, 0xEE, 0x90, previousTrackingMode, 0x01]
    SendSysex sendData, 5

    // send drum lighting
    sendData = [0x0F, 0xEE, 0x90, drumButtons[previousDrumVal], 0x01]
    SendSysex sendData, 5

    sendData = [0x0F, 0xEE, 0xBA, drumParam1[drumParamCurrent], drumParam1CurrentVal[drumParamCurrent]]
    SendSysex sendData, 5
    sendData = [0x0F, 0xEE, 0xBA, drumParam2[drumParamCurrent], drumParam2CurrentVal[drumParamCurrent]]
    SendSysex sendData, 5
    sendData = [0x0F, 0xEE, 0xBA, drumParam3[drumParamCurrent], drumParam3CurrentVal[drumParamCurrent]]
    SendSysex sendData, 5

    // end channel specific

    // send rest of 'B' mode knob data
    for i = 11 to 15
      knobTemp = i + 3
      sendData = [0x0F, 0xEE, 0xBA, knobTemp, knobCurrentVal[i]]
      SendSysex sendData, 5
    endfor

    timerVal = timerVal + 1

  elseif timerval = 8 // 7 handled above as well
    // need to reset lights from other channel
    // loop until this is done for all sixteen buttons
    resetKnobs = 1
    knobLightingCCOffset = 1
    Call @ResetCurrentModeLighting

    // NOTE could send the variables themselves rather than using conditionals in most instances
    // could even save these variables as an array and iterate through
    if arpPhraseToggle = 1
      sendData = [0x0F, 0xEE, 0x90, 0x01, 0x01]
      SendSysex sendData, 5
      if setPhrase = 1
        sendData = [0x0F, 0xEE, 0x90, 0x00, 0x01]
        SendSysex sendData, 5
      endif
    endif
    if arpPhraseOnOffToggle = 1
      sendData = [0x0F, 0xEE, 0x90, 0x09, 0x01]
      SendSysex sendData, 5
    endif
    if latch = 1
      sendData = [0x0F, 0xEE, 0x90, 0x02, 0x01]
      SendSysex sendData, 5
    endif
    // NOTE because setLfo is a temporary and restrictive state, it should reset on channel switching
    if setLfo = 1
      setLfo = 0
    endif
    // NOTE knobPush in general is complicated - pushing knobs while switching channel will almost certainly break something (esp with setLfo on), since knobPush will not be reset on switch. Should resolve itself on the next knobPush for that number and channel, but might be confusing to see
    // because switching channel is designed to use two hands, hoping this won't come up
    // would be fairly simple to resolve, just possibly a little convoluted (see conditionals when groupPushKnob is turned off; these would likely just be copied and pasted here)
    if groupKnobPush = 1
      sendData = [0x0F, 0xEE, 0x90, 0x0A, 0x01]
      SendSysex sendData, 5
    endif
    if padMode = 1
      sendData = [0x0F, 0xEE, 0x90, 0x03, 0x01]
      SendSysex sendData, 5
    endif

    // NOTE other lfo specific button lighting sent later, with flashing knob lighting
    // NOTE can't be done via pushReset array due to groupKnobPush being possibly on
    // send tempo, gate, velocity, 6, 7, 8 lighting
    for i = 0 to 5
      if i > 2
        i = i + 2
      endif
      j = i + 1
      sendData = [0x0F, 0xEE, 0xBA, j, knobCurrentVal[i]]
      SendSysex sendData, 5
    endfor

    // send lfoRate
    sendData = [0x0F, 0xEE, 0xBA, 0x04, lfoRate[lfoNumMod]]
    SendSysex sendData, 5
    // send lfoDepth
    sendData = [0x0F, 0xEE, 0xBA, 0x05, lfoDepth[lfoNumMod]]
    SendSysex sendData, 5

    if lfoMuteAll = 1
      sendData = [0x0F, 0xEE, 0x90, 0x0C, 0x01]
      SendSysex sendData, 5
    else
      for i = 0 to 3
        if lfoOnOffToggle[i] = 1
          if (lfoKnob[i] < 8 and lfoKnob[i] <> 3 and lfoKnob[i] <> 4) or ((lfoKnob[i] = 3 or lfoKnob[i] = 4) and lfoNumMod = i - 1)
            knobTemp = lfoKnob[i] + 9
            sendData = [0x0F, 0xEE, 0xB0, lfoTemp, 0x1C]
            SendSysex sendData, 5
          endif
        endif
      endfor
    endif

    if lfoOnOffToggle[lfoNumMod] = 1
      sendData = [0x0F, 0xEE, 0x90, 0x04, 0x01]
      SendSysex sendData, 5
    endif
    if lfoSync[lfoNumMod] = 1
      sendData = [0x0F, 0xEE, 0x90, 0x06, 0x01]
      SendSysex sendData, 5
    endif
    if lfoBase[lfoNumMod] = 1
      sendData = [0x0F, 0xEE, 0x90, 0x0E, 0x01]
      SendSysex sendData, 5
    endif
    if lfoInvert[lfoNumMod] = 1
      sendData = [0x0F, 0xEE, 0x90, 0x07, 0x01]
      SendSysex sendData, 5
    endif

    StopTimer
    ResetTimer
    timerVal = 0

  elseif timerVal = 10 // 9 and 11 handled above (setLfo reset)
    sendData = [0x0F, 0xEE, 0x90, 0x0B, 0x00]
    SendSysex sendData, 5

    timerVal = timerVal + 1

  elseif timerVal = 14 // 13 handled above (set reset)
    // send groupKnobPush to 'B' mode
    for l = 8 to 15
      if sendKnobTemp[l] <> -1 and sendPushReset[l] <> -1
        sendData = [0x0F, 0xEE, 0xBA, sendKnobTemp[l], sendPushReset[l]]
        SendSysex sendData, 5
      endif
    endfor

    timerVal = timerVal + 1

  elseif timerVal = 12

    // resend lighting for mode 'B'
    Call @ResetModeBTempLighting

    StopTimer
    ResetTimer
    timerVal = 0

  elseif timerVal = 16
    // send groupKnobPush to 'A' mode
    for l = 1 to 7
      if sendKnobTemp[l] <> -1 and sendPushReset[l] <> -1
        sendData = [0x0F, 0xEE, 0xBA, sendKnobTemp[l], sendPushReset[l]]
        SendSysex sendData, 5
      endif
    endfor

    Call @ResetModeATempLighting

    StopTimer
    ResetTimer
    timerVal = 0

  endif

@End

// sysex reception

@OnSysex

  ReceiveSysex sysexData

  if sysexData[0] < 0xFC
    Exit

  // clock message triggered by host clock starting
  elseif sysexData[0] = 0x7D and sysexData[1] = 0x01
    Exit

  elseif sysexData[1] = 0x07
    setPhrase = sysexData[2]
    // Turn off setPhrase light when sysex received
    if setPhrase = 0
      sendData = [0x0F, 0xEE, 0x90, 0x00, 0x00]
      SendSysex sendData, 5
    endif
    Exit

  // Turn off lights when init sysex received
  elseif sysexData[1] = 0x1B

    // reset lfo
    sendData = [0x01, 0x1D, 0x00]
    SendSysex sendData, 3

    timerVal = 1
    StartTimer // see @OnTimer for more details here
    // necessary because sysex typically sends about .005 faster than program change regardless of the order in the code

    Exit

  // Send lights when channel change sysex received
  elseif sysexData[1] = 0x1E

    timerVal = 5
    StartTimer // see @OnTimer for more details here
    // necessary because sysex typically sends about .005 faster than program change regardless of the order in the code

  endif

@End

// end sysex reception

@ResetCurrentModeLighting
  for i = 0 to 15
    knobTemp = i + knobLightingCCOffset
    // these should only go up to eight
    if resetKnobs = 1 and i < 8
      // reset lighting on knobs
      sendData = [0x0F, 0xEE, 0xBA, knobTemp, 0x00]
      SendSysex sendData, 5
      if knobLightingCCOffset = 1
        // set lighting to 'pan'
        sendData = [0x0F, 0xEE, 0xB0, knobTemp, 0x02]
        SendSysex sendData, 5
      endif
    endif
    // reset button lighting
    sendData = [0x0F, 0xEE, 0x90, i, 0x00]
    SendSysex sendData, 5
  endfor
@End

// this handles all CC and note MIDI, since notes are converted to CC to enable recording in modstep
@OnMIDICC

  if MIDIChannel <> channel
    Exit

  elseif MIDIByte2 = 0x7C // converted from note on

    Call @HandleNoteOn

  elseif MIDIByte2 = 0x7D // converted from note off

    Call @HandleNoteOff

  else

    MIDIByte2Temp = MIDIByte2
    MIDIByte3Temp = MIDIByte3
    Call @HandleKnobTurn

  endif

@End

// if it is a button push
@HandleNoteOn

  MIDINoteVal = MIDIByte3 - 19 // adjust from offset

  Call @HandlePushControl

  // if it is a button 1 push
  if MIDINoteVal = 0x08 and MIDIByte2 = 0x7C
    // if arp then increase variable
    if arpPhraseToggle = 0
      // set value mode to variable modulo 12
      arpValueMode = (arpValueMode + 1) % 12
      sendData = [0xC1, 0x06, arpValueMode]
      SendSysex sendData, 3
    // if phrase then toggle setPhrase
    else
      if setPhrase = 0
        setPhrase = 1
        sendData = [0x11, 0x07, setPhrase]
        SendSysex sendData, 3
      else
        setPhrase = 0
        sendData = [0x11, 0x07, setPhrase]
        SendSysex sendData, 3 
      endif
    endif
    Exit

  // if it is a button 9 push
  elseif MIDINoteVal = 0x10 and MIDIByte2 = 0x7C
    // if arp then decrease variable
    if arpPhraseToggle = 0
      // set value mode to variable modulo 12
      arpValueMode = ((arpValueMode - 1) % 12)
      // NOTE for some reason negative modulos are negative numbers in mozaic, so need to add 12 to offset this
      if arpValueMode < 0
        arpValueMode = arpValueMode + 12
      endif
      sendData = [0xC1, 0x06, arpValueMode]
      SendSysex sendData, 3
    // if phrase then add rest to phrase sequence
    else
      if setPhrase = 1
        sendData = [0x11, 0x1A, 0x2E]
        SendSysex sendData, 3
        // NOTE not currently planning on handling this, but there may is likely a race condition between rest and note that could cause issues
      endif
    endif
    Exit

  // if it is a button 2 push toggle arp / phrase
  elseif MIDINoteVal = 0x09 and MIDIByte2 = 0x7C
    if arpPhraseToggle = 0
      arpPhraseToggle = 1
      sendData = [0xC1, 0x01, arpPhraseToggle]
      SendSysex sendData, 3
    else
      arpPhraseToggle = 0
      sendData = [0xC1, 0x01, arpPhraseToggle]
      SendSysex sendData, 3
      if setPhrase = 1
        setPhrase = 0
        sendData = [0x11, 0x07, setPhrase]
        SendSysex sendData, 3
      endif
    endif
    Exit

  // if it is a button 10 push toggle button 2 selection on / off
  elseif MIDINoteVal = 0x11 and MIDIByte2 = 0x7C
    if arpPhraseOnOffToggle = 0
      arpPhraseOnOffToggle = 1
      sendData = [0xC1, 0x02, arpPhraseOnOffToggle]
      SendSysex sendData, 3
    else
      arpPhraseOnOffToggle = 0
      sendData = [0xC1, 0x02, arpPhraseOnOffToggle]
      SendSysex sendData, 3
    endif
    Exit

  // if it is a button 3 push toggle latch
  elseif MIDINoteVal = 0x0A and MIDIByte2 = 0x7C
    if latch = 0
      latch = 1
      sendData = [0x11, 0x0B, latch]
      SendSysex sendData, 3
    else
      latch = 0
      sendData = [0x11, 0x0B, latch]
      SendSysex sendData, 3
    endif
    Exit

  // if it is a button 11 push toggle groupKnobPush
  elseif MIDINoteVal = 0x12 and MIDIByte2 = 0x7C
    if groupKnobPush = 0
      groupKnobPush = 1
    else
      groupKnobPush = 0
    endif
    Exit

  // if it is a button 4 push toggle padMode
  elseif MIDINoteVal = 0x0B and MIDIByte2 = 0x7C
    // isBeats
    if padMode = 0
      padMode = 1
      sendData = [0x3F, 0x0C, padMode]
      SendSysex sendData, 3
    // isSample
    else
      padMode = 0
      sendData = [0x3F, 0x0C, padMode]
      SendSysex sendData, 3
    endif
    Exit

  // if it is a button 12 set lfo
  elseif MIDINoteVal = 0x13 and MIDIByte2 = 0x7C
    // knobPush prevents setLfo when on - this is in place to ensure knobPush and Turn can't set lfoKnob and not reset push control
    // see blocks for handling of setLfo on release below - no handling for push control
    for i = 0 to 15
      if knobPush[i] = 1
        Exit
      endif
    endfor
    if setLfo = 0
      setLfo = 1
    else
      setLfo = 0
    endif
    Exit

  // if it is a button 5 push toggle current lfo
  elseif MIDINoteVal = 0x0C and MIDIByte2 = 0x7C
    if lfoOnOffToggle[lfoNumMod] = 0
      lfoOnOffToggle[lfoNumMod] = 1
    else
      lfoOnOffToggle[lfoNumMod] = 0
    endif
    sendData = [0x01, 0x11, lfoNumMod, lfoOnOffToggle[lfoNumMod]]
    SendSysex sendData, 4
    Exit

  // if it is a button 13 push toggle mute of all lfos
  elseif MIDINoteVal = 0x14 and MIDIByte2 = 0x7C
    if lfoMuteAll = 0
      lfoMuteAll = 1
    else
      lfoMuteAll = 0
    endif
    sendData = [0x01, 0x12, lfoMuteAll]
    SendSysex sendData, 3
    Exit

  // if it is a button 6 push restart lfo
  elseif MIDINoteVal = 0x0D and MIDIByte2 = 0x7C
    sendData = [0x01, 0x14, lfoNumMod]
    SendSysex sendData, 3
    Exit

  // if it is a button 14 push restart all lfos
  elseif MIDINoteVal = 0x15 and MIDIByte2 = 0x7C
    sendData = [0x01, 0x15, 0x00]
    SendSysex sendData, 3
    Exit

  // if it is a button 7 push sync lfo to tempo
  elseif MIDINoteVal = 0x0E and MIDIByte2 = 0x7C
    if lfoSync[lfoNumMod] = 0
      lfoSync[lfoNumMod] = 1
    else
      lfoSync[lfoNumMod] = 0
    endif
    sendData = [0x01, 0x0E, lfoNumMod, lfoSync[lfoNumMod]]
    SendSysex sendData, 4
    Exit

  // if it is a button 15 push toggle lfo base (1: middle or 0: bottom)
  elseif MIDINoteVal = 0x16 and MIDIByte2 = 0x7C
    if lfoBase[lfoNumMod] = 0
      lfoBase[lfoNumMod] = 1
    else
      lfoBase[lfoNumMod] = 0
    endif
    sendData = [0x01, 0x0F, lfoNumMod, lfoBase[lfoNumMod]]
    SendSysex sendData, 4
    Exit

  // if it is a button 8 push toggle lfo inversion
  elseif MIDINoteVal = 0x0F and MIDIByte2 = 0x7C
    if lfoInvert[lfoNumMod] = 0
      lfoInvert[lfoNumMod] = 1
    else
      lfoInvert[lfoNumMod] = 0
    endif
    sendData = [0x01, 0x10, lfoNumMod, lfoInvert[lfoNumMod]]
    SendSysex sendData, 4
    Exit

  // if it is a button 16 send 'pan' lighting (reset after mode change)
  elseif MIDINoteVal = 0x17 and MIDIByte2 = 0x7C
    Call @ResetModeATempLighting
    Exit

  // if it is a button 32 reset lfo modulation lighting
  elseif MIDINoteVal = 0x2F and MIDIByte2 = 0x7C
    Call @ResetModeBTempLighting
    Exit

  // channel specific

  // tracking off
  elseif MIDINoteVal = 0x25 and MIDIByte2 = 0x7C
    trackingMode = 0
    if previousTrackingMode <> 5
      sendData = [0x0F, 0xEE, 0x90, previousTrackingMode, 0x00]
      SendSysex sendData, 5
    endif
    sendData = [0x11, 0x1F, trackingMode]
    SendSysex sendData, 3
    Exit

  // tracking mode double
  elseif MIDINoteVal = 0x24 and MIDIByte2 = 0x7C
    trackingMode = 2
    if previousTrackingMode <> 4
      sendData = [0x0F, 0xEE, 0x90, previousTrackingMode, 0x00]
      SendSysex sendData, 5
    endif
    sendData = [0x11, 0x1F, trackingMode]
    SendSysex sendData, 3
    Exit

  // tracking mode single
  elseif MIDINoteVal = 0x2C and MIDIByte2 = 0x7C
    trackingMode = 1
    if previousTrackingMode <> 0x0C
      sendData = [0x0F, 0xEE, 0x90, previousTrackingMode, 0x00]
      SendSysex sendData, 5
    endif
    sendData = [0x11, 0x1F, trackingMode]
    SendSysex sendData, 3
    Exit

  // if knob is pressed and a drumParam is changed, the value in the L array will not match up correctly - exit before
  elseif groupKnobPush = 1 or knobPush[8] = 1 or knobPush[9] = 1 or knobPush[10] = 1
    Exit

  elseif MIDINoteVal >= 32 and MIDINoteVal <= 35 and MIDIByte2 = 0x7C
    drumParamCurrent = MIDINoteVal - 32
    Call @HandleDrumParamChange
    Exit

  elseif MIDINoteVal >= 40 and MIDINoteVal <= 43 and MIDIByte2 = 0x7C
    drumParamCurrent = MIDINoteVal - 36
    Call @HandleDrumParamChange
    Exit
  endif

  // end channel specific

@End

@HandlePushControl
  // don't assign if setting lfo - this prevents push control issues when setting lfo
  if setLfo = 1
    Exit
  endif

  if MIDINoteVal <= 7
    MIDINoteOffset = MIDINoteVal
  elseif MIDINoteVal >= 24 and MIDINoteVal <= 31
    MIDINoteOffset = MIDINoteVal - 16
  else
    Exit
  endif

  // chain modulating lfos should not be impacted by the conditionals below, since push control should work with them when they are being modulated
  // the reason push control caused issues for the other knobs was because the lfo information was getting sent directly back here for processing and turning on knobTurn inadvertently - with these two the processing all occurs in the lfo file

  // if there is an lfo currently modulating that is on
  if lfoMuteAll = 0 and MIDINoteVal <> 3 and MIDINoteVal <> 4
    for i = 0 to 3
      if lfoKnob[i] = MIDINoteVal and lfoOnOffToggle[i] = 1
        Exit
      endif
    endfor
  endif

  knobPush[MIDINoteOffset] = 1

@End

@HandleDrumParamChange
  if drumParamCurrent <> drumButtons[previousDrumVal]
    sendData = [0x0F, 0xEE, 0x90, drumButtons[previousDrumVal], 0x00]
    SendSysex sendData, 5
  endif
  sendData = [0x0F, 0xEE, 0xBA, 0x0B, drumParam1CurrentVal[drumParamCurrent]]
  SendSysex sendData, 5
  pushReset[8] = drumParam1CurrentVal[drumParamCurrent]
  sendData = [0x0F, 0xEE, 0xBA, 0x0C, drumParam2CurrentVal[drumParamCurrent]]
  SendSysex sendData, 5
  pushReset[9] = drumParam2CurrentVal[drumParamCurrent]
  sendData = [0x0F, 0xEE, 0xBA, 0x0D, drumParam3CurrentVal[drumParamCurrent]]
  SendSysex sendData, 5
  pushReset[10] = drumParam3CurrentVal[drumParamCurrent]
@End

@ResetModeATempLighting
  // loop until this is done for all eight knobs
  for i = 1 to 8
    // set lighting to 'pan'
    sendData = [0x0F, 0xEE, 0xB0, i, 0x02]
    SendSysex sendData, 5
  endfor

  if lfoMuteAll = 0 
    for i = 0 to 3
      if lfoOnOffToggle[i] = 1 and lfoKnob[i] < 8
        if ((lfoKnob[i] = 3 or lfoKnob[i] = 4) and i - 1 = lfoNumMod) or (lfoKnob[i] <> 3 and lfoKnob[i] <> 4)
          lfoTemp = lfoKnob[i] + 9
        endif
        sendData = [0x0F, 0xEE, 0xB0, lfoTemp, 0x1C]
        SendSysex sendData, 5
      endif
    endfor
  endif
@End

@ResetModeBTempLighting
  if lfoMuteAll = 0 
    for i = 0 to 3
      if lfoOnOffToggle[i] = 1 and lfoKnob[i] >= 24 and lfoKnob[i] <= 31
        lfoTemp = lfoKnob[i] - 15
        sendData = [0x0F, 0xEE, 0xB0, lfoTemp, 0x1C]
        SendSysex sendData, 5
      endif
    endfor
  endif
@End

// if it is a button note-off (important for lighting)
@HandleNoteOff

  MIDINoteVal = MIDIByte3 - 19 // adjust from offset

  // if it's a knobPush (and / or knobTurn) and we're trying to set lfo we need to ignore other associated functionality
  if setLfo = 1 and (MIDINoteVal < 8 or (MIDINoteVal > 23 and MIDINoteVal < 32))
    // chained modulation will automatically default to lfo modulating lfo immediately below it
    // need to prevent chained modulation from looping infinitely, so lfo 1 (0) will not be able to modulate another lfo
    // NOTE could attempt to make the chain more flexible (i.e. 0, 3, 2, 1; 1, 0, 3, 2) but don't feel that's necessary at this point
    if lfoNumMod = 0 and (MIDINoteVal = 03 or MIDINoteVal = 04)
      Exit
    endif

    // lfo knobs (3 and 4) can modulate each other, but others can't
    if MIDINoteVal <> 3 and MIDINoteVal <> 4
      for i = 0 to 3
        if lfoKnob[i] = MIDINoteVal
          Exit
        endfor
      endfor
    endif

    // check if values are in same mode - should not send if knobs are not in the same mode ('A' or 'B')
    if lfoKnob[lfoNumMod] < 8 and MIDINoteVal < 8
      sameMode = 1
      knobLightingCCOffset = 1
    elseif lfoKnob[lfoNumMod] > 23 and MIDINoteVal > 23
      sameMode = 1
      knobLightingCCOffset = -15
    else
      sameMode = 0
    endif

    // send pushReset value to old knob
    if lfoMuteAll = 0 and lfoOnOffToggle[lfoNumMod] = 1 and lfoKnob[lfoNumMod] <> 3 and lfoKnob[lfoNumMod] <> 4 and sameMode = 1
      knobTemp = lfoKnob[lfoNumMod] + knobLightingCCOffset
      sendData = [0x0F, 0xEE, 0xBA, knobTemp, pushReset[lfoNumMod]]
      SendSysex sendData, 5
    endif

    // NOTE at what point should the offset be added - because offset is inconsistent, might not be worth too much thought
    lfoKnob[lfoNumMod] = MIDINoteVal
    sendData = [0x01, 0x0D, lfoNumMod, lfoKnob[lfoNumMod]]
    SendSysex sendData, 4

    setLfo = 0

    // send flash to new knob
    if lfoMuteAll = 0 and lfoOnOffToggle[lfoNumMod] = 1

      if lfoKnob[lfoNumMod] < 8 and lfoKnob[lfoNumMod] <> 3 and lfoKnob[lfoNumMod] <> 4
        lfoTemp = lfoKnob[lfoNumMod] + 9
        sendData = [0x0F, 0xEE, 0xB0, lfoTemp, 0x1C]
        SendSysex sendData, 5
      endif

    endif

    // reset flashing setLfo button
    if lfoKnob[lfoNumMod] < 8
      sendData = [0x0F, 0xEE, 0x90, 0x0B, 0x00]
      SendSysex sendData, 5
    elseif lfoKnob[lfoNumMod] > 23
      timerVal = 9
      StartTimer // see @OnTimer for more details here
      // necessary because sysex typically sends about .005 faster than program change regardless of the order in the code
    endif

    Exit
  endif

  // push control
  // NOTE these conditionals are separate from other knob push conditionals below - likely better to consolidate at some point
  // NOTE currently pushing a knob, then pressing groupKnobPush, then releasing the knob will not reset, which is expected at this point
  // NOTE if groupKnobPush is active, any knob push will result in the standard functionality, even if the knob is turned

  // ignore knobPush changes if groupKnobPush is on
  if groupKnobPush = 0

    knobPushResetConst = 1
    for i = 0 to 15
        if i > 7
          j = i + 16
          knobPushResetConst = -13
        else
          j = i
        endif
      if MIDINoteVal = j and MIDIByte2 = 0x7D
        if knobTurn[i] = 1
          knobTemp = MIDINoteVal + knobPushResetConst
          // HandleKnobTurn makes sure the parameters are changed correctly
          MIDIByte2Temp = knobTemp
          MIDIByte3Temp = pushReset[i]
          Call @HandleKnobTurn
          // tempo sends its own lighting, so this is not necessary
          if j <> 0
            sendData = [0x0F, 0xEE, 0xBA, knobTemp, pushReset[i]]
            SendSysex sendData, 5
          endif
          knobPush[i] = 0
          knobTurn[i] = 0

          // if using push control, releasing the knob button should not have any effect
          Exit
        else
          knobPush[i] = 0
        endif
      endif
    endfor

  endif

  // end push control

  // if it is a knob 1 button release, increase tempo mode
  if MIDINoteVal = 0x00 and MIDIByte2 = 0x7D
    // set tempo mode to variable modulo 4
    tempoMode = (tempoMode + 1) % 4
    sendData = [0x01, 0x18, tempoMode]
    SendSysex sendData, 3

    // set each tempoPulse to default value on switching
    // also send data to xtouch to reflect this
    if tempoMode = 0
      tempoPulse = 0x24
      pushReset[0] = 26
    elseif tempoMode = 1
      tempoPulse = 0x24
      pushReset[0] = 00
    elseif tempoMode = 2
      tempoPulse = 0x24
      pushReset[0] = 50
    elseif tempoMode = 3
      tempoPulse = 0x18
      pushReset[0] = 50
    endif
    sendData = [0xCC, 0x03, tempoPulse]
    SendSysex sendData, 3

    // don't send lighting / pushReset val if knob is actively being modulated
    // NOTE this isn't completely necessary but helps keep the lfo more closely synced as it moves
    for i = 0 to 3
      if lfoKnob[i] = 0 and lfoOnOffToggle[i] = 1 and lfoMuteAll = 0
        Exit
      endif
    endfor

    sendData = [0x0F, 0xEE, 0xBA, 0x01, pushReset[0]]
    SendSysex sendData, 5
    Exit

  // if it is a knob 2 button release, increase gate mode
  elseif MIDINoteVal = 0x01 and MIDIByte2 = 0x7D
    // set gate mode to variable modulo 6
    // NOTE preventing the light from sending will change the length more quickly, more easily
    // NOTE will be testing with live to see best setup here
    gateMode = (gateMode + 1) % 6

    gateFactor = gateFactorArr[gateMode]

    // don't send lighting / pushReset val if knob is actively being modulated
    // NOTE this isn't completely necessary but helps keep the lfo more closely synced as it moves
    for i = 0 to 3
      if lfoKnob[i] = 1 and lfoOnOffToggle[i] = 1 and lfoMuteAll = 0
        Exit
      endif
    endfor

    sendData = [0x0F, 0xEE, 0xBA, 0x02, 0x00]
    SendSysex sendData, 5
    pushReset[1] = 00 // NOTE with knob 1, this is only set prior to avoid adding the conditionals again after the lfoKnobs check
    Exit

  // if it is a knob 4 button release, change lfo type
  elseif MIDINoteVal = 0x03 and MIDIByte2 = 0x7D

    lfoType[lfoNumMod] = lfoType[lfoNumMod] + 1
    // set tempo mode to variable modulo 7
    lfoTypeMod = lfoType[lfoNumMod] % 7
    sendData = [0x01, 0x13, lfoNumMod, lfoTypeMod]
    SendSysex sendData, 4
    Exit

  // if it is a knob 5 button release, change lfo num (the lfo that's being edited)
  elseif MIDINoteVal = 0x04 and MIDIByte2 = 0x7D
    // this will cause issues if groupKnobPush or knob4Push is on due to the values in pushReset array
    if groupKnobPush = 1 or knobPush[3] = 1
      Exit
    endif
    lfoNum = lfoNum + 1
    // set tempo mode to variable modulo 4
    lfoNumMod = lfoNum % 4

    // send lighting for lfo1Rate and depth
    sendData = [0x0F, 0xEE, 0xBA, 0x04, lfoRate[lfoNumMod]]
    SendSysex sendData, 5
    sendData = [0x0F, 0xEE, 0xBA, 0x05, lfoDepth[lfoNumMod]]
    SendSysex sendData, 5
    pushReset[3] = lfoRate[lfoNumMod]
    pushReset[4] = lfoDepth[lfoNumMod]
    // send lighting for lfoOnOff, lfoSync, lfoBase, and lfoInvert
    if lfoOnOffToggle[lfoNumMod] = 1
      sendData = [0x0F, 0xEE, 0x90, 0x04, 0x01]
      SendSysex sendData, 5
    else
      sendData = [0x0F, 0xEE, 0x90, 0x04, 0x00]
      SendSysex sendData, 5
    endif
    if lfoSync[lfoNumMod] = 1
      sendData = [0x0F, 0xEE, 0x90, 0x06, 0x01]
      SendSysex sendData, 5
    else
      sendData = [0x0F, 0xEE, 0x90, 0x06, 0x00]
      SendSysex sendData, 5
    endif
    if lfoBase[lfoNumMod] = 1
      sendData = [0x0F, 0xEE, 0x90, 0x0E, 0x01]
      SendSysex sendData, 5
    else
      sendData = [0x0F, 0xEE, 0x90, 0x0E, 0x00]
      SendSysex sendData, 5
    endif
    if lfoInvert[lfoNumMod] = 1
      sendData = [0x0F, 0xEE, 0x90, 0x07, 0x01]
      SendSysex sendData, 5
    else
      sendData = [0x0F, 0xEE, 0x90, 0x07, 0x00]
      SendSysex sendData, 5
    endif
    // send flashing lights if chain modulating
    if lfoNumMod < 3 and lfoOnOffToggle[lfoNumMod + 1] = 1 and lfoMuteAll = 0
      if lfoKnob[lfoNumMod + 1] = 3
        sendData = [0x0F, 0xEE, 0xB0, 0x0C, 0x1C]
        SendSysex sendData, 5
      endif
      if lfoKnob[lfoNumMod + 1] = 4
        sendData = [0x0F, 0xEE, 0xB0, 0x0D, 0x1C]
        SendSysex sendData, 5
      endif
    endif
    Exit

  elseif MIDINoteVal = 0x08 and MIDIByte2 = 0x7D
    if arpPhraseToggle = 1
      if setPhrase = 1
        sendData = [0x0F, 0xEE, 0x90, 0x00, 0x01]
        SendSysex sendData, 5
      endif
    endif
    Exit

  elseif MIDINoteVal = 0x09 and MIDIByte2 = 0x7D
    if arpPhraseToggle = 1
      sendData = [0x0F, 0xEE, 0x90, 0x01, 0x01]
      SendSysex sendData, 5
    else
      // NOTE this sends even when light is off
      if setPhrase = 0
        sendData = [0x0F, 0xEE, 0x90, 0x00, 0x00]
        SendSysex sendData, 5
      endif
    endif
    Exit

  elseif MIDINoteVal = 0x0A and MIDIByte2 = 0x7D
    if latch = 1
      sendData = [0x0F, 0xEE, 0x90, 0x02, 0x01]
      SendSysex sendData, 5
    endif
    Exit

  elseif MIDINoteVal = 0x0B and MIDIByte2 = 0x7D
    if padMode = 1
      sendData = [0x0F, 0xEE, 0x90, 0x03, 0x01]
      SendSysex sendData, 5
    endif
    Exit

  elseif MIDINoteVal = 0x11 and MIDIByte2 = 0x7D
    if arpPhraseOnOffToggle = 1
      sendData = [0x0F, 0xEE, 0x90, 0x09, 0x01]
      SendSysex sendData, 5
    endif
    Exit

  elseif MIDINoteVal = 0x12 and MIDIByte2 = 0x7D
    if groupKnobPush = 1
      sendData = [0x0F, 0xEE, 0x90, 0x0A, 0x01]
      SendSysex sendData, 5

      // turn on knobPush for all knobs that aren't currently being modulated
      for i = 0 to 15
        if i > 7
          j = i + 16
        else
          j = i
        endif
        if lfoKnob[0] <> j or lfoKnob[1] <> j or lfoKnob[2] <> j or lfoKnob[3] <> j
          knobPush[i] = 1
        endif
      endfor

    // reset all knobs to pushReset values if turning off
    else

      knobPushResetConst = 1
      for i = 0 to 15
        if i > 7
          j = i + 16
          knobPushResetConst = -13
        else
          j = i
        endif
        if knobTurn[i] = 1

          // send program change to ensure lighting correctly sends - necessary for 'B' knobs
          if knobPushResetConst = -13 and programChange = 0
            programChange = 1

            timerVal = 13
            StartTimer // see @OnTimer for more details here
            // necessary because sysex typically sends about .005 faster than program change regardless of the order in the code

          endif
          knobTemp = j + knobPushResetConst
          // HandleKnobTurn makes sure the parameters are changed correctly
          MIDIByte2Temp = knobTemp
          MIDIByte3Temp = pushReset[i]
          Call @HandleKnobTurn
          // tempo sends its own lighting, so this is not necessary
          if j <> 0
            // need these to be arrays for timing - would send immediately but program change must occur first
            sendKnobTemp[i] = knobTemp
            sendPushReset[i]= pushReset[i]
          endif
          knobPush[i] = 0
          knobTurn[i] = 0
        else
          knobPush[i] = 0
          if j <> 0
            sendKnobTemp[i] = -1
            sendPushReset[i]= -1
          endif
        endif
      endfor

      // send program change to ensure lighting correctly appears after change - necessary for 'B' knobs
      if programChange = 1
        programChange = 0
      else
        timerVal = 16
        StartTimer
      endif

      Exit
    endif
    Exit

  elseif MIDINoteVal = 0x13 and MIDIByte2 = 0x7D
    if setLfo = 1
      sendData = [0x0F, 0xEE, 0x90, 0x0B, 0x02]
      SendSysex sendData, 5
    endif
    Exit

  elseif MIDINoteVal = 0x0C and MIDIByte2 = 0x7D
    if lfoOnOffToggle[lfoNumMod] = 1
      sendData = [0x0F, 0xEE, 0x90, 0x04, 0x01]
      SendSysex sendData, 5
      if lfoMuteAll = 0 and lfoKnob[lfoNumMod] < 8 and lfoKnob[lfoNumMod] <> 3 and lfoKnob[lfoNumMod] <> 4
        lfoTemp = lfoKnob[lfoNumMod] + 9
        sendData = [0x0F, 0xEE, 0xB0, lfoTemp, 0x1C]
        SendSysex sendData, 5
      endif
    else
      // don't want to send pushReset values twice if we don't have to
      if lfoMuteAll = 0 and lfoKnob[lfoNumMod] < 8 and lfoKnob[lfoNumMod] <> 3 and lfoKnob[lfoNumMod] <> 4
        knobTemp = lfoKnob[lfoNumMod] + 1
        sendData = [0x0F, 0xEE, 0xBA, knobTemp, pushReset[lfoKnob[lfoNumMod]]]
        SendSysex sendData, 5
      endif
    endif
    Exit

  elseif MIDINoteVal = 0x14 and MIDIByte2 = 0x7D
    if lfoMuteAll = 1
      sendData = [0x0F, 0xEE, 0x90, 0x0C, 0x01]
      SendSysex sendData, 5
      for i = 0 to 3
        if lfoOnOffToggle[i] = 1
          if (lfoKnob[i] < 8 and lfoKnob[i] <> 3 and lfoKnob[i] <> 4) or ((lfoKnob[i] = 3 or lfoKnob[i] = 4) and lfoNumMod = i - 1)
            knobTemp = lfoKnob[i] + 1
            sendData = [0x0F, 0xEE, 0xBA, knobTemp, pushReset[lfoKnob[i]]]
            SendSysex sendData, 5
          endif
        endif
      endfor
    else
      for i = 0 to 3
        if lfoOnOffToggle[i] = 1
          if (lfoKnob[i] < 8 and lfoKnob[i] <> 3 and lfoKnob[i] <> 4) or ((lfoKnob[i] = 3 or lfoKnob[i] = 4) and lfoNumMod = i - 1)
            lfoTemp = lfoKnob[i] + 9
            sendData = [0x0F, 0xEE, 0xB0, lfoTemp, 0x1C]
            SendSysex sendData, 5
          endif
        endif
      endfor
    endif
    Exit

  elseif MIDINoteVal = 0x0E and MIDIByte2 = 0x7D
    if lfoSync[lfoNumMod] = 1
      sendData = [0x0F, 0xEE, 0x90, 0x06, 0x01]
      SendSysex sendData, 5
    endif
    Exit

  elseif MIDINoteVal = 0x16 and MIDIByte2 = 0x7D
    if lfoBase[lfoNumMod] = 1
      sendData = [0x0F, 0xEE, 0x90, 0x0E, 0x01]
      SendSysex sendData, 5
    endif
    Exit

  // if it is a button 15 push toggle lfo inversion
  elseif MIDINoteVal = 0x0F and MIDIByte2 = 0x7D
    if lfoInvert[lfoNumMod] = 1
      sendData = [0x0F, 0xEE, 0x90, 0x07, 0x01]
      SendSysex sendData, 5
    endif
    Exit

  // channel specific

  // if it is a knob 9 button release, toggle waveguide
  elseif MIDINoteVal = 0x18 and MIDIByte2 = 0x7D
    if waveguideToggle = 0
      waveguideToggle = 1
      // NOTE this is a little janky - waveguide doesn't seem to reset visually and requires a press on the machine itself
      sendData = [0x11, 0xEE, channelCC, 116, 0x7F]
    else
      waveguideToggle = 0
      // NOTE this is a little janky - waveguide doesn't seem to reset visually and requires a press on the machine itself
      sendData = [0x11, 0xEE, channelCC, 116, 0x00]
    endif
    SendSysex sendData, 5
    Exit

  // if it is a knob 10 button release, toggle pitch quantize
  elseif MIDINoteVal = 0x19 and MIDIByte2 = 0x7D
    if pitchQuantize = 0
      pitchQuantize = 1
      sendData = [0x11, 0xEE, channelCC, 53, 0x7F]
    else
      pitchQuantize = 0
      sendData = [0x11, 0xEE, channelCC, 53, 0x00]
    endif
    SendSysex sendData, 5
    Exit

  elseif MIDINoteVal = 0x25 and MIDIByte2 = 0x7D
    sendData = [0x0F, 0xEE, 0x90, 0x05, 0x01]
    SendSysex sendData, 5
    previousTrackingMode = 0x05
    Exit
  elseif MIDINoteVal = 0x24 and MIDIByte2 = 0x7D
    sendData = [0x0F, 0xEE, 0x90, 0x04, 0x01]
    SendSysex sendData, 5
    previousTrackingMode = 0x04
    Exit
  elseif MIDINoteVal = 0x2C and MIDIByte2 = 0x7D
    sendData = [0x0F, 0xEE, 0x90, 0x0C, 0x01]
    SendSysex sendData, 5
    previousTrackingMode = 0x0C
    Exit

  // if knob is pressed and a drumParam is changed, the value in the pushReset array will not match up correctly
  // send lighting if drumParam is the same so that the light doesn't just turn off
  elseif (knobPush[8] = 1 or knobPush[9] = 1 or knobPush[10] = 1)
    if (MIDINoteVal >= 32 and MIDINoteVal <= 35) or (MIDINoteVal >= 40 and MIDINoteVal <= 43)
      knobTemp = MIDINoteVal - drumButtons[previousDrumVal]
      // send lighting to keep knob lit if same knob pressed
      if knobTemp = 32
        sendData = [0x0F, 0xEE, 0x90, drumButtons[previousDrumVal], 0x01]
        SendSysex sendData, 5
      endif
      Exit
    endif
  endif

  // drumParams
  for i = 0 to 7
    if MIDINoteVal - 32 = drumButtons[i] and MIDIByte2 = 0x7D
      sendData = [0x0F, 0xEE, 0x90, drumButtons[i], 0x01]
      SendSysex sendData, 5
      for j = 0 to 3
        if lfoKnob[j] >= 24 and lfoKnob[j] <= 26
          lfoTemp = lfoKnob[i] - 15
          sendData = [0x0F, 0xEE, 0xB0, lfoTemp, 0x1C]
          SendSysex sendData, 5
        endif
      endfor
      previousDrumVal = i
      Exit
    endif
  endfor

  // end channel specific

@End

@HandleKnobTurn

  // Need to handle as if being called both in knobTurn and on button release for knobPush
  if MIDIByte2Temp <> 0 and MIDIByte2Temp <= 8
    MIDIByte2Offset = MIDIByte2Temp - 1
  elseif MIDIByte2Temp >= 11 and MIDIByte2Temp <= 18
    MIDIByte2Offset = MIDIByte2Temp - 3
  endif

  // set knob turn to true if using push control
  // knob turn vals are + 1 from knob push vals
  if knobPush[MIDIByte2Offset] = 1
    knobTurn[MIDIByte2Offset] = 1
  endif

  // if knob is 1 (tempo)
  // knob is sensitive down to one notch
  if MIDIByte2Temp = 1
    Call @HandleTempo

  elseif MIDIByte2Temp > 1 and MIDIByte2Temp <= 18
    // needs to be sent out
    // assign for push control
    if knobPush[MIDIByte2Offset] = 0
      pushReset[MIDIByte2Offset] = MIDIByte3Temp
    endif

    // gate
    if MIDIByte2Temp = 2
      // starting points: max will be ~5 seconds (5000), min will be .1 seconds (100)
      // 2.5 seconds should be enough to handle 96 pulses at 120 bpm,  but slower bpm's can move up to 5 seconds
      // overall: 0-127 (*2) (*5) (*16) (*32) (*64)
      // NOTE none of the values here end up sending an F7, but if changed it's possible they could, which would cause issues
      knobCurrentVal[MIDIByte2Offset] = MIDIByte3Temp * gateFactor
      gateTemp = RoundDown (knobCurrentVal[MIDIByte2Offset] / 256)
      sendData = [0xCC, 0x04, gateTemp, knobCurrentVal[MIDIByte2Offset]] // NOTE final index value uses only last two digits
      SendSysex sendData, 4

    // velocity
    elseif MIDIByte2Temp = 3
      knobCurrentVal[MIDIByte2Offset] = MIDIByte3Temp
      sendData = [0xC1, 0x05, knobCurrentVal[MIDIByte2Offset]]
      SendSysex sendData, 3

    // lfo rate
    elseif MIDIByte2Temp = 4
      lfoRate[lfoNumMod] = MIDIByte3Temp
      sendData = [0x01, 0x16, lfoNumMod, lfoRate[lfoNumMod]]
      SendSysex sendData, 4

    // lfo depth
    elseif MIDIByte2Temp = 5
      lfoDepth[lfoNumMod] = MIDIByte3Temp
      sendData = [0x01, 0x17, lfoNumMod, lfoDepth[lfoNumMod]]
      SendSysex sendData, 4

    // channel specific
    elseif MIDIByte2Temp > 5

      // drumParams
      if MIDIByte2Temp = 11
        knobSendVals[MIDIByte2Offset] = drumParam1[drumParamCurrent]
        drumParam1CurrentVal[drumParamCurrent] = MIDIByte3Temp
      elseif MIDIByte2Temp = 12
        knobSendVals[MIDIByte2Offset] = drumParam2[drumParamCurrent]
        drumParam2CurrentVal[drumParamCurrent] = MIDIByte3Temp
      elseif MIDIByte2Temp = 13
        knobSendVals[MIDIByte2Offset] = drumParam3[drumParamCurrent]
        drumParam3CurrentVal[drumParamCurrent] = MIDIByte3Temp
      else
        knobCurrentVal[MIDIByte2Offset] = MIDIByte3Temp
      endif

      // send channel specific val
      sendData = [0x11, 0xEE, channelCC, knobSendVals[MIDIByte2Offset], MIDIByte3Temp]
      SendSysex sendData, 5
    endif

  endif

  // end channel specific

@End

@HandleTempo
  // NOTE because lighting does actually change the CC value, we need to handle this based on lighting
  // (MIDIByte3 >= -12 and MIDIByte3 <= -7) or (MIDIByte3 >= 7 and MIDIByte3 <= 12)
  // (MIDIByte3 >= 1 and MIDIByte3 <= 6) or (MIDIByte3 >= 20 and MIDIByte3 <= 25)
  // (MIDIByte3 >= 14 and MIDIByte3 <= 19) or (MIDIByte3 >= 33 and MIDIByte3 <= 38)
  // (MIDIByte3 >= 27 and MIDIByte3 <= 32) or (MIDIByte3 >= 46 and MIDIByte3 <= 51)
  // (MIDIByte3 >= 40 and MIDIByte3 <= 45) or (MIDIByte3 >= 59 and MIDIByte3 <= 64)
  // (MIDIByte3 >= 53 and MIDIByte3 <= 58) or (MIDIByte3 >= 72 and MIDIByte3 <= 77)
  // (MIDIByte3 >= 66 and MIDIByte3 <= 71) or (MIDIByte3 >= 85 and MIDIByte3 <= 90)
  // (MIDIByte3 >= 79 and MIDIByte3 <= 84) or (MIDIByte3 >= 98 and MIDIByte3 <= 103)
  // (MIDIByte3 >= 92 and MIDIByte3 <= 97) or (MIDIByte3 >= 111 and MIDIByte3 <= 116)
  // (MIDIByte3 >= 105 and MIDIByte3 <= 110) or (MIDIByte3 >= 123 and MIDIByte3 <= 126) // edge
  // (MIDIByte3 >= 118 and MIDIByte3 <= 122) or (MIDIByte3 >= 136 and MIDIByte3 <= 139) // edge

  // (MIDIByte3 >= -24 and MIDIByte3 <= -13) or (MIDIByte3 >= 13 and MIDIByte3 <= 24)
  // (MIDIByte3 >= 1 and MIDIByte3 <= 12) or (MIDIByte3 >= 38 and MIDIByte3 <= 49)
  // (MIDIByte3 >= 26 and MIDIByte3 <= 37) or (MIDIByte3 >= 63 and MIDIByte3 <= 74)
  // (MIDIByte3 >= 51 and MIDIByte3 <= 62) or (MIDIByte3 >= 88 and MIDIByte3 <= 99)
  // (MIDIByte3 >= 76 and MIDIByte3 <= 87) or (MIDIByte3 >= 113 and MIDIByte3 <= 126) // edge
  // (MIDIByte3 >= 101 and MIDIByte3 <= 112) or (MIDIByte3 >= 138 and MIDIByte3 <= 151)

  if tempoMode = 0
    CopyArray tempoMode0Vals, tempoModeVals, 11
    length = 10
    compUpConst = 5
    compDownConst = 5
    lightingConst = 13
  else
    if tempoMode = 1
      CopyArray tempoMode1Vals, tempoModeVals, 6
    elseif tempoMode = 2
      CopyArray tempoMode2Vals, tempoModeVals, 6
    elseif tempoMode = 3
      CopyArray tempoMode3Vals, tempoModeVals, 6
    endif
    length = 5
    compUpConst = 11
    compDownConst = 11
    lightingConst = 25
  endif

  for k = 0 to length // k used because this handler is used in a for loop with i and j as iterators

    lightingVal = k * lightingConst
    compUp = lightingVal + -1 * (lightingConst - 1)
    compDown = lightingVal + ((lightingConst + 1) / 2)

    // edge cases - hard coded since 127 is not a very convenient number to end on
    if tempoMode = 0
      if k = length - 1
        compDown = compDown - 1 // 123
        compDownConst = 3 // 126, later 139 since this won't be reset
      elseif k = length
        compUpConst = 4 // 122
      endif
    elseif k = length - 1
      compDownConst = 13 // 126, later 151 since this won't be reset
    endif

    if k = length
      lightingVal = 127
    endif

    if (MIDIByte3Temp >= compUp and MIDIByte3Temp <= compUp + compUpConst) or (MIDIByte3Temp >= compDown and MIDIByte3Temp <= compDown + compDownConst) or (MIDIByte3Temp = lightingVal)
      // NOTE last conditional above probably unnecessary, since we shouldn't be getting lighting input for processing
      tempoPulse = tempoModeVals[k]
      sendData = [0xCC, 0x03, tempoPulse]
      SendSysex sendData, 3
      sendData = [0x0F, 0xEE, 0xBA, 0x01, lightingVal]
      SendSysex sendData, 5
      if knobPush[MIDIByte2Offset] = 0
        pushReset[MIDIByte2Offset] = lightingVal
      endif
      knobCurrentVal[0] = lightingVal
    endif
  endfor
@End
