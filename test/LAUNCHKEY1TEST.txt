# TEST
# launchkey mini test code

# TEST NOTES
# NOTE phrase tested and passed all tests, but there may still be one unconfirmed bug where the notes are transposed downward incorrectly
# TODO this above bug has at this point occurred in final tests, still unconfirmed how it occurs










# END TEST
# launchkey mini (mk2)

# if phrase and arp are off, notes will be passed through as expected

IF LOAD

  SUBROUTINE INSERTION_SORT isOrder length
    ALIAS IF9 i
    ALIAS IFA j
    ALIAS IFB jPlusOne
    ALIAS IFC keyVal
    ALIAS IFD keyBool
    ALIAS IFE isSetSort
    ALIAS IFF lengthOffset

    MATH lengthOffset = length + 20

    IF isOrder == 1
      ASS i = 21
      WHILE i < lengthOffset
        ASS keyVal = KIF9
        ASS keyBool = JIF9
        MATH j = i - 1
        MATH jPlusOne = j + 1
        ASS isSetSort = 0
        IF j >= 20
          IF KIFA < keyVal
            ASS isSetSort = 1
          END
        END
        WHILE isSetSort == 1
          ASS KIFB = KIFA
          ASS JIFB = JIFA
          MATH j = j - 1
          MATH jPlusOne = j + 1
          ASS isSetSort = 0
          IF j >= 20
            IF KIFA < keyVal
              ASS isSetSort = 1
            END
          END
        END
        ASS KIFB = keyVal
        ASS JIFB = keyBool
        MATH i = i + 1
      END
    ELSE
      ASS i = 21
      WHILE i < lengthOffset
        ASS keyVal = JIF9
        ASS keyBool = KIF9
        MATH j = i - 1
        MATH jPlusOne = j + 1
        ASS isSetSort = 0
        IF j >= 20
          IF JIFA < keyVal
            ASS isSetSort = 1
          END
        END
        WHILE isSetSort == 1
          ASS JIFB = JIFA
          ASS KIFB = KIFA
          MATH j = j - 1
          MATH jPlusOne = j + 1
          ASS isSetSort = 0
          IF j >= 20
            IF JIFA < keyVal
              ASS isSetSort = 1
            END
          END
        END
        ASS JIFB = keyVal
        ASS KIFB = keyBool
        MATH i = i + 1
      END
    END
  END

  # global

  ALIAS G0 channel

  # constant

  ALIAS 00 channelVal # channel specific (obviously)
  ALIAS 20 arpIndexOffset
  ALIAS C8 latchInterval

  # local

  ALIAS I0 channelCC
  ALIAS I1 channelNoteOn
  ALIAS I2 channelNoteOff
  ALIAS I3 iter
  ALIAS I4 arpIndex
  ALIAS I5 numPressedTotal
  ALIAS I6 max
  ALIAS I7 valOfMax
  ALIAS I8 secondMax
  ALIAS I9 valOfSecondMax
  ALIAS IA tempPhraseVal
  ALIAS IB overload
  ALIAS IC phraseTemp
  ALIAS ID initLatch
  ALIAS IE latchTiming

  # sysex

  ALIAS J0 numPressed
  ALIAS J1 arpPhraseToggle
  ALIAS J2 arpPhraseOnOffToggle
  ALIAS J5 velocity
  ALIAS J6 arpValueModeMod
  ALIAS J7 setPhrase
  ALIAS J8 phraseVal
  ALIAS J9 phraseIndex
  ALIAS JA phraseLengthPlusOffset
  ALIAS JB latch

  # assign sysex variables

  ASS numPressed = 0
  ASS arpPhraseToggle = 0
  ASS arpPhraseOnOffToggle = 0
  ASS velocity = 64
  ASS arpValueModeMod = 0
  ASS setPhrase = 0
  ASS phraseVal = 3C
  ASS phraseIndex = 2A
  ASS phraseLengthPlusOffset = 2A
  ASS latch = 0
  ASS J20 = 00 00 00 00 00 00 00 00 00 00 # arp values (J10 J11 J12 J13 J14 J15 J16 J17 J18 J19)
  ASS J2A = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # phrase sequence (J2A J2B J2C J2D J2E J2F J30 J31 J32 J33 J34 J35 J36 J37 J38 J39 ETC.)
  # TEST
  # ensure phrase and arp values reset
  ASS LFF = 20
  WHILE LFF < 48
    LOG J_INDEX LFF
    LOG LFF JLFF
    MATH LFF = LFF + 1
  END
  # END TEST

  # assign local

  # these are only defined here, since they are essentially constants - will not change past this
  MATH channelCC = B0 + channelVal
  MATH channelNoteOn = 90 + channelVal
  MATH channelNoteOff = 80 + channelVal

  ASS K20 = 00 00 00 00 00 00 00 00 00 00

  ASS numPressedTotal = 0
  ASS arpIndex = arpIndexOffset
  # needs to be set to a value too far for both negatives and positives to reach
  ASS tempPhraseVal = AAAA
  ASS overload = 0
  ASS initLatch = 1

  ASS channel = 00 # channel specific (channel 0 only)

  # reset xtouch lighting and params
  SEND F0 FF 1B 00 F7 +F
  # TEST
  # ensure xtouch reset
  LOG XTOUCH_RESET
  # END TEST

  # reset channel information
  SEND F0 CC 1C 00 F7 +F
  # TEST
  # ensure channel information reset (will need to be done on individual files)
  LOG CHANNELS_RESET
  # END TEST

END

# sysex reception

IF M0 == F0

  IF M2 == 01
    ASS arpPhraseToggle = M3
    # if module is currently on
    IF arpPhraseOnOffToggle == 1
      # need to open gate so that there's a smooth transition here
      # SEND SYSEX
      SEND F0 CC 19 60 F7 +F
      # END SYSEX
    END
    # TEST
    # ensure launchkey receives arpPhraseToggle
    # ensure transition between arp and phrase is smooth if module is on
    LOG arpPhraseToggle_SYSEX_RECEIVED arpPhraseToggle
    # END TEST
    BLOCK
    EXIT
  END

  IF M2 == 02
    ASS arpPhraseOnOffToggle = M3
    # will need to send note release if latch is on
    IF latch == 1
      IF arpPhraseOnOffToggle == 1
        ASS iter = arpIndexOffset
        WHILE iter < arpIndex
          SEND channelNoteOff JI3 00
          MATH iter = iter + 1
        END
        # need to open gate so that there's a smooth transition here
        # SEND SYSEX
        SEND F0 CC 19 60 F7 +F
        # END SYSEX
      ELSE
        ASS iter = arpIndexOffset
        WHILE iter < arpIndex
          SEND channelNoteOn JI3 velocity
          MATH iter = iter + 1
        END
      END
    END
    # TEST
    # ensure launchkey receives arpPhraseOnOffToggle
    # ensure note release properly sent when arp/phrase turned on
    # ensure general transition with latch on to arp/phrase on is smooth
    # ensure note press properly sent when arp/phrase turned off
    # ensure general transition with latch on to arp/phrase off is smooth
    LOG arpPhraseOnOffToggle_SYSEX_RECEIVED arpPhraseOnOffToggle
    # END TEST
    BLOCK
    EXIT
  END

  IF M2 == 05
    ASS velocity = M3
    # TEST
    # ensure launchkey receives velocity
    LOG velocity_SYSEX_RECEIVED velocity
    # END TEST
    BLOCK
    EXIT
  END

  IF M2 == 06
    ASS arpValueModeMod = M3
    # TEST
    # ensure launchkey receives arpValueModeMod
    LOG arpValueModeMod_SYSEX_RECEIVED arpValueModeMod
    # END TEST
    BLOCK
    EXIT
  END

  # NOTE should setPhrase turn latch off?
  IF M2 == 07
    ASS setPhrase = M3
    # TEST
    # ensure launchkey receives setPhrase
    LOG setPhrase_SYSEX_RECEIVED JA
    # END TEST
    IF setPhrase == 0
      ASS phraseIndex = 2A
      ASS tempPhraseVal = AAAA
      FX = XX +B
      # TEST
      # ensure sysex resets phraseIndex when setPhrase is turned off
      LOG phraseIndex phraseIndex
      # END TEST
    END
    BLOCK
    EXIT
  END

  IF M2 == 0B
    ASS latch = M3
      IF latch == 0
        ASS iter = arpIndexOffset
        WHILE iter < arpIndex
          SEND channelNoteOff JI3 00
          ASS JI3 = 0
          ASS KI3 = 0
          MATH iter = iter + 1
        END
        ASS numPressed = 0
        ASS numPressedTotal = 0
        ASS arpIndex = arpIndexOffset
        # SEND SYSEX
        SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
        # END SYSEX
        # SEND SYSEX
        SEND F0 CC 00 numPressed F7 +F
        # END SYSEX
      END
    # TEST
    # ensure launchkey receives latch
    # ensure note release properly sent when latch turned off
    LOG latch_SYSEX_RECEIVED latch
    # END TEST
    BLOCK
    EXIT
  END
END

# end sysex reception

IF MT == B0
  # channel changed on release - should be released when hold released on launchkey
  # NOTE pressing a button / key and changing the channel before note off is not supported
  # channel change should use two hands, so hoping this will not come up
  # NOTE because this is what changes the hardware filter, the hardware filter will not properly filter out the channel change from any channel - needs to be set to receive channel specific channel change messages
  IF M0 == channelCC 6B 00

    # send channel change sysex
    # SEND SYSEX
    SEND F0 FF 1E CC F7 +F
    # END SYSEX

    # change channel variable here
    # NOTE currently global, but could change to sysex
    ASS channel = MC

    BLOCK
    EXIT
  END

  # full reset
  IF M1 == 68 7F

    # reset sysex variables

    ASS numPressed = 0
    ASS arpPhraseToggle = 0
    ASS arpPhraseOnOffToggle = 0
    ASS velocity = 64
    ASS arpValueModeMod = 0
    ASS setPhrase = 0
    ASS phraseVal = 3C
    ASS phraseIndex = 2A
    ASS phraseLengthPlusOffset = 2A
    ASS latch = 0
    ASS J20 = 00 00 00 00 00 00 00 00 00 00 # arp values (J10 J11 J12 J13 J14 J15 J16 J17 J18 J19)
    ASS J2A = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # phrase sequence (J2A J2B J2C J2D J2E J2F J30 J31 J32 J33 J34 J35 J36 J37 J38 J39 ETC.)
    # TEST
    # ensure phrase and arp values reset
    ASS LFF = 20
    WHILE LFF < 48
      LOG J_INDEX LFF
      LOG LFF JLFF
      MATH LFF = LFF + 1
    END
    # END TEST

    # reset local

    ASS K20 = 00 00 00 00 00 00 00 00 00 00

    ASS numPressedTotal = 0
    ASS arpIndex = arpIndexOffset
    # needs to be set to a value too far for both negatives and positives to reach
    ASS tempPhraseVal = AAAA
    ASS overload = 0
    ASS initLatch = 1

    # reset xtouch lighting and params
    SEND F0 FF 1B 00 F7 +F
    # TEST
    # ensure xtouch reset
    LOG XTOUCH_RESET
    # END TEST

    # reset channel information
    SEND F0 CC 1C 00 F7 +F
    # TEST
    # ensure channel information reset (will need to be done on individual files)
    LOG CHANNELS_RESET
    # END TEST

    BLOCK
    EXIT
  END

  # channel reset
  IF M1 == 6A 7F

    # reset sysex variables

    ASS numPressed = 0
    ASS arpPhraseToggle = 0
    ASS arpPhraseOnOffToggle = 0
    ASS velocity = 64
    ASS arpValueModeMod = 0
    ASS setPhrase = 0
    ASS phraseVal = 3C
    ASS phraseIndex = 2A
    ASS phraseLengthPlusOffset = 2A
    ASS latch = 0
    ASS J20 = 00 00 00 00 00 00 00 00 00 00 # arp values (J10 J11 J12 J13 J14 J15 J16 J17 J18 J19)
    ASS J2A = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # phrase sequence (J2A J2B J2C J2D J2E J2F J30 J31 J32 J33 J34 J35 J36 J37 J38 J39 ETC.)
    # TEST
    # ensure phrase and arp values reset
    ASS LFF = 20
    WHILE LFF < 48
      LOG J_INDEX LFF
      LOG LFF JLFF
      MATH LFF = LFF + 1
    END
    # END TEST

    # reset local

    ASS K20 = 00 00 00 00 00 00 00 00 00 00

    ASS numPressedTotal = 0
    ASS arpIndex = arpIndexOffset
    # needs to be set to a value too far for both negatives and positives to reach
    ASS tempPhraseVal = AAAA
    ASS overload = 0
    ASS initLatch = 1

    # reset xtouch lighting and params
    SEND F0 FF 1B 00 F7 +F
    # TEST
    # ensure xtouch reset
    LOG XTOUCH_RESET
    # END TEST

    # reset channel information
    SEND F0 CC 1C 00 F7 +F
    # TEST
    # ensure channel information reset (will need to be done on individual files)
    LOG CHANNELS_RESET
    # END TEST

    BLOCK
    EXIT
  END
END

IF M0 == channelNoteOn
  LOG channelNoteOn channelNoteOn
  LOG MT MT
  LOG M0 M0

  # RESET

  # if reset (key pressed limit exceeded), handle differently
  IF overload == 1
    MATH numPressed = numPressed + 1
    # SEND SYSEX
    SEND F0 CC 00 numPressed F7 +F
    # END SYSEX
    BLOCK
    EXIT
  END

  # setting arbitrary limit on number of keys pressed at a time to 10 (using 10 as comparator here because numPressed has not yet been increased)
  IF numPressed == A
    ASS J20 = 00 00 00 00 00 00 00 00 00 00
    # SEND SYSEX
    SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
    # END SYSEX
    ASS K20 = 00 00 00 00 00 00 00 00 00 00
    ASS overload = 1
    ASS numPressedTotal = 0
    ASS arpIndex = arpIndexOffset
    # necessary so that numPressed does not go past zero by mistake, as we have not yet incremented for this key press
    MATH numPressed = numPressed + 1
    # SEND SYSEX
    SEND F0 CC 00 numPressed F7 +F
    # END SYSEX
    ASS phraseVal = 3C
    # SEND SYSEX
    SEND F0 CC 08 phraseVal F7 +F
    # END SYSEX

    # TEST
    # ensure J array contains correct key values pressed on reset (0)
    # ensure K array contains correct order of keys pressed on reset (0)
    # ensure numPressed aligns with number of keys pressed on reset (0)
    # ensure numPressedTotal aligns with number of keys pressed total on reset (0)
    # ensure phraseVal reset to 3C on reset
    LOG J19 J19 # should always be 0, unless globalkey is updated
    LOG J20 J20
    LOG J21 J21
    LOG J22 J22
    LOG J23 J23
    LOG J24 J24
    LOG J25 J25
    LOG J26 J26
    LOG J27 J27
    LOG J28 J28
    LOG J29 J29
    LOG J2A J2A # should always be first value of phrase
    LOG ~~~~~~~~~~BREAK~~~~~~~~~~
    LOG K19 K19 # should always be 0
    LOG K20 K20
    LOG K21 K21
    LOG K22 K22
    LOG K23 K23
    LOG K24 K24
    LOG K25 K25
    LOG K26 K26
    LOG K27 K27
    LOG K28 K28
    LOG K29 K29
    LOG K2A K2A # should always be 0
    LOG ~~~~~~~~~~BREAK~~~~~~~~~~
    LOG numPressed numPressed
    LOG numPressedTotal numPressedTotal
    LOG phraseVal phraseVal
    # END TEST

    BLOCK
    EXIT
  END

  # LATCH

  IF latch == 1
    ASS latchTiming = T0
    # TEST
    # ensure latchValues are storing correctly on note press
    # ensure latchValues are reset if timing between notes is >=.1 second
    # ensure latchValues are added to if timing between notes <.1 second
    LOG latchTiming latchTiming
    LOG latchInterval latchInterval
    # END TEST
    # initLatch essentially performs timer reset, since timer is only reset on scene load
    # it prevents the overly large timer from being relevant on first ASS
    # if key press is NOT within time limit
    IF initLatch == 0
      IF latchTiming > latchInterval
        # reset arrays and send note releases
        ASS iter = arpIndexOffset
        WHILE iter < arpIndex
          # NOTE if the note value is the same as a value that has just been pressed, we need to resend the value, since that is what will be happening with any other overlapping values pressed
          SEND channelNoteOff JI3 00
          IF M1 == JI3
            SEND channelNoteOn JI3 velocity
          END
          ASS JI3 = 0
          ASS KI3 = 0
          MATH iter = iter + 1
        END
        ASS numPressed = 0
        ASS numPressedTotal = 0
        ASS arpIndex = arpIndexOffset
        # TEST
        LOG TIMING_OFF_LATCH_RESET
        # END TEST
      END
    ELSE
      ASS initLatch = 0
      # TEST
      LOG initLatch initLatch
      # END TEST
    END
  END

  # PHRASE

  # set initial note to calculate offset
  ASS phraseVal = M1
  # SEND SYSEX
  SEND F0 CC 08 phraseVal F7 +F
  # END SYSEX

  # ALL

  # add one to notes overall pressed
  MATH numPressedTotal = numPressedTotal + 1

  # store note value in first open spot in array
  # NOTE this uses arpIndex, which should be set to arpIndexOffset before first key is pressed
  # after first key is pressed, arpIndex will be increased by numPressed (see below)
  ASS JI4 = M1
  ASS KI4 = numPressedTotal

  # add one to current notes pressed
  # NOTE this is done before sorting to make sure proper length is parsed
  # this is done after array assignment so that the alignment with arpIndex is accurate in setting
  MATH numPressed = numPressed + 1
  # SEND SYSEX
  SEND F0 CC 00 numPressed F7 +F
  # END SYSEX

  # NOTE this could also be MATH arpIndex = arpIndexOffset + numPressed
  MATH arpIndex = arpIndex + 1

  # ARP

  # sort array / hashmap according to ascending, descending, order pressed
  IF arpValueModeMod < 6
    INSERTION_SORT 0 numPressed
  END
  IF arpValueModeMod > 8
    INSERTION_SORT 1 numPressed
  END
  # SEND SYSEX
  SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
  # END SYSEX

  # ALL

  IF numPressed == 1
    # gateOpened
    # SEND SYSEX
    SEND F0 CC 19 60 F7 +F
    # END SYSEX
  END
  # TEST TRY
  #IF numPressed > 1
  #  ASS gateOpened = 2
  #END
  # END TEST TRY

  # TEST
  # ensure J array contains correct key values pressed on key press
  # ensure K array contains correct order of keys pressed on key press
  # ensure numPressed aligns with number of keys pressed on key press
  # ensure numPressedTotal aligns with number of keys pressed total on key press
  # ensure gateOpened aligns with number of keys pressed total on key press
  # ensure phraseVal aligns with correct phraseVal on key press
  LOG J19 J19 # should always be 0, unless globalkey is updated
  LOG J20 J20
  LOG J21 J21
  LOG J22 J22
  LOG J23 J23
  LOG J24 J24
  LOG J25 J25
  LOG J26 J26
  LOG J27 J27
  LOG J28 J28
  LOG J29 J29
  LOG J2A J2A # should always be first value of phrase
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG K19 K19 # should always be 0
  LOG K20 K20
  LOG K21 K21
  LOG K22 K22
  LOG K23 K23
  LOG K24 K24
  LOG K25 K25
  LOG K26 K26
  LOG K27 K27
  LOG K28 K28
  LOG K29 K29
  LOG K2A K2A # should always be 0
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG numPressed numPressed
  LOG numPressedTotal numPressedTotal
  LOG phraseVal phraseVal
  # END TEST

  IF arpPhraseOnOffToggle == 1
    # only block notes if setPhrase is zero - if it's one, we need the setPhrase if statement to process the note
    IF setPhrase == 0
      NX = XX +B
    END
  END

END


LOG channelNoteOnPre channelNoteOn
LOG channelNoteOffPre channelNoteOff
LOG M0 M0
IF M0 == channelNoteOff
  LOG channelNoteOff channelNoteOff
  LOG MT MT
  LOG M0 M0

  # if reset (key pressed limit exceeded), handle differently
  IF overload == 1
    MATH numPressed = numPressed - 1
    # SEND SYSEX
    SEND F0 CC 00 numPressed F7 +F
    # END SYSEX
    IF numPressed == 0
      ASS overload = 0
    END
    BLOCK
    EXIT
  END

  # LATCH

  IF latch == 1
    # TEST
    # ensure note releases are blocked if latch is on
    LOG NOTE_RELEASE_BLOCKED
    # END TEST
    BLOCK
    EXIT
  END

  # ALL (max for PHRASE)

  # find the max l value, or the most recent key pressed
  # if the k value, or note value of that max is M1, we need to change the phrase offset
  # while we are iterating, we need to set the l value of whichever key is released to zero so we can reuse that index
  ASS max = 0
  ASS valOfMax = 0
  ASS secondMax = 0
  ASS valOfSecondMax = 0
  ASS iter = arpIndexOffset
  WHILE iter < arpIndex
    IF KI3 > max
      ASS secondMax = max
      ASS valOfSecondMax = valOfMax
      ASS max = KI3
      ASS valOfMax = JI3
    ELSE
      IF KI3 > secondMax
        ASS secondMax = KI3
        ASS valOfSecondMax = JI3
      END
    END
    IF JI3 == M1
      ASS JI3 = 0
      ASS KI3 = 0
    END
    MATH iter = iter + 1
  END

  # PHRASE

  # TEST
  LOG valOfMax valOfMax
  LOG M1 M1
  # END TEST

  IF valOfMax == M1
    # set value equal to second most recent key pressed
    # ASS gateOpened = 1 # NOTE uncommenting this and sending sysex would restart phrase whenever key lifted
    ASS phraseVal = valOfSecondMax
    # SEND SYSEX
    SEND F0 CC 08 phraseVal F7 +F
    # END SYSEX
  END

  # ARP

  # sort array / hashmap according to ascending, descending, order pressed
  IF arpValueModeMod < 6
    INSERTION_SORT 0 numPressed
  END
  IF arpValueModeMod > 8
    INSERTION_SORT 1 numPressed
  END
  # SEND SYSEX
  SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
  # END SYSEX

  # ALL

  # subract one from current notes pressed
  # NOTE this is done after sorting to make sure any removed values are pushed out
  MATH numPressed = numPressed - 1
  # SEND SYSEX
  SEND F0 CC 00 numPressed F7 +F
  # END SYSEX

  MATH arpIndex = arpIndex - 1

  IF numPressed == 0
    ASS J20 = 00 00 00 00 00 00 00 00 00 00
    # SEND SYSEX
    SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
    # END SYSEX
    ASS K20 = 00 00 00 00 00 00 00 00 00 00
    ASS numPressedTotal = 0
    ASS arpIndex = arpIndexOffset
    ASS phraseVal = 3C
    # SEND SYSEX
    SEND F0 CC 08 phraseVal F7 +F
    # END SYSEX
  END

  # TEST
  # ensure J array contains correct key values pressed on key release
  # ensure K array contains correct order of keys pressed on key release
  # ensure numPressed aligns with number of keys pressed on key release
  # ensure numPressedTotal aligns with number of keys pressed total on key release
  # ensure gateOpened aligns with number of keys pressed total on key release
  # ensure phraseVal aligns with correct phraseVal on key release
  LOG J19 J19 # should always be 0, unless global key is updated
  LOG J20 J20
  LOG J21 J21
  LOG J22 J22
  LOG J23 J23
  LOG J24 J24
  LOG J25 J25
  LOG J26 J26
  LOG J27 J27
  LOG J28 J28
  LOG J29 J29
  LOG J2A J2A # should always be first value of phrase
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG K19 K19 # should always be 0
  LOG K20 K20
  LOG K21 K21
  LOG K22 K22
  LOG K23 K23
  LOG K24 K24
  LOG K25 K25
  LOG K26 K26
  LOG K27 K27
  LOG K28 K28
  LOG K29 K29
  LOG K2A K2A # should always be 0
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG numPressed numPressed
  LOG numPressedTotal numPressedTotal
  LOG phraseVal phraseVal
  # END TEST

  IF arpPhraseOnOffToggle == 1
    NX = XX +B
  END

END

# NOTE could add these if statements to if statements above - I think this is slightly more readable
IF setPhrase == 1
  IF M0 == channelNoteOn
    # because we're taking offset here, we need to record each step as the difference between it and the last step
    # if tempPhraseVal has a previous value (i.e. is not the first key pressed in the phrase)
    # NOTE max phrase length at this point is 30
    IF tempPhraseVal == AAAA
      ASS tempPhraseVal = M1
    END
    MATH JJ9 = M1 - tempPhraseVal
    MATH phraseTemp = JJ9 / 100
    # SEND SYSEX
    SEND F0 CC phraseIndex phraseTemp JJ9 F7 +F
    # END SYSEX
    ASS phraseLengthPlusOffset = phraseIndex
    # SEND SYSEX
    SEND F0 CC 0A phraseLengthPlusOffset F7 +F
    # END SYSEX
    MATH phraseIndex = phraseIndex + 1
  END
  # if phraseRest is sent
  IF M2 == 1A 2E
    # assign value to 2E57, indicating a rest
    ASS JJ9 = 2E57
    # NOTE could remove math and hard code in 2E57
    MATH phraseTemp = JJ9 / 100
    # SEND SYSEX
    SEND F0 CC phraseIndex phraseTemp JJ9 F7 +F
    # END SYSEX
    ASS phraseLengthPlusOffset = phraseIndex
    # SEND SYSEX
    SEND F0 CC 0A phraseLengthPlusOffset F7 +F
    # END SYSEX
    MATH phraseIndex = phraseIndex + 1
  END
  # if phrase is at max limit, end setPhrase
  IF phraseIndex > 47
    ASS setPhrase = 0
    # SEND SYSEX
    SEND F0 FF 07 setPhrase F7 +F
    # END SYSEX
    ASS phraseIndex = 2A
    ASS tempPhraseVal = AAAA
  END
  FX = XX +B
  # block notes if phrase is on, since keypresses then should not make a noise
  IF arpPhraseOnOffToggle == 1
    NX = XX +B
  END
  # NOTE could block whatever is inputted here, to prevent notes from passing through while the phrase is running
  # this would make sense if phrase was toggled and on, but not if this was not the case
  # TEST
  # ensure phrase is being correctly set
  # ensure setPhrase is 0 if max limit reached, otherwise 1
  # ensure tempPhraseVal is the previous value
  # ensure phraseIndex is the previous index plus one
  LOG setPhrase
  LOG J2A J2A
  LOG J2B J2B
  LOG J2C J2C
  LOG J2D J2D
  LOG J2E J2E
  LOG J2F J2F
  LOG J30 J30
  LOG J31 J31
  LOG J32 J32
  LOG J33 J33
  LOG J34 J34
  LOG J35 J35
  LOG J36 J36
  LOG J37 J37
  LOG J38 J38
  LOG J39 J39
  LOG J3A J3A
  LOG J3B J3B
  LOG J3C J3C
  LOG J3D J3D
  LOG J3E J3E
  LOG J3F J3F
  LOG J40 J40
  LOG J41 J41
  LOG J42 J42
  LOG J43 J43
  LOG J44 J44
  LOG J45 J45
  LOG J46 J46
  LOG J47 J47
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG setPhrase setPhrase
  LOG tempPhraseVal tempPhraseVal
  LOG phraseIndex phraseIndex
  LOG phraseLengthPlusOffset phraseLengthPlusOffset
  # END TEST
END
