# test plan code
# NOTE that each file test is meant to be copied and pasted into SB - using this whole file will not function as expected

# xtouch


IF LOAD

  # NOTE dangerous - need to confirm that this is where we want the global reset to occur
  ASS G0 = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

  # local
  ALIAS I0 tempoMode
  ALIAS I1 arpValueMode

  # global
  ALIAS G0 channel
  ALIAS G2 arpPhraseToggle
  ALIAS G3 arpPhraseOnOffToggle
  ALIAS G4 tempoModeMod
  ALIAS G5 tempoPulse
  ALIAS G6 gate
  ALIAS G7 arpValueModeMod
  ALIAS G8 setPhrase
  ALIAS G9 waveguideToggle
  ALIAS GA drumParams
  ALIAS GE arpModeSwitched # gateOpened

  # assign local
  # NOTE if this isn't reset on each 'install', then it's technically possible it could increase to the value max
  ASS tempoMode = 0
  # NOTE if this isn't reset on each 'install', then it's technically possible it could decrease/increase to the value min/max
  ASS arpValueMode = 8000
END

# if it is a button push
IF MT == 90
  # if it is a knob 1 button push, increase tempo mode
  # if variable is too high, reset
  IF M1 == 00 7F
    MATH tempoMode = tempoMode + 1
    # set tempo mode to variable modulo 3
    MATH tempoModeMod = tempoMode % 4
    IF tempoModeMod == 0
      ASS tempoPulse = 24
      SEND BA 01 28
    END
    # set each tempoPulse to default value on switching
    # also send data to xtouch to reflect this
    IF tempoModeMod == 1
      ASS tempoPulse = 24
      SEND BA 01 0
    END
    IF tempoModeMod == 2
      ASS tempoPulse = 24
      SEND BA 01 53
    END
    IF tempoModeMod == 3
      ASS tempoPulse = 18
      SEND BA 01 53
    END
    # TEST
    # ensure tempoModeMod changes accordingly and tempoPulse correlates
    LOG tempoMode tempoModeMod
    LOG tempoPulse tempoPulse
    # END TEST
  END

  # if it is a button 1 push
  IF M0 == 9A 08 7F
    # if arp then increase variable
    IF arpPhraseToggle == 0
      MATH arpValueMode = arpValueMode + 1
      # set value mode to variable modulo 11
      MATH arpValueModeMod = arpValueMode % B
      # NOTE uncommenting this makes clockNum, isOctave, and arpIndex reset whenever the arpMode changes
      # ASS arpModeSwitched = 1
    # if phrase then toggle setPhrase
    ELSE
      IF setPhrase == 0
        ASS setPhrase = 1
        SEND 90 00 01
      ELSE
        ASS setPhrase = 0
        SEND F0 BB BB 07 +F
      END
    END
    # TEST
    # ensure arpValueModeMod changes accordingly or setPhrase changes
    LOG arpValueMode arpValueModeMod
    LOG setPhrase setPhrase
    # END TEST
  END

  # if it is a button 9 push
  IF M0 == 9A 10 7F
    # if arp then decrease variable
    IF arpPhraseToggle == 0
      MATH arpValueMode = arpValueMode - 1
      # set value mode to variable modulo 11
      MATH arpValueModeMod = arpValueMode % B
    # if phrase then add rest to phrase sequence
    ELSE
      SEND F0 AA AA F7 +F
      # TEST
      # ensure rest sent
      LOG REST_SYSEX_SENT
      # END TEST
    END
    # TEST
    # ensure arpValueModeMod changes accordingly
    LOG arpValueMode arpValueModeMod
    # END TEST
  END

  # if it is a button 2 push toggle arp / phrase
  IF M1 == 09 7F
    IF arpPhraseToggle == 0
      ASS arpPhraseToggle = 1
      SEND 90 01 01
    ELSE
      ASS arpPhraseToggle = 0
      IF setPhrase == 1
        ASS setPhrase = 0
        SEND F0 BB BB 07 +F
      END
    END
    # TEST
    # ensure arp and phrase are toggling and setPhrase is turned off (if on) when switched to arp
    IF arpPhraseToggle == 0
      LOG IS_ARP
    END
    IF arpPhraseToggle == 1
      LOG IS_PHRASE
    END
    LOG setPhrase setPhrase
    # END TEST
  END

  # if it is a button 10 push toggle button 2 selection on / off
  IF M1 == 11 7F
    IF arpPhraseOnOffToggle == 0
      ASS arpPhraseOnOffToggle = 1
      SEND 90 09 01
    ELSE
      ASS arpPhraseOnOffToggle = 0
    END
    # TEST
    # ensure arp/phrase module is turned off or on
    IF arpPhraseOnOffToggle == 0
      LOG MODULE_OFF
    END
    IF arpPhraseOnOffToggle == 1
      LOG MODULE_ON
    END
    # END TEST
  END

  # if it is channel 1-6
  IF channel <= 6
    IF M1 == 07 7F
      IF waveguideToggle == 0
        ASS waveguideToggle = 1
      ELSE
        ASS waveguideToggle = 0
      END
      # TEST
      # ensure waveguide is toggled properly
      IF waveguideToggle == 0
        LOG WAVEGUIDE_STRING
      END
      IF waveguideToggle == 1
        LOG WAVEGUIDE_TUBE
      END
      # END TEST
    END
    # TODO add lighting here
    # for all except the last, order is part 1, part 2, part 1 and 2
    # if it is button 5 - knobs control 'select'
    IF M1 == 0C 7F
      ASS drumParams = $14 $15 $16
      # TEST
      # ensure drumparams are assigned according to correct buttons
      LOG drumParams drumParams
      # END TEST
    END
    # if it is button 6 - knobs control 'level'
    IF M1 == 0D 7F
      ASS drumParams = $17 $18 $19
      # TEST
      # ensure drumparams are assigned according to correct buttons
      LOG drumParams drumParams
      # END TEST
    END
    # if it is button 7 - knobs control 'attack'
    IF M1 == 0E 7F
      ASS drumParams = $20 $21 $22
      # TEST
      # ensure drumparams are assigned according to correct buttons
      LOG drumParams drumParams
      # END TEST
    END
    # if it is button 8 - knobs control 'release'
    IF M1 == 0F 7F
      ASS drumParams = $23 $24 $25
      # TEST
      # ensure drumparams are assigned according to correct buttons
      LOG drumParams drumParams
      # END TEST
    END
    # if it is button 13 - knobs control 'pitch'
    IF M1 == 14 7F
      ASS drumParams = $26 $27 $28
      # TEST
      # ensure drumparams are assigned according to correct buttons
      LOG drumParams drumParams
      # END TEST
    END
    # if it is button 14 - knobs control 'modAmount'
    IF M1 == 15 7F
      ASS drumParams = $29 $30 $31
      # TEST
      # ensure drumparams are assigned according to correct buttons
      LOG drumParams drumParams
      # END TEST
    END
    # if it is button 15 - knobs control 'modRate'
    IF M1 == 16 7F
      ASS drumParams = $46 $47 $48
      # TEST
      # ensure drumparams are assigned according to correct buttons
      LOG drumParams drumParams
      # END TEST
    END
    # order is decay, body, tune, send
    # if it is button 16 - knobs control 'waveguide'
    IF M1 == 17 7F
      ASS drumParams = $17 $18 $19 $103
      # TEST
      # ensure drumparams are assigned according to correct buttons
      LOG drumParams drumParams
      # END TEST
    END
  END
END

# if it is a button note-off (important for lighting)
IF MT == 80
  IF M1 == 08 00
    IF arpPhraseToggle == 1
      IF setPhrase == 1
        SEND 90 00 01
      END
    END
  END

  IF M1 == 09 00
    IF arpPhraseToggle == 1
      SEND 90 01 01
    ELSE
      IF setPhrase == 0
        SEND 90 00 00
      END
    END
  END

  IF M1 == 11 00
    IF arpPhraseOnOffToggle == 1
      SEND 90 09 01
    END
  END
END

# if it is a knob turn
IF MT == B0
  # if knob is 1 (tempo)
  IF M1 == 1
    IF arpPhraseOnOffToggle == 1
      # if arp tempo mode is 0
      IF tempoModeMod == 0
        # if knob value is 0-11
        IF M2 < 12
          ASS tempoPulse = $48
        END
        # if knob value is 12-22
        IF M2 >= 12
          IF M2 < 23
            ASS tempoPulse = $36
          END
        END
        # if knob value is 23-33
        IF M2 >= 23
          IF M2 < 34
            ASS tempoPulse = $24
          END
        END
        # if knob value is 34-45
        IF M2 >= 34
          IF M2 < 46
            ASS tempoPulse = $18
          END
        END
        # if knob value is 46-57
        IF M2 >= 46
          IF M2 < 58
            ASS tempoPulse = $12
          END
        END
        # if knob value is 58-69
        IF M2 >= 58
          IF M2 < 70
            ASS tempoPulse = $9
          END
        END
        # if knob value is 70-81
        IF M2 >= 70
          IF M2 < 82
            ASS tempoPulse = $6
          END
        END
        # if knob value is 82-93
        IF M2 >= 82
          IF M2 < 94
            ASS tempoPulse = $4
          END
        END
        # if knob value is 94-104
        IF M2 >= 94
          IF M2 < 105
            ASS tempoPulse = $3
          END
        END
        # if knob value is 105-115
        IF M2 >= 105
          IF M2 < 116
            ASS tempoPulse = $2
          END
        END
        # if knob value is 116-127
        IF M2 >= 116
          ASS tempoPulse = $1
        END
      END
      # if arp tempo mode is 1
      IF tempoModeMod == 1
        # if knob value is 0-21
        IF M2 < 22
          ASS tempoPulse = $24
        END
        # if knob value is 22-42
        IF M2 >= 22
          IF M2 < 43
            ASS tempoPulse = $12
          END
        END
        # if knob value is 43-63
        IF M2 >= 43
          IF M2 < 64
            ASS tempoPulse = $9
          END
        END
        # if knob value is 64-84
        IF M2 >= 64
          IF M2 < 85
            ASS tempoPulse = $6
          END
        END
        # if knob value is 85-105
        IF M2 >= 85
          IF M2 < 106
            ASS tempoPulse = $4
          END
        END
        # if knob value is 106-127
        IF M2 >= 106
          ASS tempoPulse = $3
        END
      END
      # if arp tempo mode is 2
      IF tempoModeMod == 2
        # if knob value is 0-21
        IF M2 < 22
          ASS tempoPulse = $96
        END
        # if knob value is 22-42
        IF M2 >= 22
          IF M2 < 43
            ASS tempoPulse = $48
          END
        END
        # if knob value is 43-63
        IF M2 >= 43
          IF M2 < 64
            ASS tempoPulse = $24
          END
        END
        # if knob value is 64-84
        IF M2 >= 64
          IF M2 < 85
            ASS tempoPulse = $12
          END
        END
        # if knob value is 85-105
        IF M2 >= 85
          IF M2 < 106
            ASS tempoPulse = $6
          END
        END
        # if knob value is 106-127
        IF M2 >= 106
          ASS tempoPulse = $3
        END
      END
      # if arp tempo mode is 3
      IF tempoModeMod == 3
        # if knob value is 0-21
        IF M2 < 22
          ASS tempoPulse = $72
        END
        # if knob value is 22-42
        IF M2 >= 22
          IF M2 < 43
            ASS tempoPulse = $36
          END
        END
        # if knob value is 43-63
        IF M2 >= 43
          IF M2 < 64
            ASS tempoPulse = $18
          END
        END
        # if knob value is 64-84
        IF M2 >= 64
          IF M2 < 85
            ASS tempoPulse = $9
          END
        END
        # if knob value is 85-105
        IF M2 >= 85
          IF M2 < 106
            ASS tempoPulse = $4
          END
        END
        # if knob value is 106-127
        IF M2 >= 106
          ASS tempoPulse = $2
        END
      END
    END
  END
  # if knob is 2 (gate)
  # starting points: max will be ~5 seconds (5000), min will be .1 seconds (100)
  IF M1 == 2
    MATH gate = M3 * 39
    MATH gate = gate + 100
  END
END

# launchkey mini

SUBROUTINE INSERTION_SORT isOrder length
  ALIAS I10 i
  ALIAS I11 j
  ALIAS I12 jPlusOne
  ALIAS I13 keyVal
  ALIAS I14 keyBool
  ALIAS I15 isSetSort

  IF isOrder == 1
    ASS i = 10
    WHILE i < length
      ASS keyVal = JI10
      ASS keyBool = GI10
      MATH j = i - 1
      MATH jPlusOne = j + 1
      ASS isSetSort = 0
      IF j >= 0
        IF JI11 < keyVal
          ASS isSetSort = 1
        END
      END
      WHILE isSetSort == 1
        ASS JI12 = JI11
        ASS GI12 = GI11
        MATH j = j - 1
        MATH jPlusOne = j + 1
        ASS isSetSort = 0
        IF j >= 0
          IF JI11 < keyVal
            ASS isSetSort = 1
          END
        END
      END
      ASS JI12 = keyVal
      ASS GI12 = keyBool
      MATH i = i + 1
    END
  ELSE
    ASS i = 10
    WHILE i < length
      ASS keyVal = GI10
      ASS keyBool = JI10
      MATH j = i - 1
      MATH jPlusOne = j + 1
      ASS isSetSort = 0
      IF j >= 0
        IF GI11 < keyVal
          ASS isSetSort = 1
        END
      END
      WHILE isSetSort == 1
        ASS GI12 = GI11
        ASS JI12 = JI11
        MATH j = j - 1
        MATH jPlusOne = j + 1
        ASS isSetSort = 0
        IF j >= 0
          IF GI11 < keyVal
            ASS isSetSort = 1
          END
        END
      END
      ASS GI12 = keyVal
      ASS JI12 = keyBool
      MATH i = i + 1
    END
  END
END

IF LOAD

  # constant

  ALIAS 10 arpIndexOffset

  # local
  ALIAS I0 iter
  ALIAS I1 isSet
  ALIAS I2 arpIndex
  ALIAS I3 numPressedTotal
  ALIAS I4 max
  ALIAS I5 maxIndex
  ALIAS I6 secondMax
  ALIAS I7 secondMaxIndex
  ALIAS I8 tempPhraseVal
  ALIAS I9 phraseIndex

  # global
  ALIAS G1 numPressed
  ALIAS G2 arpPhraseToggle
  ALIAS G3 arpPhraseOnOffToggle
  ALIAS G7 arpValueModeMod
  ALIAS G8 setPhrase
  ALIAS GE gateOpened
  ALIAS GF phraseVal
  ALIAS G10 phraseLengthPlusOffset

  # assign local
  # NOTE technically K does not need to be reset here, since only L is parsed - doing so as good practice
  ASS J0 = 00 00 00 00 00 00 00 00 00 00
  ASS K0 = 00 00 00 00 00
  ASS L0 = 00 00 00 00 00

  ASS numPressedTotal = 0
  # needs to be set to a value too far for both negatives and positives to reach
  ASS tempPhraseVal = AAAA
  ASS phraseIndex = 2A
  
END

IF MT == B0
  IF M1 == 69 7F # TODO placeholder - two buttons at once? double tap?
    # on init, this should init the global array to something basic
    # NOTE init here?
    # consider making init file, where one sysex inits just the global array, the other all channels are cleared
    # channelmanage file? this would break with the one midi device to each SB instance
    # can also possibly save instances from multiple sessions using another StreamByter and +P

    # NOTE we could filter so that these messages only get sent to channels
    # this would depend on how much data an SB file could interpret at once, with keys and everything being passed through as well

    # NOTE depending on routing, we may just need to send one message
    # receiving a message that does not match the channel triggers an auto save (this may require some timer, since this might be a race condition)
    # signal previous channel file to save
    # signal next channel file to load
    # SEND F0 C4 MC G0 F7 +F

    # NOTE will need to send lighting to x touch for sure, but setting the global channel should be enough to change routing
    # NOTE need to review routing, because if only one channel can route through launchkeymini, only one channel can use these features at a time
    # this is fine (and expected) for live keyboard playing without latch, but will likely be an issue when using modstep

    # assign local variables
    ASS J0 = 00 00 00 00 00 00 00 00 00 00
    ASS K0 = 00 00 00 00 00
    ASS L0 = 00 00 00 00 00
    ASS numPressedTotal = 0
    ASS tempPhraseVal = AAAA
    ASS phraseIndex = 2A

    # assign global variables
    ASS G0 = MC

    # NOTE only necessary for implementing latch functionality
    # load local arrays for channel

    # NOTE ensure to block specific sysex input so it isn't passed out
  END
END

# if arp / phrase is on
IF arpPhraseOnOffToggle == 1
  # if arp / phrase is arp
  IF arpPhraseToggle == 0
    # if key is pressed
    IF MT == 90
      
      # setting arbitrary limit on number of keys pressed at a time to 10
      IF numPressed == 11
        ASS G20 = 00 00 00 00 00 00 00 00 00 00
        ASS J0 = 00 00 00 00 00 00 00 00 00 00
        ASS numPressed = 0
        ASS numPressedTotal = 0
        # TEST
        # ensure G array contains correct key values pressed on reset (0)
        # ensure J array contains correct order of keys pressed on reset (0)
        # ensure numPressed aligns with number of keys pressed on reset (0)
        # ensure numPressedTotal aligns with number of keys pressed total on reset (0)
        LOG isArp
        LOG G20 G20
        LOG G21 G21
        LOG G22 G22
        LOG G23 G23
        LOG G24 G24
        LOG G25 G25
        LOG G26 G26
        LOG G27 G27
        LOG G28 G28
        LOG G29 G29
        LOG ~~~~~~~~~~BREAK~~~~~~~~~~
        LOG J0 J0
        LOG J1 J1
        LOG J2 J2
        LOG J3 J3
        LOG J4 J4
        LOG J5 J5
        LOG J6 J6
        LOG J7 J7
        LOG J8 J8
        LOG J9 J9
        LOG ~~~~~~~~~~BREAK~~~~~~~~~~
        LOG numPressed numPressed
        LOG numPressedTotal numPressedTotal
        # END TEST
        BLOCK
        EXIT
      END
      
      # add one to notes overall pressed
      MATH numPressedTotal = numPressedTotal + 1

      # store note value in first open spot in array
      MATH arpIndex = arpIndexOffset + numPressed
      ASS GI2 = M1
      ASS JI2 = numPressedTotal

      # sort array / hashmap according to ascending, descending, order pressed
      IF arpValueModeMod == 3
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod == 4
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod == 5
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod < 3
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod > 8
        INSERTION_SORT 1 numPressed
      END
      
      MATH numPressed = numPressed + 1

      IF numPressed == 1
        ASS gateOpened = 1
      END

    # TEST
    # ensure G array contains correct key values pressed on key press
    # ensure J array contains correct order of keys pressed on key press
    # ensure numPressed aligns with number of keys pressed on key press
    # ensure numPressedTotal aligns with number of keys pressed total on key press
    # ensure gateOpened aligns with number of keys pressed total on key press
    LOG isArp
    LOG G20 G20
    LOG G21 G21
    LOG G22 G22
    LOG G23 G23
    LOG G24 G24
    LOG G25 G25
    LOG G26 G26
    LOG G27 G27
    LOG G28 G28
    LOG G29 G29
    LOG ~~~~~~~~~~BREAK~~~~~~~~~~
    LOG J0 J0
    LOG J1 J1
    LOG J2 J2
    LOG J3 J3
    LOG J4 J4
    LOG J5 J5
    LOG J6 J6
    LOG J7 J7
    LOG J8 J8
    LOG J9 J9
    LOG ~~~~~~~~~~BREAK~~~~~~~~~~
    LOG numPressed numPressed
    LOG numPressedTotal numPressedTotal
    LOG gateOpened gateOpened
    # END TEST
      
      NX = XX +B
      
    END

    IF MT == 80
      # remove note value from array
      # decrease number of notes that need to be iterated through
      ASS iter = 10
      ASS isSet = 0
      WHILE isSet != 1
        # if iter is the note value, remove values
        IF GI0 == M1
          ASS GI0 = 0
          ASS JI0 = 0
          ASS isSet = 1
        END
        MATH iter = iter + 1
        IF iter == numPressed
          ASS isSet = 1
        END
      END
      
      # sort array / hashmap according to ascending, descending, order pressed
      IF arpValueModeMod == 3
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod == 4
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod == 5
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod < 3
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod > 8
        INSERTION_SORT 1 numPressed
      END
      
      MATH numPressed = numPressed - 1
      IF numPressed == 0
        ASS G20 = 00 00 00 00 00 00 00 00 00 00
        ASS J0 = 00 00 00 00 00 00 00 00 00 00
        ASS numPressedTotal = 0
      END

    # TEST
    # ensure G array contains correct key values pressed on key release
    # ensure J array contains correct order of keys pressed on key release
    # ensure numPressed aligns with number of keys pressed on key release
    # ensure numPressedTotal aligns with number of keys pressed total on key release
    # ensure gateOpened aligns with number of keys pressed total on key release
    LOG isArp
    LOG G20 G20
    LOG G21 G21
    LOG G22 G22
    LOG G23 G23
    LOG G24 G24
    LOG G25 G25
    LOG G26 G26
    LOG G27 G27
    LOG G28 G28
    LOG G29 G29
    LOG ~~~~~~~~~~BREAK~~~~~~~~~~
    LOG J0 J0
    LOG J1 J1
    LOG J2 J2
    LOG J3 J3
    LOG J4 J4
    LOG J5 J5
    LOG J6 J6
    LOG J7 J7
    LOG J8 J8
    LOG J9 J9
    LOG ~~~~~~~~~~BREAK~~~~~~~~~~
    LOG numPressed numPressed
    LOG numPressedTotal numPressedTotal
    LOG gateOpened gateOpened
    # END TEST
      
      NX = XX +B
      
    END
  # else isPhrase
  ELSE
    # if key pressed
    IF MT == 90
      
      # ASS gateOpened = 1 # NOTE uncommenting this would restart phrase whenever key pressed

      # setting arbitrary limit on number of keys pressed at a time to 5
      IF numPressed == 5
        ASS L0 = 00 00 00 00 00
        ASS numPressed = 0
        ASS numPressedTotal = 0
        # TEST
        # ensure K array contains correct key values pressed on reset (0)
        # ensure L array contains correct order of keys pressed on reset (0)
        # ensure numPressed aligns with number of keys pressed on reset (0)
        # ensure numPressedTotal aligns with number of keys pressed total on reset (0)
        LOG isPhrase
        LOG K0 K0
        LOG K1 K1
        LOG K2 K2
        LOG K3 K3
        LOG K4 K4
        LOG ~~~~~~~~~~BREAK~~~~~~~~~~
        LOG L0 L0
        LOG L1 L1
        LOG L2 L2
        LOG L3 L3
        LOG L4 L4
        LOG ~~~~~~~~~~BREAK~~~~~~~~~~
        LOG numPressed numPressed
        LOG numPressedTotal numPressedTotal
        # END TEST
        BLOCK
        EXIT
      END
      
      # set initial note to calculate offset
      ASS phraseVal = M1
      
      # add to number of keys pressed
      MATH numPressed = numPressed + 1
      MATH numPressedTotal = numPressedTotal + 1
      
      # we need to have a while loop here to account for the user pressing and releasing keys in different orders
      # say user presses A, B, C, then lifts up B
      # this sets numPressed to 2, but when another key is pressed it will overwrite C if we continue linearly
      ASS iter = 1
      ASS isSet = 0
      WHILE isSet != 1
        IF LI0 == 0
          # add note value into K - this array's indices will all be >= 1
          ASS KI0 = M1
          # add note index in L to show it is pressed - this array's indices will all be >= 1
          ASS LI0 = numPressedTotal
          ASS isSet = 1
        END
        MATH iter = iter + 1
      END

      IF numPressed == 1
        ASS gateOpened = 1
      END

      # TEST
      # ensure K array contains correct key values pressed on key press
      # ensure L array contains correct order of keys pressed on key press
      # ensure numPressed aligns with number of keys pressed on key press
      # ensure numPressedTotal aligns with number of keys pressed total on key press
      # ensure gateOpened aligns with number of keys pressed total on key press
      LOG isPhrase
      LOG K0 K0
      LOG K1 K1
      LOG K2 K2
      LOG K3 K3
      LOG K4 K4
      LOG ~~~~~~~~~~BREAK~~~~~~~~~~
      LOG L0 L0
      LOG L1 L1
      LOG L2 L2
      LOG L3 L3
      LOG L4 L4
      LOG ~~~~~~~~~~BREAK~~~~~~~~~~
      LOG numPressed numPressed
      LOG numPressedTotal numPressedTotal
      LOG gateOpened gateOpened
      # END TEST
      
    END

    IF MT == 80
      # stop if no keys pressed
      MAT numPressed = numPressed - 1
      IF numPressed < 1
        ASS L0 = 00 00 00 00 00
        ASS numPressedTotal = 0
      END
      
      # find the max k value, or the most recent key pressed
      # if the j value, or note value of that max is M1, we need to change the phrase offset,
      # so reset the g values, setting G1 to the second most recent key pressed
      # while we are iterating, we need to set the k value of whichever key is pressed to zero so we can reuse that index
      ASS max = 0
      ASS secondMax = 0
      ASS iter = 1
      WHILE iter <= 5
        IF LI0 > max
          ASS secondMax = max
          ASS max = LI0
          ASS secondMaxIndex = maxIndex
          ASS maxIndex = iter
        ELSE
          IF LI0 > secondMax
            ASS secondMax = LI0
            ASS secondMaxIndex = iter
          END
        END
        IF KI0 == M1
          ASS LI0 = 0
        END
        MATH iter = iter + 1
      END
      IF KI5 == M1
        # set value equal to second most recent key pressed
        # ASS gateOpened = 1 # NOTE uncommenting this would restart phrase whenever key lifted
        ASS phraseVal = KI7
      END

      # TEST
      # ensure K array contains correct key values pressed on key release
      # ensure L array contains correct order of keys pressed on key release
      # ensure numPressed aligns with number of keys pressed on key release
      # ensure numPressedTotal aligns with number of keys pressed total on key release
      # ensure gateOpened aligns with number of keys pressed total on key release
      LOG isPhrase
      LOG K0 K0
      LOG K1 K1
      LOG K2 K2
      LOG K3 K3
      LOG K4 K4
      LOG ~~~~~~~~~~BREAK~~~~~~~~~~
      LOG L0 L0
      LOG L1 L1
      LOG L2 L2
      LOG L3 L3
      LOG L4 L4
      LOG ~~~~~~~~~~BREAK~~~~~~~~~~
      LOG numPressed numPressed
      LOG numPressedTotal numPressedTotal
      LOG gateOpened gateOpened
      LOG phraseVal phraseVal
      # END TEST
      
    END

  END

END

IF setPhrase == 1
  IF MT == 90
    # because we're taking offset here, we need to record each step as the difference between it and the last step
    # if tempPhraseVal has a previous value (i.e. is not the first key pressed in the phrase)
    IF tempPhraseVal != AAAA
      MATH GI9 = M1 - tempPhraseVal
      ASS phraseLengthPlusOffset = phraseIndex
      MATH phraseIndex = phraseIndex + 1
      ASS tempPhraseVal = M1
    # else tempPhraseVal does not have a previous value, this is the first entered value, and no record in the global array is necessary
    ELSE
      ASS tempPhraseVal = M1
    END
    # if phrase is at max limit, end setPhrase
    IF phraseIndex > 39
      ASS setPhrase = 0
      ASS tempPhraseVal = AAAA
    END
  END
  # if phraseRest is sent
  # NOTE might need to filter the sysex messages here to prevent them from passing through and causing havoc
  IF M0 == F0 AA AA F7
    # assign value to AAAA, indicating a rest
    ASS GI9 = AAAA
    MATH phraseIndex = phraseIndex + 1

    # if phrase is at max limit, end setPhrase
    IF phraseIndex > 39
      ASS setPhrase = 0
      ASS tempPhraseVal = AAAA
    END
  END
  # ensure phraseIndex is reset when setPhrase is turned off from xtouch
  IF M0 == F0 BB BB 07
    ASS phraseIndex = AAAA
  END
  # NOTE could block whatever is inputted here
  # this would make sense if phrase was toggled and on, but not if this was not the case
  # TEST
  # ensure phrase is being correctly set
  # ensure setPhrase is 0 if max limit reached, otherwise 1
  # ensure tempPhraseVal is the previous value
  # ensure phraseIndex is the previous index plus one
  LOG setPhrase
  LOG G2A G2A
  LOG G2B G2B
  LOG G2C G2C
  LOG G2D G2D
  LOG G2E G2E
  LOG G2F G2F
  LOG G30 G30
  LOG G31 G31
  LOG G32 G32
  LOG G33 G33
  LOG G34 G34
  LOG G35 G35
  LOG G36 G36
  LOG G37 G37
  LOG G38 G38
  LOG G39 G39
  LOG G3A G3A
  LOG G3B G3B
  LOG G3C G3C
  LOG G3D G3D
  LOG G3E G3E
  LOG G3F G3F
  LOG G40 G40
  LOG G41 G41
  LOG G42 G42
  LOG G43 G43
  LOG G44 G44
  LOG G45 G45
  LOG G46 G46
  LOG G47 G47
  LOG G48 G48
  LOG G49 G49
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG setPhrase setPhrase
  LOG tempPhraseVal tempPhraseVal
  LOG phraseIndex phraseIndex
  # END TEST
END

IF M0 == F0
  XX = XX +B
END
