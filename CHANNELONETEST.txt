# channel one test code

# TEST NOTES
# NOTE the order in which these notes will be played is up in the air - currently the array is reset without regard to arpIndex, but in the future it may be preferred to reset the array only once all elements in the current array are iterated through (arpIndex = length of array + arpOffset)
# see TEST TRY here and in channel one for more information









# channel one

# this instance will constantly be receiving clock, the question will be whether it responds to it or not
# there will be another service receiving note in - if arpPhraseOnOffToggle is on, notes will be processed, otherwise, they will not

# note that the assumption here is that the global array information will be used, not the local array
# the local array will just be used for storage

# possible future updates - addings 'reverse' and 'bounce' for phrase (stochastic etc. whatever)

# need to reassign arpIndex whenever mode is changed

# NOTE maxVal for clockNum is based off 227 * 288 = floor(65,535 / 288) * (ffff / lcm of all possible tempoPulse)

# arpTypes
# 1: ascending one octave
# 2: ascending two octave
# 3: ascending three octave
# 4: descending one octave
# 5: descending two octave
# 6: descending three octave
# 7: random one octave
# 8: random two octave
# 9: random three octave
# 10: order pressed one octave
# 11: order pressed two octave
# 12: order pressed three octave

# J is the local storage array (database)

IF LOAD

  # constant
  ALIAS FF60 maxValClockNum
  ALIAS 00 thisChannel
  ALIAS 20 arpOffset

  # local
  ALIAS I0 clockNum
  ALIAS I1 clockNumMod
  ALIAS I2 arpIndex
  ALIAS I3 isOctave
  ALIAS I4 isOctaveMod
  ALIAS I5 arpOctaveValue
  ALIAS I6 phraseValSend
  # NOTE this phraseIndex is the playing index, not the setting index
  ALIAS I7 phraseIndex
  ALIAS I8 numPressedOffset
  ALIAS I9 phraseTemp # TODO
  ALIAS IA gateTemp # TODO

  ALIAS J0 currentChannel
  ALIAS J1 numPressed
  ALIAS J2 arpPhraseToggle
  ALIAS J3 arpPhraseOnOffToggle
  ALIAS J5 tempoPulse
  ALIAS J7 gate
  ALIAS J8 velocity
  ALIAS J9 arpValueModeMod
  ALIAS JB phraseVal
  ALIAS JD phraseLengthPlusOffset
  ALIAS JE gateOpened

  # assign local
  ASS clockNum = 0
  ASS isOctave = 0

  # TEST
  ALIAS L0 tempVar1
  ALIAS L1 tempVar2
  # END TEST
END

# sysex reception

IF M0 == F0 01
  ASS numPressed = M2
  # TEST
  # ensure channel receives numPressed
  LOG numPressed_SYSEX_RECEIVED J1
  # END TEST
  BLOCK
  EXIT
END

IF M0 == F0 02
  ASS arpPhraseToggle = M2
  # TEST
  # ensure channel receives arpPhraseToggle
  LOG arpPhraseToggle_SYSEX_RECEIVED J2
  # END TEST
  BLOCK
  EXIT
END

IF M0 == F0 03
  ASS arpPhraseOnOffToggle = M2
  # TEST
  # ensure channel receives arpPhraseOnOffToggle
  LOG arpPhraseOnOffToggle_SYSEX_RECEIVED J3
  # END TEST
  BLOCK
  EXIT
END

IF M0 == F0 05
  ASS tempoPulse = M2
  # TEST
  # ensure channel receives tempoPulse
  LOG tempoPulse_SYSEX_RECEIVED J5
  # END TEST
  BLOCK
  EXIT
END

IF M0 == F0 07
  MATH gateTemp = M2 * 100
  MATH gateTemp = gateTemp + M3
  ASS gate = gateTemp
  # TEST
  # ensure channel receives gate
  LOG gate_SYSEX_RECEIVED J7
  # END TEST
  BLOCK
  EXIT
END

IF M0 == F0 08
  ASS velocity = M2
  # TEST
  # ensure channel receives velocity
  LOG velocity_SYSEX_RECEIVED J8
  # END TEST
  BLOCK
  EXIT
END

IF M0 == F0 09
  ASS arpValueModeMod = M2
  # TEST
  # ensure channel receives arpValueModeMod
  LOG arpValueModeMod_SYSEX_RECEIVED J9
  # END TEST
  BLOCK
  EXIT
END

IF M0 == F0 0B
  ASS phraseVal = M2
  # TEST
  # ensure channel receives phraseVal
  LOG phraseVal_SYSEX_RECEIVED JB
  # END TEST
  BLOCK
  EXIT
END

IF M0 == F0 0D
  ASS phraseLengthPlusOffset = M2
  # TEST
  # ensure channel receives phraseLengthPlusOffset
  LOG phraseLengthPlusOffset_SYSEX_RECEIVED JD
  # END TEST
  BLOCK
  EXIT
END

IF M0 == F0 0E
  ASS gateOpened = M2
  # TEST
  # ensure channel receives gateOpened
  LOG gateOpened_SYSEX_RECEIVED JE
  # END TEST
  BLOCK
  EXIT
END

IF M0 == F0 20
  ASS J20 = M2 M3 M4 M5 M6 M7 M8 M9 MA MB
  # TEST
  # ensure channel receives arpValues
  LOG arpValues_SYSEX_RECEIVED
  LOG J20 J20
  LOG J21 J21
  LOG J22 J22
  LOG J23 J23
  LOG J24 J24
  LOG J25 J25
  LOG J26 J26
  LOG J27 J27
  LOG J28 J28
  LOG J29 J29
  # END TEST
  BLOCK
  EXIT
END

IF M0 == F0
  IF M1 > 29
    MATH phraseTemp = M2 * 100
    MATH phraseTemp = phraseTemp + M3
    ASS JM1 = phraseTemp
    # TEST
    # ensure channel receives phraseValues
    LOG phraseValues_SYSEX_RECEIVED JM1
    LOG J2A J2A
    LOG J2B J2B
    LOG J2C J2C
    LOG J2D J2D
    LOG J2E J2E
    LOG J2F J2F
    LOG J30 J30
    LOG J31 J31
    LOG J32 J32
    LOG J33 J33
    LOG J34 J34
    LOG J35 J35
    LOG J36 J36
    LOG J37 J37
    LOG J38 J38
    LOG J39 J39
    LOG J3A J3A
    LOG J3B J3B
    LOG J3C J3C
    LOG J3D J3D
    LOG J3E J3E
    LOG J3F J3F
    LOG J40 J40
    LOG J41 J41
    LOG J42 J42
    LOG J43 J43
    LOG J44 J44
    LOG J45 J45
    LOG J46 J46
    LOG J47 J47
    # END TEST
    BLOCK
    EXIT
  END
END

# Reset channel when init sysex received
# NOTE M1 used due to SB limiting comparisons to four indices
IF M1 == FF 00 00 0C
  ASS J0 = 00 # currentChannel
  ASS J1 = 00 # numPressed
  ASS J2 = 00 # arpPhraseToggle
  ASS J3 = 00 # arpPhraseOnOffToggle
  ASS J4 = 00 # tempoModeMod
  ASS J5 = 24 # tempoPulse
  ASS J6 = 00 # gateModeMod
  ASS J7 = 00 # gate
  ASS J8 = 64 # velocity
  ASS J9 = 00 # arpValueModeMod
  ASS JA = 00 # setPhrase
  ASS JB = 00 # phraseVal
  ASS JC = 2A # phraseindex
  ASS JD = 2A # phraseLengthPlusOffset
  ASS JE = 00 # gateOpened
  ASS JF = 00 # waveguideToggle
  ASS J10 = 0E # drumParams (Part 1)
  ASS J11 = 0F # drumParams (Part 2)
  ASS J12 = 10 # drumParams (Part 1+2)
  ASS J13 = 67 # drumParams (wg send) (103)
  ASS J20 = 00 00 00 00 00 00 00 00 00 00 # arp values (J10 J11 J12 J13 J14 J15 J16 J17 J18 J19)
  ASS J2A = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # phrase sequence (J2A J2B J2C J2D J2E J2F J30 J31 J32 J33 J34 J35 J36 J37 J38 J39 ETC.)
  # TEST
  LOG RESET_SYSEX_RECEIVED
  # END TEST
END

# end sysex reception

# if this channel is currently allowing input
# TODO review ordering here - could possibly be rearranged - will need to be if channels are split up as expected
IF currentChannel == 0
  # if message is clock
  IF M0 == F8
    # if gate is open (numPressed is greater than zero)
    IF numPressed > 0
      # if arpPhraseOnOffToggle is on
      IF arpPhraseOnOffToggle == 1
        # process midi clock
        # maxVal = (floor of (ffff / lcm of all possible tempoPulse)) * lcm of all possible tempoPulse
        IF clockNum == maxValClockNum
          ASS clockNum = 0
          # TEST
          LOG clockNum_RESET
          # END TEST
        END
        # TEST
        # ensure maxValClockNum mod any possible tempoPulse is equal to 0 mod the same tempoPulse
        MATH tempVar1 = maxValClockNum % tempoPulse
        MATH tempVar2 = 0 % tempoPulse
        IF tempVar1 == tempVar2
          LOG maxValClockNum_GOOD
        ELSE
          LOG maxValClockNum_BAD
        END
        # END TEST
        IF gateOpened == 1
          ASS clockNum = 0 # NOTE might need to be reconfigured if clock signal is too fast for processing, as this may reset clock inadvertantly
          # TEST
          # uncomment to check that maxValClockNum is set correctly
          # ASS clockNum = FF48
          # END TEST
          # TEST
          # ensure gateOpened resets clockNum
          LOG clockNum_AFTER_gateOpened_RESET clockNum
          # END TEST
        END
        # TEST
        LOG clockNum_BEFORE clockNum
        # END TEST
        MATH clockNumMod = clockNum % tempoPulse
        # TEST
        LOG clockNumMod_BEFORE clockNumMod
        # END TEST
        # if clockNum modulo the number set from above is zero, allow clock
        IF clockNumMod == 0
          # TEST
          # ensure notes are processed if clockNumMod is zero
          LOG clockNumMod_ZERO
          # END TEST
          # if isArp
          IF arpPhraseToggle == 0
            # TEST
            # ensure arp only goes to arp
            LOG IS_ARP
            # END TEST
            # if value mode is 0 (asc 1)
            IF arpValueModeMod == 0
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                MATH arpIndex = numPressed + arpOffset
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # TEST TRY
              # NOTE only in modes that use octaves
              # NOTE this might actually make sequence inconsistent between octaves and no octaves - would almost rather save locally
              # NOTE could use local array to save arp and reset save on every completion
              #IF gateOpened == 2
              #  MATH arpIndex = arpIndex + 1
              #  ASS gateOpened = 0
              #  # TEST
              #  # ensure gateOpened resets arpIndex
              #  LOG arpIndex_AFTER_gateOpened_MINUS_ONE arpIndex
              #  # END TEST
              #END
              # END TEST TRY
              # arpIndex will initially be set to numPressed + 32, but after it's set to numPressed + 32 - 1, it will be automatically decreased each run through
              # this decrease stops once we go under 32 - at that point it's reset
              MATH arpIndex = arpIndex - 1
              IF arpIndex == 1F
                MATH arpIndex = numPressed + arpOffset
                # NOTE need to subtract one here because subtraction always needs to occur after reset
                MATH arpIndex = arpIndex - 1
              END
              # TEST
              LOG numPressed numPressed
              LOG arpIndex arpIndex
              # END TEST
              SEND 90 JI2 velocity
              SEND 80 JI2 velocity +DG7
            END
            # if value mode is 1 (asc 2)
            IF arpValueModeMod == 1
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                MATH arpIndex = numPressed + arpOffset
                ASS isOctave = 0
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # TEST
              # ensure isOctave is cycling through correctly
              LOG isOctave isOctave
              # END TEST
              # if not isOctave, business as usual
              IF isOctave == 0
                MATH arpIndex = arpIndex - 1
                IF arpIndex == 1F
                  MATH arpIndex = numPressed + arpOffset
                  # NOTE need to subtract one here because subtraction always needs to occur after reset
                  MATH arpIndex = arpIndex - 1
                END
                SEND 90 JI2 velocity
                SEND 80 JI2 velocity +DG7
                ASS isOctave = 1
              # if isOctave, add 12 semitones and send that instead
              ELSE
                MATH arpOctaveValue = JI2 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG7
                ASS isOctave = 0
              END
            END
            # if value mode is 2 (asc 3)
            IF arpValueModeMod == 2
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                MATH arpIndex = numPressed + arpOffset
                ASS isOctave = 0
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # TEST
              # ensure isOctave is cycling through correctly
              LOG isOctave isOctave
              # END TEST
              MATH isOctaveMod = isOctave % 3
              # if isOctaveMod is 0, business as usual
              IF isOctaveMod == 0
                MATH arpIndex = arpIndex - 1
                IF arpIndex == 1F
                  MATH arpIndex = numPressed + arpOffset
                  # NOTE need to subtract one here because subtraction always needs to occur after reset
                  MATH arpIndex = arpIndex - 1
                END
                SEND 90 JI2 velocity
                SEND 80 JI2 velocity +DG7
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 1, add 12 semitones and send that instead
              IF isOctaveMod == 1
                MATH arpOctaveValue = JI2 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG7
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 2, add 24 semitones and send that instead
              IF isOctaveMod == 2
                MATH arpOctaveValue = JI2 + $24 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG7
                MATH isOctave = isOctave + 1
              END
            END
            # if value mode is 3 (desc 1)
            IF arpValueModeMod == 3
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                ASS arpIndex = 1F
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # arpIndex will initially be set to 31, but after it's set to 32, it will be automatically increased each run through
              # this increase stops once we go over numPressed - at that point it's reset
              MATH arpIndex = arpIndex + 1
              MATH numPressedOffset = numPressed + arpOffset
              IF arpIndex >= numPressedOffset
                ASS arpIndex = 1F
                # NOTE need to add one here because subtraction always needs to occur after reset
                MATH arpIndex = arpIndex + 1
              END
              SEND 90 JI2 velocity
              SEND 80 JI2 velocity +DG7
            END
            # if value mode is 4 (desc 2)
            IF arpValueModeMod == 4
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                ASS arpIndex = 1F
                ASS isOctave = 0
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # TEST
              # ensure isOctave is cycling through correctly
              LOG isOctave isOctave
              # END TEST
              # if not isOctave, business as usual
              IF isOctave == 0
                MATH arpIndex = arpIndex + 1
                MATH numPressedOffset = numPressed + arpOffset
                IF arpIndex >= numPressedOffset
                  ASS arpIndex = 1F
                  # NOTE need to add one here because subtraction always needs to occur after reset
                  MATH arpIndex = arpIndex + 1
                END
                SEND 90 JI2 velocity
                SEND 80 JI2 velocity +DG7
                ASS isOctave = 1
              # if isOctave, add 12 semitones and send that instead
              ELSE
                MATH arpOctaveValue = JI2 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG7
                ASS isOctave = 0
              END
            END
            # if value mode is 5 (desc 3)
            IF arpValueModeMod == 5
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                ASS arpIndex = 1F
                ASS isOctave = 0
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # TEST
              # ensure isOctave is cycling through correctly
              LOG isOctave isOctave
              # END TEST
              MATH isOctaveMod = isOctave % 3
              # if isOctaveMod is 0, business as usual
              IF isOctaveMod == 0
                MATH arpIndex = arpIndex + 1
                MATH numPressedOffset = numPressed + arpOffset
                IF arpIndex >= numPressedOffset
                  ASS arpIndex = 1F
                  # NOTE need to add one here because subtraction always needs to occur after reset
                  MATH arpIndex = arpIndex + 1
                END
                SEND 90 JI2 velocity
                SEND 80 JI2 velocity +DG7
                ASS isOctave = 1
              END
              # if isOctaveMod is 1, add 12 semitones and send that instead
              IF isOctaveMod == 1
                MATH arpOctaveValue = JI2 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG7
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 2, add 24 semitones and send that instead
              IF isOctaveMod == 2
                MATH arpOctaveValue = JI2 + $24 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG7
                MATH isOctave = isOctave + 1
              END
              # NOTE could use if else here, have chosen not to because I think this is more readable
              # NOTE also might be able to multiply isOctaveMod by 12, add, and always send arpOctaveValue
              # NOTE could make this a subroutine
            END
            # if value mode is 6 (rand 1)
            IF arpValueModeMod == 6
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              MATH arpIndex = RFF % numPressed
              # TEST
              # ensure random is random
              LOG arpIndex_RANDOM arpIndex
              # END TEST
              MATH arpIndex = arpIndex + arpOffset
              SEND 90 JI2 velocity
              SEND 80 JI2 velocity +DG7
            END
            # if value mode is 7 (rand 2)
            IF arpValueModeMod == 7
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # NOTE this is completely random - thus ignoring the note played before it - the octave will not necessarily match up with previous note
              MATH arpIndex = RFF % numPressed
              MATH isOctaveMod = RFF % 2
              # TEST
              # ensure random is random
              LOG arpIndex_RANDOM arpIndex
              LOG isOctave_RANDOM isOctaveMod
              # END TEST
              MATH arpIndex = arpIndex + arpOffset
              # if not isOctaveMod, business as usual
              IF isOctaveMod == 0
                SEND 90 JI2 velocity
                SEND 80 JI2 velocity +DG7
              # if isOctaveMod, add 12 semitones and send that instead
              ELSE
                MATH arpOctaveValue = JI2 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG7
              END
            END
            # if value mode is 8 (rand 3)
            IF arpValueModeMod == 8
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              MATH arpIndex = RFF % numPressed
              MATH isOctaveMod = RFF % 3
              # TEST
              # ensure random is random
              LOG arpIndex_RANDOM arpIndex
              LOG isOctave_RANDOM isOctaveMod
              # END TEST
              MATH arpIndex = arpIndex + arpOffset
              # if isOctaveMod is 0, business as usual
              IF isOctaveMod == 0
                SEND 90 JI2 velocity
                SEND 80 JI2 velocity +DG7
              END
              # if isOctaveMod is 1, add 12 semitones and send that instead
              IF isOctaveMod == 1
                MATH arpOctaveValue = JI2 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG7
              END
              # if isOctaveMod is 2, add 24 semitones and send that instead
              IF isOctaveMod == 2
                MATH arpOctaveValue = JI2 + $24 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG7
              END
            END
            # NOTE this currently appears the same as the general asc - this is because the way they are sorted will be the same
            # if value mode is 9 (order 1)
            IF arpValueModeMod == 9
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              IF gateOpened == 1
                MATH arpIndex = numPressed + arpOffset
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # arpIndex will initially be set to numPressed + 32, but after it's set to numPressed + 32 - 1, it will be automatically decreased each run through
              # this decrease stops once we go under 32 - at that point it's reset
              MATH arpIndex = arpIndex - 1
              IF arpIndex == 1F
                MATH arpIndex = numPressed + arpOffset
                # NOTE need to subtract one here because subtraction always needs to occur after reset
                MATH arpIndex = arpIndex - 1
              END
              SEND 90 JI2 velocity
              SEND 80 JI2 velocity +DG7
            END
            # if value mode is 10 (order 2)
            IF arpValueModeMod == A
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                MATH arpIndex = numPressed + arpOffset
                ASS isOctave = 0
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # TEST
              # ensure isOctave is cycling through correctly
              LOG isOctave isOctave
              # END TEST
              # if not isOctave, business as usual
              IF isOctave == 0
                MATH arpIndex = arpIndex - 1
                IF arpIndex == 1F
                  MATH arpIndex = numPressed + arpOffset
                  # NOTE need to subtract one here because subtraction always needs to occur after reset
                  MATH arpIndex = arpIndex - 1
                END
                SEND 90 JI2 velocity
                SEND 80 JI2 velocity +DG7
                ASS isOctave = 1
              # if isOctave, add 12 semitones and send that instead
              ELSE
                MATH arpOctaveValue = JI2 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG7
                ASS isOctave = 0
              END
            END
            # if value mode is 11 (order 3)
            IF arpValueModeMod == B
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                MATH arpIndex = numPressed + arpOffset
                ASS isOctave = 0
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # TEST
              # ensure isOctave is cycling through correctly
              LOG isOctave isOctave
              # END TEST
              MATH isOctaveMod = isOctave % 3
              # if isOctaveMod is 0, business as usual
              IF isOctaveMod == 0
                MATH arpIndex = arpIndex - 1
                IF arpIndex == 1F
                  MATH arpIndex = numPressed + arpOffset
                  # NOTE need to subtract one here because subtraction always needs to occur after reset
                  MATH arpIndex = arpIndex - 1
                END
                SEND 90 JI2 velocity
                SEND 80 JI2 velocity +DG7
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 1, add 12 semitones and send that instead
              IF isOctaveMod == 1
                MATH arpOctaveValue = JI2 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG7
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 2, add 24 semitones and send that instead
              IF isOctaveMod == 2
                MATH arpOctaveValue = JI2 + $24 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG7
                MATH isOctave = isOctave + 1
              END
            END
          # else isPhrase
          # because we need the phrase to be relative, we'll need the global array to contain offset, not note value
          # offset will be used in conjunction with note in, also stored in the global array
          # additionally, -1 implies a rest, so nothing will be played
          ELSE
            # TEST
            # ensure phrase only goes to phrase
            LOG IS_PHRASE
            # END TEST
            # if gateOpened, or if first instance of clock since first key was pressed
            IF gateOpened == 1
              ASS phraseIndex = 2A
              ASS gateOpened = 0
              # TEST
              # ensure gateOpened resets phraseIndex
              LOG phraseIndex_AFTER_gateOpened_RESET phraseIndex
              # END TEST
            END
            # if phrase offset is not a rest
            IF JI7 != 2E57
              MATH phraseValSend = phraseVal + GI7
              # TEST
              # ensure correct offset is sending
              LOG phraseVal_OFFSET GI7
              # END TEST
              SEND 90 phraseValSend velocity
              SEND 80 phraseValSend velocity +DG7
            END
            # TEST
            # ensure rest functionality is working
            IF JI7 == 2E57
              LOG IS_REST
            END
            # END TEST
            IF phraseIndex != phraseLengthPlusOffset
              MATH phraseIndex = phraseIndex + 1
            ELSE
              ASS phraseIndex = 2A
              # TEST
              # ensure phraseIndex is reset at the end of the phrase
              LOG phraseIndex_RESET
              # END TEST
            END
          END
          F8 = XX +B
        ELSE
          XX = XX +B
        END
        MATH clockNum = clockNum + 1
        # TEST
        LOG clockNum_AFTER clockNum
        # END TEST
      ELSE
        XX = XX +B
      END
    ELSE
      XX = XX +B
    END
  ELSE
    XX = XX +B
  END
ELSE
  XX = XX +B
END
