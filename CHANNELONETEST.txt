# channel one test code

# TEST NOTES









# channel one

# this instance will constantly be receiving clock, the question will be whether it responds to it or not
# there will be another service receiving note in - if arpPhraseOnOffToggle is on, notes will be processed, otherwise, they will not

# note that the assumption here is that the global array information will be used, not the local array
# the local array will just be used for storage

# possible future updates - addings 'reverse' and 'bounce' for phrase (stochastic etc. whatever)

# need to reassign arpIndex whenever mode is changed

# NOTE maxVal for clockNum is based off 227 * 288 = floor(65,535 / 288) * (ffff / lcm of all possible tempoPulse)

# arpTypes
# 1: ascending one octave
# 2: ascending two octave
# 3: ascending three octave
# 4: descending one octave
# 5: descending two octave
# 6: descending three octave
# 7: random one octave
# 8: random two octave
# 9: random three octave
# 10: order pressed one octave
# 11: order pressed two octave
# 12: order pressed three octave

IF LOAD

  # constant
  ALIAS FF60 MaxValClockNum
  ALIAS 00 thisChannel
  ALIAS 20 arpOffset

  # local
  # TODO remove below and update
  ALIAS I0 maxValClockNum
  ALIAS I1 clockNum
  ALIAS I2 clockNumMod
  ALIAS I3 arpIndex
  ALIAS I4 isOctave
  ALIAS I5 isOctaveMod
  ALIAS I6 arpOctaveValue
  ALIAS I7 phraseValSend
  # NOTE this phraseIndex is the playing index, not the setting index
  ALIAS I8 phraseIndex

  # global
  ALIAS G0 channel
  ALIAS G1 numPressed
  ALIAS G2 arpPhraseToggle
  ALIAS G3 arpPhraseOnOffToggle
  ALIAS G5 tempoPulse
  ALIAS G6 gate
  ALIAS G7 arpValueModeMod
  ALIAS GE gateOpened
  ALIAS GF phraseVal
  ALIAS G10 phraseLengthPlusOffset
  ALIAS G11 velocity

  # assign local
  ASS maxValClockNum = FF60
  # TEST
  # assign clockNum close to maxVal
  # END TEST
  ASS clockNum = 0
  ASS isOctave = 0

  # TEST
  ALIAS L0 tempVar1
  ALIAS L1 tempVar2
  # END TEST
END

# SEND F0 C4 MC G0 F7 +F
#IF M0 == F0 C4
#  IF M2 == thisChannel
#    # delay?
#    # load velocity from local
#    # update channel
#    # NOTE race condition
#    # NOTE other data will need to be stored locally for latch
#  ELSE
#    IF M3 == thisChannel
#      # NOTE save other data for latch
#    END
#  END
#END

# NOTE above should not matter without latch, since clock is only considered when channel is this file's channel


# if channel is this channel (one)
IF channel == 0
  # if message is clock
  IF M0 == F8
    # if gate is open (numPressed is greater than zero)
    IF numPressed > 0
      # if arpPhraseOnOffToggle is on
      IF arpPhraseOnOffToggle == 1
        # process midi clock
        # maxVal = (floor of (ffff / lcm of all possible tempoPulse)) * lcm of all possible tempoPulse
        IF clockNum == maxValClockNum
          ASS clockNum = 0
        END
        # TEST
        # ensure maxValClockNum mod any possible tempoPulse is equal to 0 mod the same tempoPulse
        MATH tempVar1 = maxValClockNum % tempoPulse
        MATH tempVar2 = 0 % tempoPulse
        IF tempVar1 == tempVar2
          LOG maxValClockNum_GOOD
        ELSE
          LOG maxValClockNum_BAD
        END
        # END TEST
        IF gateOpened = 1
          ASS clockNum = 0 # NOTE might need to be reconfigured if clock signal is too fast for processing, as this may reset clock inadvertantly
          # TEST
          # ensure gateOpened resets clockNum
          LOG clockNum_AFTER_gateOpened_RESET clockNum
          # END TEST
        END
        MATH clockNumMod = clockNum % tempoPulse
        # if clockNum modulo the number set from above is zero, allow clock
        IF clockNumMod == 0
          # TEST
          # ensure notes are processed if clockNumMod is zero
          LOG clockNumMod_ZERO
          # END TEST
          # if isArp
          IF arpPhraseToggle == 0
            # TEST
            # ensure arp only goes to arp
            LOG IS_ARP
            # END TEST
            # if value mode is 0 (asc 1)
            IF arpValueModeMod == 0
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                MATH arpIndex = numPressed + arpOffset
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # arpIndex will initially be set to numPressed + 32, but after it's set to numPressed + 32 - 1, it will be automatically decreased each run through
              # this decrease stops once we go under 32 - at that point it's reset
              MATH arpIndex = arpIndex - 1
              IF arpIndex == 1F
                MATH arpIndex = numPressed + arpOffset
              END
              SEND 90 GI3 velocity
              SEND 80 GI3 velocity +DG6
            END
            # if value mode is 1 (asc 2)
            IF arpValueModeMod == 1
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                MATH arpIndex = numPressed + arpOffset
                ASS isOctave = 0
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # TEST
              # ensure isOctave is cycling through correctly
              LOG isOctave isOctave
              # END TEST
              # if not isOctave, business as usual
              IF isOctave == 0
                MATH arpIndex = arpIndex - 1
                IF arpIndex == 1F
                  ASS arpIndex = numPressed + arpOffset
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                ASS isOctave = 1
              # if isOctave, add 12 semitones and send that instead
              ELSE
                MATH arpOctaveValue = GI3 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                ASS isOctave = 0
              END
            END
            # if value mode is 2 (asc 3)
            IF arpValueModeMod == 2
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                MATH arpIndex = numPressed + arpOffset
                ASS isOctave = 0
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # TEST
              # ensure isOctave is cycling through correctly
              LOG isOctave isOctave
              # END TEST
              MATH isOctaveMod = isOctave % 3
              # if isOctaveMod is 0, business as usual
              IF isOctaveMod == 0
                MATH arpIndex = arpIndex - 1
                IF arpIndex == 1F
                  MATH arpIndex = numPressed + arpOffset
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 1, add 12 semitones and send that instead
              IF isOctaveMod == 1
                MATH arpOctaveValue = GI3 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 2, add 24 semitones and send that instead
              IF isOctaveMod == 2
                MATH arpOctaveValue = GI3 + $24 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
            END
            # if value mode is 3 (desc 1)
            IF arpValueModeMod == 3
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                ASS arpIndex = 1F
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # arpIndex will initially be set to 31, but after it's set to 32, it will be automatically increased each run through
              # this increase stops once we go over numPressed - at that point it's reset
              MATH arpIndex = arpIndex + 1
              MATH numPressedOffset = numPressed + arpOffset
              IF arpIndex >= numPressedOffset
                ASS arpIndex = 1F
              END
              SEND 90 GI3 velocity
              SEND 80 GI3 velocity +DG6
            END
            # if value mode is 4 (desc 2)
            IF arpValueModeMod == 4
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                ASS arpIndex = 1F
                ASS isOctave = 0
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # TEST
              # ensure isOctave is cycling through correctly
              LOG isOctave isOctave
              # END TEST
              # if not isOctave, business as usual
              IF isOctave == 0
                MATH arpIndex = arpIndex + 1
                MATH numPressedOffset = numPressed + arpOffset
                IF arpIndex >= numPressedOffset
                  ASS arpIndex = 1F
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                ASS isOctave = 1
              # if isOctave, add 12 semitones and send that instead
              ELSE
                MATH arpOctaveValue = GI3 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                ASS isOctave = 0
              END
            END
            # if value mode is 5 (desc 3)
            IF arpValueModeMod == 5
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                ASS arpIndex = 1F
                ASS isOctave = 0
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # TEST
              # ensure isOctave is cycling through correctly
              LOG isOctave isOctave
              # END TEST
              MATH isOctaveMod = isOctave % 3
              # if isOctaveMod is 0, business as usual
              IF isOctaveMod == 0
                MATH arpIndex = arpIndex + 1
                MATH numPressedOffset = numPressed + arpOffset
                IF arpIndex >= numPressedOffset
                  ASS arpIndex = 1F
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                ASS isOctave = 1
              END
              # if isOctaveMod is 1, add 12 semitones and send that instead
              IF isOctaveMod == 1
                MATH arpOctaveValue = GI3 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 2, add 24 semitones and send that instead
              IF isOctaveMod == 2
                MATH arpOctaveValue = GI3 + $24 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # NOTE could use if else here, have chosen not to because I think this is more readable
              # NOTE also might be able to multiply isOctaveMod by 12, add, and always send arpOctaveValue
              # NOTE could make this a subroutine
            END
            # if value mode is 6 (rand 1)
            IF arpValueModeMod == 6
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              MATH arpIndex = RFF % numPressed
              # TEST
              # ensure random is random
              LOG arpIndex_RANDOM arpIndex
              # END TEST
              MATH arpIndex = arpIndex + arpOffset
              SEND 90 GI3 velocity
              SEND 80 GI3 velocity +DG6
            END
            # if value mode is 7 (rand 2)
            IF arpValueModeMod == 7
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # NOTE this is completely random - thus ignoring the note played before it - the octave will not necessarily match up with previous note
              MATH arpIndex = RFF % numPressed
              MATH isOctaveMod = RFF % 2
              # TEST
              # ensure random is random
              LOG arpIndex_RANDOM arpIndex
              LOG isOctave_RANDOM isOctave
              # END TEST
              MATH arpIndex = arpIndex + arpOffset
              # if not isOctaveMod, business as usual
              IF isOctaveMod == 0
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
              # if isOctaveMod, add 12 semitones and send that instead
              ELSE
                MATH arpOctaveValue = GI3 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
              END
            END
            # if value mode is 8 (rand 3)
            IF arpValueModeMod == 8
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              MATH arpIndex = RFF % numPressed
              MATH isOctaveMod = RFF % 3
              # TEST
              # ensure random is random
              LOG arpIndex_RANDOM arpIndex
              LOG isOctave_RANDOM isOctave
              # END TEST
              MATH arpIndex = arpIndex + arpOffset
              # if isOctaveMod is 0, business as usual
              IF isOctave == 0
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
              END
              # if isOctaveMod is 1, add 12 semitones and send that instead
              IF isOctave == 1
                MATH arpOctaveValue = GI3 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
              END
              # if isOctaveMod is 2, add 24 semitones and send that instead
              IF isOctave == 2
                MATH arpOctaveValue = GI3 + $24 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
              END
            END
            # NOTE this currently appears the same as the general asc - this is because the way they are sorted will be the same
            # if value mode is 9 (order 1)
            IF arpValueModeMod == 9
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              IF gateOpened == 1
                MATH arpIndex = numPressed + arpOffset
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # arpIndex will initially be set to numPressed + 32, but after it's set to numPressed + 32 - 1, it will be automatically decreased each run through
              # this decrease stops once we go under 32 - at that point it's reset
              MATH arpIndex = arpIndex - 1
              IF arpIndex == 1F
                MATH arpIndex = numPressed + arpOffset
              END
              SEND 90 GI3 velocity
              SEND 80 GI3 velocity +DG6
            END
            # if value mode is 10 (order 2)
            IF arpValueModeMod == A
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                MATH arpIndex = numPressed + arpOffset
                ASS isOctave = 0
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # TEST
              # ensure isOctave is cycling through correctly
              LOG isOctave isOctave
              # END TEST
              # if not isOctave, business as usual
              IF isOctave == 0
                MATH arpIndex = arpIndex - 1
                IF arpIndex == 1F
                  MATH arpIndex = numPressed + arpOffset
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                ASS isOctave = 1
              # if isOctave, add 12 semitones and send that instead
              ELSE
                MATH arpOctaveValue = GI3 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                ASS isOctave = 0
              END
            END
            # if value mode is 11 (order 3)
            IF arpValueModeMod == B
              # TEST
              # ensure arpValueMode is correct
              LOG arpValueMode arpValueModeMod
              # END TEST
              # if gateOpened, or if first instance of clock since first key was pressed
              IF gateOpened == 1
                MATH arpIndex = numPressed + arpOffset
                ASS isOctave = 0
                ASS gateOpened = 0
                # TEST
                # ensure gateOpened resets arpIndex
                LOG arpIndex_AFTER_gateOpened_RESET arpIndex
                # END TEST
              END
              # TEST
              # ensure isOctave is cycling through correctly
              LOG isOctave isOctave
              # END TEST
              MATH isOctaveMod = isOctave % 3
              # if isOctaveMod is 0, business as usual
              IF isOctaveMod == 0
                MATH arpIndex = arpIndex - 1
                IF arpIndex == 1F
                  MATH arpIndex = numPressed + arpOffset
                END
                SEND 90 GI3 velocity
                SEND 80 GI3 velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 1, add 12 semitones and send that instead
              IF isOctaveMod == 1
                MATH arpOctaveValue = GI3 + $12 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
              # if isOctaveMod is 2, add 24 semitones and send that instead
              IF isOctaveMod == 2
                MATH arpOctaveValue = GI3 + $24 # NOTE see if this should be -12 or +12
                SEND 90 arpOctaveValue velocity
                SEND 80 arpOctaveValue velocity +DG6
                MATH isOctave = isOctave + 1
              END
            END
          # else isPhrase
          # because we need the phrase to be relative, we'll need the global array to contain offset, not note value
          # offset will be used in conjunction with note in, also stored in the global array
          # additionally, -1 implies a rest, so nothing will be played
          ELSE
            # TEST
            # ensure phrase only goes to phrase
            LOG IS_PHRASE
            # END TEST
            # if gateOpened, or if first instance of clock since first key was pressed
            IF gateOpened == 1
              MATH phraseIndex = 2A
              ASS gateOpened = 0
              # TEST
              # ensure gateOpened resets phraseIndex
              LOG phraseIndex_AFTER_gateOpened_RESET phraseIndex
              # END TEST
            END
            # if phrase offset is not a rest
            IF GI8 != 2E57
              MATH phraseValSend = phraseVal + GI8
              # TEST
              # ensure correct offset is sending 
              LOG phraseVal_OFFSET GI8
              # END TEST
              SEND 90 phraseValSend velocity
              SEND 80 phraseValSend velocity +DG6
            END
            # TEST
            # ensure rest functionality is working
            IF GI8 == 2E57
              LOG IS_REST
            END
            # END TEST
            IF phraseIndex != phraseLengthPlusOffset
              MATH phraseIndex = phraseIndex + 1
            ELSE
              ASS phraseIndex = 2A
              # TEST
              # ensure phraseIndex is reset at the end of the phrase
              LOG phraseIndex_RESET
              # END TEST
            END
          END
        ELSE
          XX = XX +B
        END
        MATH clockNum = clockNum + 1
      ELSE
        XX = XX +B
      END
    ELSE
      XX = XX +B 
    END
  ELSE
    XX = XX +B
  END
ELSE
  XX = XX +B
END
