# launchkey mini test code

# TEST NOTES










# launchkey mini (mk2)

# this will feed data into each channel file and will be toggled by xtouch
# if phrase and arp are off, notes will be passed through as expected

SUBROUTINE INSERTION_SORT isOrder length
  ALIAS I10 i
  ALIAS I11 j
  ALIAS I12 jPlusOne
  ALIAS I13 keyVal
  ALIAS I14 keyBool
  ALIAS I15 isSetSort
  ALIAS I16 lengthOffset

  MATH lengthOffset = length + 20

  IF isOrder == 1
    ASS i = 21
    WHILE i < lengthOffset
      ASS keyVal = II10
      ASS keyBool = JI10
      MATH j = i - 1
      MATH jPlusOne = j + 1
      ASS isSetSort = 0
      IF j >= 20
        IF II11 < keyVal
          ASS isSetSort = 1
        END
      END
      WHILE isSetSort == 1
        ASS II12 = II11
        ASS JI12 = JI11
        MATH j = j - 1
        MATH jPlusOne = j + 1
        ASS isSetSort = 0
        IF j >= 20
          IF II11 < keyVal
            ASS isSetSort = 1
          END
        END
      END
      ASS II12 = keyVal
      ASS JI12 = keyBool
      MATH i = i + 1
    END
  ELSE
    ASS i = 21
    WHILE i < lengthOffset
      ASS keyVal = JI10
      ASS keyBool = II10
      MATH j = i - 1
      MATH jPlusOne = j + 1
      ASS isSetSort = 0
      IF j >= 20
        IF JI11 < keyVal
          ASS isSetSort = 1
        END
      END
      WHILE isSetSort == 1
        ASS JI12 = JI11
        ASS II12 = II11
        MATH j = j - 1
        MATH jPlusOne = j + 1
        ASS isSetSort = 0
        IF j >= 20
          IF JI11 < keyVal
            ASS isSetSort = 1
          END
        END
      END
      ASS JI12 = keyVal
      ASS II12 = keyBool
      MATH i = i + 1
    END
  END
END

# J is the local storage array (database)
# TODO implement button reset

IF LOAD

  # setup init - comment out if there is a need to save global information between sessions
  # reset global array
  # TODO IF keypressed here? can that prevent extra work?

  ASS J0 = 00 # currentChannel
  ASS J1 = 00 # numPressed
  ASS J2 = 00 # arpPhraseToggle
  ASS J3 = 00 # arpPhraseOnOffToggle
  ASS J4 = 00 # tempoModeMod
  ASS J5 = 24 # tempoPulse
  ASS J6 = 00 # gateModeMod
  ASS J7 = 00 # gate
  ASS J8 = 64 # velocity
  ASS J9 = 00 # arpValueModeMod
  ASS JA = 00 # setPhrase
  ASS JB = 00 # phraseVal
  ASS JC = 2A # phraseindex
  ASS JD = 2A # phraseLengthPlusOffset
  ASS JE = 00 # gateOpened
  ASS JF = 00 # waveguideToggle
  ASS J10 = 0E # drumParams (Part 1)
  ASS J11 = 0F # drumParams (Part 2)
  ASS J12 = 10 # drumParams (Part 1+2)
  ASS J13 = 67 # drumParams (wg send) (103)
  ASS J14 = 00 # isLatch
  ASS J20 = 00 00 00 00 00 00 00 00 00 00 # arp values (J10 J11 J12 J13 J14 J15 J16 J17 J18 J19)
  ASS J2A = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # phrase sequence (J2A J2B J2C J2D J2E J2F J30 J31 J32 J33 J34 J35 J36 J37 J38 J39 ETC.)
  # TEST
  # ensure global array reset
  ASS LFF = 0
  WHILE LFF < 48
    LOG J_INDEX LFF
    LOG LFF JLFF
    MATH LFF = LFF + 1
  END
  # END TEST

  # reset xtouch lighting and params
  SEND F0 FF FF 00 00 F7 +F
  # TEST
  # ensure xtouch reset
  LOG XTOUCH_RESET
  # END TEST

  # full setup init - comment out if there is a need to save channel information between sessions
  # reset channel information
  SEND F0 CC FF 00 00 F7 +F
  # TEST
  # ensure channel information reset (will need to be done on individual files)
  LOG CHANNELS_RESET
  # END TEST

  # global variable
  ALIAS G0 currentChannel

  # end init

  # constant

  ALIAS 20 arpIndexOffset
  ALIAS 30 latchIndexOffset
  ALIAS 64 latchInterval

  # local
  ALIAS I0 iter
  ALIAS I1 isSet
  ALIAS I2 arpIndex
  ALIAS I3 numPressedTotal
  ALIAS I4 max
  ALIAS I5 maxIndex
  ALIAS I6 secondMax
  ALIAS I7 secondMaxIndex
  ALIAS I8 tempPhraseVal
  ALIAS I9 resetArp
  ALIAS IA resetPhrase
  ALIAS I17 phraseTemp # TODO
  ALIAS I18 isFirst # TODO
  ALIAS I19 latchTiming # TODO
  ALIAS I1A latchIndex
  # NOTE I10 - I16 taken by insertion sort above, I20 - I29 taken as numPressed order for arp, I30 - I39 taken as latch values

  # global
  ALIAS J1 numPressed
  ALIAS J2 arpPhraseToggle
  ALIAS J3 arpPhraseOnOffToggle
  ALIAS J9 arpValueModeMod
  ALIAS JA setPhrase
  ALIAS JB phraseVal
  ALIAS JC phraseIndex
  ALIAS JD phraseLengthPlusOffset
  ALIAS JE gateOpened
  ALIAS J14 isLatch

  # assign local
  # NOTE technically K does not need to be reset here, since only L is parsed - doing so as good practice
  ASS I20 = 00 00 00 00 00 00 00 00 00 00
  ASS K1 = 00 00 00 00 00
  ASS L1 = 00 00 00 00 00

  ASS numPressedTotal = 0
  # needs to be set to a value too far for both negatives and positives to reach
  ASS tempPhraseVal = AAAA
  ASS resetArp = 0
  ASS resetPhrase = 0
  ASS isFirst = 0

END

# TODO fix this - can't make it global because then it can't be recorded - or would need to save channel when recording somehow
# filter xtouch into modstep?
IF isFirst == 0
  ASS currentChannel = MC
  ASS isFirst = 1
END

# sysex reception

IF M0 == F0

  IF M2 == 01
    ASS numPressed = M3
    # TEST
    # ensure launchkey receives numPressed
    LOG numPressed_SYSEX_RECEIVED J1
    # END TEST
    BLOCK
    EXIT
  END

  IF M2 == 02
    ASS arpPhraseToggle = M3
    # TEST
    # ensure launchkey receives arpPhraseToggle
    LOG arpPhraseToggle_SYSEX_RECEIVED J2
    # END TEST
    BLOCK
    EXIT
  END

  IF M2 == 03
    ASS arpPhraseOnOffToggle = M3
    # TEST
    # ensure launchkey receives arpPhraseOnOffToggle
    LOG arpPhraseOnOffToggle_SYSEX_RECEIVED J3
    # END TEST
    BLOCK
    EXIT
  END

  IF M2 == 09
    ASS arpValueModeMod = M3
    # TEST
    # ensure launchkey receives arpValueModeMod
    LOG arpValueModeMod_SYSEX_RECEIVED J9
    # END TEST
    BLOCK
    EXIT
  END

  IF M2 == 0A
    ASS setPhrase = M3
    # TEST
    # ensure launchkey receives setPhrase
    LOG setPhrase_SYSEX_RECEIVED JA
    # END TEST
    IF setPhrase == 0
      ASS phraseIndex = 2A
      ASS tempPhraseVal = AAAA
      FX = XX +B
      # TEST
      # ensure sysex resets phraseIndex when setPhrase is turned off
      LOG phraseIndex phraseIndex
      # END TEST
    END
    BLOCK
    EXIT
  END

  IF M2 == 0C
    ASS phraseIndex = M3
    # TEST
    # ensure launchkey receives phraseIndex
    LOG phraseIndex_SYSEX_RECEIVED JC
    # END TEST
    BLOCK
    EXIT
  END

  IF M2 == 14
    ASS isLatch = M3
    # TEST
    # ensure launchkey receives isLatch
    LOG isLatch_SYSEX_RECEIVED J14
    # END TEST
    BLOCK
    EXIT
  END
END

# end sysex reception

# TODO not currently functional
IF MT == B0
  IF M1 == 6B 00
    # TODO two buttons at once? triple tap? on release

    # NOTE will need to send lighting to xtouch for sure, but setting the global channel should be enough to change routing
    # SEND sysex here

    ASS currentChannel = MC

    NX = XX +B
  END
END

IF isLatch == 1
  IF MT == 90
    ASS latchTiming = T0
    IF latchTiming > latchInterval
      ASS iter = 30
      WHILE iter <= latchLength
        # send note release - injected because this is the only file that would process the note release
        SEND 80 II0 00 +I
        # remove from latchValues
        ASS II0 = 00
        MATH iter = iter + 1
      END
      ASS latchLength = 0
      ASS T0 = 0 # reset timer
    END
    ASS latchIndex = latchIndexOffset + latchLength
    ASS II1A = M1
    # TEST
    # ensure latchValues are storing correctly on note press
    # ensure latchValues are reset if timing between notes is >=.1 second
    # ensure latchValues are added to if timing between notes <.1 second
    LOG latchIndex latchIndex
    LOG latchValues
    LOG I30 I30
    LOG I31 I31
    LOG I32 I32
    LOG I33 I33
    LOG I34 I34
    LOG I35 I35
    LOG I36 I36
    LOG I37 I37
    LOG I38 I38
    LOG I39 I39
    # END TEST
    MATH latchLength = latchLength + 1
    # TEST
    LOG latchLength latchLength
    # END TEST
  END
  IF MT == 80
    # TEST
    # ensure note releases are blocked if latch is on
    LOG NOTE_RELEASE_BLOCKED
    # END TEST
    BLOCK
    EXIT
  END
END

# NOTE will need to set latchLength to 0 and latchValues to 0 on latch off

# if arp / phrase is on
IF arpPhraseOnOffToggle == 1
  # if arp / phrase is arp
  IF arpPhraseToggle == 0
    # if key is pressed
    IF MT == 90

      # if reset (key pressed limit exceeded), handle differently
      IF resetArp == 1
        MATH numPressed = numPressed + 1
        # SEND SYSEX
        SEND F0 CC 01 numPressed F7 +F
        # END SYSEX
        BLOCK
        EXIT
      END

      # setting arbitrary limit on number of keys pressed at a time to 10 (using 10 as comparator here because numPressed has not yet been increased)
      IF numPressed == A
        ASS J20 = 00 00 00 00 00 00 00 00 00 00
        # SEND SYSEX
        SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
        # END SYSEX
        ASS I20 = 00 00 00 00 00 00 00 00 00 00
        ASS resetArp = 1
        ASS numPressedTotal = 0
        # necessary so that numPressed does not go past zero by mistake, as we have not yet incremented for this key press
        MATH numPressed = numPressed + 1
        # SEND SYSEX
        SEND F0 CC 01 numPressed F7 +F
        # END SYSEX
        # TEST
        # ensure J array contains correct key values pressed on reset (0)
        # ensure I array contains correct order of keys pressed on reset (0)
        # ensure numPressed aligns with number of keys pressed on reset (0)
        # ensure numPressedTotal aligns with number of keys pressed total on reset (0)
        LOG isArp
        LOG J19 J19 # should always be 0, unless globalkey is updated
        LOG J20 J20
        LOG J21 J21
        LOG J22 J22
        LOG J23 J23
        LOG J24 J24
        LOG J25 J25
        LOG J26 J26
        LOG J27 J27
        LOG J28 J28
        LOG J29 J29
        LOG J2A J2A # should always be first value of phrase
        LOG ~~~~~~~~~~BREAK~~~~~~~~~~
        LOG I19 I19 # should always be 0
        LOG I20 I20
        LOG I21 I21
        LOG I22 I22
        LOG I23 I23
        LOG I24 I24
        LOG I25 I25
        LOG I26 I26
        LOG I27 I27
        LOG I28 I28
        LOG I29 I29
        LOG I2A I2A # should always be 0
        LOG ~~~~~~~~~~BREAK~~~~~~~~~~
        LOG numPressed numPressed
        LOG numPressedTotal numPressedTotal
        # END TEST
        BLOCK
        EXIT
      END

      # add one to notes overall pressed
      MATH numPressedTotal = numPressedTotal + 1

      # store note value in first open spot in array
      MATH arpIndex = arpIndexOffset + numPressed
      ASS JI2 = M1
      ASS II2 = numPressedTotal

      # add one to current notes pressed
      # NOTE this is done before sorting to make sure proper length is parsed
      MATH numPressed = numPressed + 1
      # SEND SYSEX
      SEND F0 CC 01 numPressed F7 +F
      # END SYSEX

      # sort array / hashmap according to ascending, descending, order pressed
      IF arpValueModeMod < 6
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod > 8
        INSERTION_SORT 1 numPressed
      END
      # SEND SYSEX
      SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
      # END SYSEX

      IF numPressed == 1
        ASS gateOpened = 1
        # SEND SYSEX
        SEND F0 CC 0E gateOpened F7 +F
        # END SYSEX
      END
      # TEST TRY
      #IF numPressed > 1
      #  ASS gateOpened = 2
      #END
      # END TEST TRY
      # TEST
      # ensure J array contains correct key values pressed on key press
      # ensure I array contains correct order of keys pressed on key press
      # ensure numPressed aligns with number of keys pressed on key press
      # ensure numPressedTotal aligns with number of keys pressed total on key press
      # ensure gateOpened aligns with number of keys pressed total on key press
      LOG isArp
      LOG J19 J19 # should always be 0, unless globalkey is updated
      LOG J20 J20
      LOG J21 J21
      LOG J22 J22
      LOG J23 J23
      LOG J24 J24
      LOG J25 J25
      LOG J26 J26
      LOG J27 J27
      LOG J28 J28
      LOG J29 J29
      LOG J2A J2A # should always be first value of phrase
      LOG ~~~~~~~~~~BREAK~~~~~~~~~~
      LOG I19 I19 # should always be 0
      LOG I20 I20
      LOG I21 I21
      LOG I22 I22
      LOG I23 I23
      LOG I24 I24
      LOG I25 I25
      LOG I26 I26
      LOG I27 I27
      LOG I28 I28
      LOG I29 I29
      LOG I2A I2A # should always be 0
      LOG ~~~~~~~~~~BREAK~~~~~~~~~~
      LOG numPressed numPressed
      LOG numPressedTotal numPressedTotal
      LOG gateOpened gateOpened
      # END TEST

      NX = XX +B

    END

    IF MT == 80

      # if reset (key pressed limit exceeded), handle differently
      IF resetArp == 1
        MATH numPressed = numPressed - 1
        # SEND SYSEX
        SEND F0 CC 01 numPressed F7 +F
        # END SYSEX
        IF numPressed == 0
          ASS resetArp = 0
        END
        BLOCK
        EXIT
      END

      # remove note value from array
      # decrease number of notes that need to be iterated through
      ASS iter = arpIndexOffset
      ASS isSet = 0
      WHILE isSet != 1
        # if iter is the note value, remove values
        IF JI0 == M1
          ASS JI0 = 0
          ASS II0 = 0
          ASS isSet = 1
        END
        MATH iter = iter + 1
        IF iter == numPressed
          ASS isSet = 1
        END
      END

      # sort array / hashmap according to ascending, descending, order pressed
      IF arpValueModeMod < 6
        INSERTION_SORT 0 numPressed
      END
      IF arpValueModeMod > 8
        INSERTION_SORT 1 numPressed
      END
      # SEND SYSEX
      SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
      # END SYSEX

      # subract one from current notes pressed
      # NOTE this is done after sorting to make sure any removed values are pushed out
      MATH numPressed = numPressed - 1
      # SEND SYSEX
      SEND F0 CC 01 numPressed F7 +F
      # END SYSEX
      IF numPressed == 0
        ASS J20 = 00 00 00 00 00 00 00 00 00 00
        # SEND SYSEX
        SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
        # END SYSEX
        ASS I20 = 00 00 00 00 00 00 00 00 00 00
        ASS numPressedTotal = 0
      END
      # TEST
      # ensure J array contains correct key values pressed on key release
      # ensure I array contains correct order of keys pressed on key release
      # ensure numPressed aligns with number of keys pressed on key release
      # ensure numPressedTotal aligns with number of keys pressed total on key release
      # ensure gateOpened aligns with number of keys pressed total on key release
      LOG isArp
      LOG J19 J19 # should always be 0, unless globalkey is updated
      LOG J20 J20
      LOG J21 J21
      LOG J22 J22
      LOG J23 J23
      LOG J24 J24
      LOG J25 J25
      LOG J26 J26
      LOG J27 J27
      LOG J28 J28
      LOG J29 J29
      LOG J2A J2A # should always be first value of phrase
      LOG ~~~~~~~~~~BREAK~~~~~~~~~~
      LOG I19 I19 # should always be 0
      LOG I20 I20
      LOG I21 I21
      LOG I22 I22
      LOG I23 I23
      LOG I24 I24
      LOG I25 I25
      LOG I26 I26
      LOG I27 I27
      LOG I28 I28
      LOG I29 I29
      LOG I2A I2A # should always be 0
      LOG ~~~~~~~~~~BREAK~~~~~~~~~~
      LOG numPressed numPressed
      LOG numPressedTotal numPressedTotal
      LOG gateOpened gateOpened
      # END TEST

      NX = XX +B

    END
  # else isPhrase
  ELSE
    # if key pressed
    IF MT == 90

      # ASS gateOpened = 1 # NOTE uncommenting this and adding sysex would restart phrase whenever key pressed

      # if reset (key pressed limit exceeded), handle differently
      IF resetPhrase == 1
        MATH numPressed = numPressed + 1
        # SEND SYSEX
        SEND F0 CC 01 numPressed F7 +F
        # END SYSEX
        BLOCK
        EXIT
      END

      # setting arbitrary limit on number of keys pressed at a time to 5
      IF numPressed == 5
        ASS L1 = 00 00 00 00 00
        ASS resetPhrase = 1
        ASS numPressedTotal = 0
        # necessary so that numPressed does not go past zero by mistake, as we have not yet incremented for this key press
        MATH numPressed = numPressed + 1
        # SEND SYSEX
        SEND F0 CC 01 numPressed F7 +F
        # END SYSEX
        # TEST
        # ensure K array contains correct key values pressed on reset (0)
        # ensure L array contains correct order of keys pressed on reset (0)
        # ensure numPressed aligns with number of keys pressed on reset (0)
        # ensure numPressedTotal aligns with number of keys pressed total on reset (0)
        LOG isPhrase
        LOG K0 K0 should always be zero
        LOG K1 K1
        LOG K2 K2
        LOG K3 K3
        LOG K4 K4
        LOG K5 K5
        LOG K6 K6 # should always be zero
        LOG ~~~~~~~~~~BREAK~~~~~~~~~~
        LOG L0 L0 # should always be zero
        LOG L1 L1
        LOG L2 L2
        LOG L3 L3
        LOG L4 L4
        LOG L5 L5
        LOG L6 L6 # should always be zero
        LOG ~~~~~~~~~~BREAK~~~~~~~~~~
        LOG numPressed numPressed
        LOG numPressedTotal numPressedTotal
        # END TEST
        BLOCK
        EXIT
      END

      # set initial note to calculate offset
      ASS phraseVal = M1
      # SEND SYSEX
      SEND F0 CC 0B phraseVal F7 +F
      # END SYSEX

      # add to number of keys pressed
      MATH numPressed = numPressed + 1
      # SEND SYSEX
      SEND F0 CC 01 numPressed F7 +F
      # END SYSEX
      MATH numPressedTotal = numPressedTotal + 1

      # we need to have a while loop here to account for the user pressing and releasing keys in different orders
      # say user presses A, B, C, then lifts up B
      # this sets numPressed to 2, but when another key is pressed it will overwrite C if we continue linearly
      ASS iter = 1
      ASS isSet = 0
      WHILE isSet != 1
        IF LI0 == 0
          # add note value into K - this array's indices will all be >= 1
          ASS KI0 = M1
          # add note index in L to show it is pressed - this array's indices will all be >= 1
          ASS LI0 = numPressedTotal
          ASS isSet = 1
        END
        MATH iter = iter + 1
      END

      IF numPressed == 1
        ASS gateOpened = 1
        # SEND SYSEX
        SEND F0 CC 0E gateOpened F7 +F
        # END SYSEX
      END
      # TEST
      # ensure K array contains correct key values pressed on key press
      # ensure L array contains correct order of keys pressed on key press
      # ensure numPressed aligns with number of keys pressed on key press
      # ensure numPressedTotal aligns with number of keys pressed total on key press
      # ensure gateOpened aligns with number of keys pressed total on key press
      LOG isPhrase
      LOG K0 K0 should always be zero
      LOG K1 K1
      LOG K2 K2
      LOG K3 K3
      LOG K4 K4
      LOG K5 K5
      LOG K6 K6 # should always be zero
      LOG ~~~~~~~~~~BREAK~~~~~~~~~~
      LOG L0 L0 # should always be zero
      LOG L1 L1
      LOG L2 L2
      LOG L3 L3
      LOG L4 L4
      LOG L5 L5
      LOG L6 L6 # should always be zero
      LOG ~~~~~~~~~~BREAK~~~~~~~~~~
      LOG numPressed numPressed
      LOG numPressedTotal numPressedTotal
      LOG gateOpened gateOpened
      LOG phraseVal phraseVal
      # END TEST

    END

    IF MT == 80

      # if reset (key pressed limit exceeded), handle differently
      IF resetPhrase == 1
        MATH numPressed = numPressed - 1
        # SEND SYSEX
        SEND F0 CC 01 numPressed F7 +F
        # END SYSEX
        IF numPressed == 0
          ASS resetPhrase = 0
        END
        BLOCK
        EXIT
      END

      # stop if no keys pressed
      MATH numPressed = numPressed - 1
      # SEND SYSEX
      SEND F0 CC 01 numPressed F7 +F
      # END SYSEX
      IF numPressed < 1
        ASS L1 = 00 00 00 00 00
        ASS numPressedTotal = 0
      END

      # find the max l value, or the most recent key pressed
      # if the k value, or note value of that max is M1, we need to change the phrase offset
      # while we are iterating, we need to set the l value of whichever key is released to zero so we can reuse that index
      ASS max = 0
      ASS secondMax = 0
      ASS iter = 1
      WHILE iter <= 5
        IF LI0 > max
          ASS secondMax = max
          ASS max = LI0
          ASS secondMaxIndex = maxIndex
          ASS maxIndex = iter
        ELSE
          IF LI0 > secondMax
            ASS secondMax = LI0
            ASS secondMaxIndex = iter
          END
        END
        IF KI0 == M1
          ASS LI0 = 0
        END
        MATH iter = iter + 1
      END
      IF KI5 == M1
        # set value equal to second most recent key pressed
        # ASS gateOpened = 1 # NOTE uncommenting this and sending sysex would restart phrase whenever key lifted
        ASS phraseVal = KI7
        # SEND SYSEX
        SEND F0 CC 0B phraseVal F7 +F
        # END SYSEX
      END
      # TEST
      # ensure K array contains correct key values pressed on key release
      # ensure L array contains correct order of keys pressed on key release
      # ensure numPressed aligns with number of keys pressed on key release
      # ensure numPressedTotal aligns with number of keys pressed total on key release
      # ensure gateOpened aligns with number of keys pressed total on key release
      LOG isPhrase
      LOG K0 K0 should always be zero
      LOG K1 K1
      LOG K2 K2
      LOG K3 K3
      LOG K4 K4
      LOG K5 K5
      LOG K6 K6 # should always be zero
      LOG ~~~~~~~~~~BREAK~~~~~~~~~~
      LOG L0 L0 # should always be zero
      LOG L1 L1
      LOG L2 L2
      LOG L3 L3
      LOG L4 L4
      LOG L5 L5
      LOG L6 L6 # should always be zero
      LOG ~~~~~~~~~~BREAK~~~~~~~~~~
      LOG numPressed numPressed
      LOG numPressedTotal numPressedTotal
      LOG gateOpened gateOpened
      LOG phraseVal phraseVal
      # END TEST
    END
    # only block notes if setPhrase is zero - if it's one, we need the next if statement to process the note
    IF setPhrase == 0
      NX = XX +B
    END
  END
END

IF setPhrase == 1
  IF MT == 90
    # because we're taking offset here, we need to record each step as the difference between it and the last step
    # if tempPhraseVal has a previous value (i.e. is not the first key pressed in the phrase)
    # NOTE max phrase length at this point is 32
    IF tempPhraseVal == AAAA
      ASS tempPhraseVal = M1
    END
    MATH JJC = M1 - tempPhraseVal
    MATH phraseTemp = JJC / 100
    # SEND SYSEX
    SEND F0 CC phraseIndex phraseTemp JJC F7 +F
    # END SYSEX
    ASS phraseLengthPlusOffset = phraseIndex
    # SEND SYSEX
    SEND F0 CC 0D phraseLengthPlusOffset F7 +F
    # END SYSEX
    MATH phraseIndex = phraseIndex + 1
  END
  # if phraseRest is sent
  # NOTE M1 used due to SB limiting comparisons to four indices
  IF M2 == FF 2E 57
    # assign value to 2E57, indicating a rest
    ASS JJC = 2E57
    # NOTE could remove math and hard code in 2E57
    MATH phraseTemp = JJC / 100
    # SEND SYSEX
    SEND F0 CC phraseIndex phraseTemp JJC F7 +F
    # END SYSEX
    ASS phraseLengthPlusOffset = phraseIndex
    # SEND SYSEX
    SEND F0 CC 0D phraseLengthPlusOffset F7 +F
    # END SYSEX
    MATH phraseIndex = phraseIndex + 1
  END
  # if phrase is at max limit, end setPhrase
  IF phraseIndex > 47
    ASS setPhrase = 0
    # SEND SYSEX
    SEND F0 FF 0A setPhrase F7 +F
    # END SYSEX
    ASS phraseIndex = 2A
    ASS tempPhraseVal = AAAA
    # NOTE since this message is for turning off the light, it only needs to be sent when the final note is not a rest
    # rest button handles this in xtouch
    IF J47 != 2E57
      SEND F0 FF 0A setPhrase F7 +F
    END
  END
  FX = XX +B
  # block notes if phrase is on, since keypresses then should not make a noise
  IF arpPhraseOnOffToggle == 1
    NX = XX +B
  END
  # NOTE could block whatever is inputted here, to prevent notes from passing through while the phrase is running
  # this would make sense if phrase was toggled and on, but not if this was not the case
  # TEST
  # ensure phrase is being correctly set
  # ensure setPhrase is 0 if max limit reached, otherwise 1
  # ensure tempPhraseVal is the previous value
  # ensure phraseIndex is the previous index plus one
  LOG setPhrase
  LOG J2A J2A
  LOG J2B J2B
  LOG J2C J2C
  LOG J2D J2D
  LOG J2E J2E
  LOG J2F J2F
  LOG J30 J30
  LOG J31 J31
  LOG J32 J32
  LOG J33 J33
  LOG J34 J34
  LOG J35 J35
  LOG J36 J36
  LOG J37 J37
  LOG J38 J38
  LOG J39 J39
  LOG J3A J3A
  LOG J3B J3B
  LOG J3C J3C
  LOG J3D J3D
  LOG J3E J3E
  LOG J3F J3F
  LOG J40 J40
  LOG J41 J41
  LOG J42 J42
  LOG J43 J43
  LOG J44 J44
  LOG J45 J45
  LOG J46 J46
  LOG J47 J47
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG setPhrase setPhrase
  LOG tempPhraseVal tempPhraseVal
  LOG phraseIndex phraseIndex
  LOG phraseLengthPlusOffset phraseLengthPlusOffset
  # END TEST
END

# NOTE could likely reorder everything here to be grouped in one if statement to make code more readable if desired
