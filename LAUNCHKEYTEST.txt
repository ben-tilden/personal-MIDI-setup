# launchkey mini test code

# TEST NOTES
# TODO latch is sending a note off that arp (and likely phrase) never actually had on in the first place
# can we send the note again once we press arp / phrase?
# phrase would only need to receive the first value in the array, since multiple keys don't matter
# incorrect - note release would still impact num pressed
# issue here is that it would be most recent key pressed, not first key pressed
# could possibly use latchLengthOffset - 1 to reverse sending
#
# can we switch between arpPhraseToggle without issue?









# launchkey mini (mk2)

# this will feed data into each channel file and will be toggled by xtouch
# if phrase and arp are off, notes will be passed through as expected

SUBROUTINE INSERTION_SORT isOrder length
  ALIAS I10 i
  ALIAS I11 j
  ALIAS I12 jPlusOne
  ALIAS I13 keyVal
  ALIAS I14 keyBool
  ALIAS I15 isSetSort
  ALIAS I16 lengthOffset

  MATH lengthOffset = length + 20

  IF isOrder == 1
    ASS i = 21
    WHILE i < lengthOffset
      ASS keyVal = KI10
      ASS keyBool = JI10
      MATH j = i - 1
      MATH jPlusOne = j + 1
      ASS isSetSort = 0
      IF j >= 20
        IF KI11 < keyVal
          ASS isSetSort = 1
        END
      END
      WHILE isSetSort == 1
        ASS KI12 = KI11
        ASS JI12 = JI11
        MATH j = j - 1
        MATH jPlusOne = j + 1
        ASS isSetSort = 0
        IF j >= 20
          IF KI11 < keyVal
            ASS isSetSort = 1
          END
        END
      END
      ASS KI12 = keyVal
      ASS JI12 = keyBool
      MATH i = i + 1
    END
  ELSE
    ASS i = 21
    WHILE i < lengthOffset
      ASS keyVal = JI10
      ASS keyBool = KI10
      MATH j = i - 1
      MATH jPlusOne = j + 1
      ASS isSetSort = 0
      IF j >= 20
        IF JI11 < keyVal
          ASS isSetSort = 1
        END
      END
      WHILE isSetSort == 1
        ASS JI12 = JI11
        ASS KI12 = KI11
        MATH j = j - 1
        MATH jPlusOne = j + 1
        ASS isSetSort = 0
        IF j >= 20
          IF JI11 < keyVal
            ASS isSetSort = 1
          END
        END
      END
      ASS JI12 = keyVal
      ASS KI12 = keyBool
      MATH i = i + 1
    END
  END
END

# J is the local storage array (database)
# TODO implement button reset

IF LOAD

  # setup init - comment out if there is a need to save global information between sessions
  # reset global array
  # TODO IF keypressed here? can that prevent extra work?

  ASS J0 = 00 # currentChannel
  ASS J1 = 00 # numPressed
  ASS J2 = 00 # arpPhraseToggle
  ASS J3 = 00 # arpPhraseOnOffToggle
  ASS J4 = 00 # tempoModeMod
  ASS J5 = 24 # tempoPulse
  ASS J6 = 00 # gateModeMod
  ASS J7 = 00 # gate
  ASS J8 = 64 # velocity
  ASS J9 = 00 # arpValueModeMod
  ASS JA = 00 # setPhrase
  ASS JB = 00 # phraseVal
  ASS JC = 2A # phraseindex
  ASS JD = 2A # phraseLengthPlusOffset
  ASS JE = 00 # gateOpened
  ASS JF = 00 # waveguideToggle
  ASS J10 = 0E # drumParams (Part 1)
  ASS J11 = 0F # drumParams (Part 2)
  ASS J12 = 10 # drumParams (Part 1+2)
  ASS J13 = 67 # drumParams (wg send) (103)
  ASS J14 = 00 # isLatch
  ASS J20 = 00 00 00 00 00 00 00 00 00 00 # arp values (J10 J11 J12 J13 J14 J15 J16 J17 J18 J19)
  ASS J2A = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # phrase sequence (J2A J2B J2C J2D J2E J2F J30 J31 J32 J33 J34 J35 J36 J37 J38 J39 ETC.)
  # TEST
  # ensure global array reset
  ASS LFF = 0
  WHILE LFF < 48
    LOG J_INDEX LFF
    LOG LFF JLFF
    MATH LFF = LFF + 1
  END
  # END TEST

  # reset xtouch lighting and params
  SEND F0 FF FF 00 00 F7 +F
  # TEST
  # ensure xtouch reset
  LOG XTOUCH_RESET
  # END TEST

  # full setup init - comment out if there is a need to save channel information between sessions
  # reset channel information
  SEND F0 CC FF 00 00 F7 +F
  # TEST
  # ensure channel information reset (will need to be done on individual files)
  LOG CHANNELS_RESET
  # END TEST

  # global variable
  ALIAS G0 currentChannel

  # end init

  # constant

  ALIAS 20 arpIndexOffset
  ALIAS C8 latchInterval

  # local
  ALIAS I0 iter
  ALIAS I1 isSet
  ALIAS I2 arpIndex
  ALIAS I3 numPressedTotal
  ALIAS I4 max
  ALIAS I5 maxIndex
  ALIAS I6 secondMax
  ALIAS I7 secondMaxIndex
  ALIAS I8 tempPhraseVal
  ALIAS I9 resetArp
  ALIAS IA resetPhrase
  ALIAS I17 phraseTemp # TODO
  ALIAS I18 isFirst # TODO
  ALIAS I19 latchTiming # TODO
  ALIAS I1C initLatch # TODO
  # NOTE I10 - I16 taken by insertion sort above

  # global
  ALIAS J1 numPressed
  ALIAS J2 arpPhraseToggle
  ALIAS J3 arpPhraseOnOffToggle
  ALIAS J9 arpValueModeMod
  ALIAS JA setPhrase
  ALIAS JB phraseVal
  ALIAS JC phraseIndex
  ALIAS JD phraseLengthPlusOffset
  ALIAS JE gateOpened
  ALIAS J14 isLatch

  # assign local
  ASS K20 = 00 00 00 00 00 00 00 00 00 00

  ASS numPressedTotal = 0
  # needs to be set to a value too far for both negatives and positives to reach
  ASS tempPhraseVal = AAAA
  ASS overload = 0
  ASS isFirst = 0
  ASS initLatch = 1

END

# TODO fix this - can't make it global because then it can't be recorded - or would need to save channel when recording somehow
# filter xtouch into modstep?
IF isFirst == 0
  ASS currentChannel = MC
  ASS isFirst = 1
END

# sysex reception

IF M0 == F0

  IF M2 == 02
    ASS arpPhraseToggle = M3
    # TEST
    # ensure launchkey receives arpPhraseToggle
    LOG arpPhraseToggle_SYSEX_RECEIVED J2
    # END TEST
    BLOCK
    EXIT
  END

  IF M2 == 03
    ASS arpPhraseOnOffToggle = M3
    # TODO will need to send note release if latch is on
    IF isLatch == 1
      # isArp
      IF arpPhraseToggle == 0

      # isPhrase
      ELSE

      END
    END
    # TEST
    # ensure launchkey receives arpPhraseOnOffToggle
    LOG arpPhraseOnOffToggle_SYSEX_RECEIVED J3
    # END TEST
    BLOCK
    EXIT
  END

  IF M2 == 09
    ASS arpValueModeMod = M3
    # TEST
    # ensure launchkey receives arpValueModeMod
    LOG arpValueModeMod_SYSEX_RECEIVED J9
    # END TEST
    BLOCK
    EXIT
  END

  # TODO should setPhrase turn latch off?
  IF M2 == 0A
    ASS setPhrase = M3
    # TEST
    # ensure launchkey receives setPhrase
    LOG setPhrase_SYSEX_RECEIVED JA
    # END TEST
    IF setPhrase == 0
      ASS phraseIndex = 2A
      ASS tempPhraseVal = AAAA
      FX = XX +B
      # TEST
      # ensure sysex resets phraseIndex when setPhrase is turned off
      LOG phraseIndex phraseIndex
      # END TEST
    END
    BLOCK
    EXIT
  END

  IF M2 == 0C
    ASS phraseIndex = M3
    # TEST
    # ensure launchkey receives phraseIndex
    LOG phraseIndex_SYSEX_RECEIVED JC
    # END TEST
    BLOCK
    EXIT
  END

  # NOTE pressing keys at the same time as turning latch off will likely cause problems, since note releases will be sent regardless of whether the keys are currently pressed or not
  # TODO send note releases / reset initLatch on latch reset (do this for above as well)
  IF M2 == 14
    ASS isLatch = M3
    IF isLatch == 0

    END
    # TEST
    # ensure launchkey receives isLatch
    LOG isLatch_SYSEX_RECEIVED J14
    # END TEST
    BLOCK
    EXIT
  END
END

# end sysex reception

# TODO not currently functional
IF MT == B0
  IF M1 == 6B 00
    # TODO two buttons at once? triple tap? on release

    # NOTE will need to send lighting to xtouch for sure, but setting the global channel should be enough to change routing
    # SEND sysex here

    ASS currentChannel = MC

    NX = XX +B
  END
END

IF MT == 90

  # RESET

  # if reset (key pressed limit exceeded), handle differently
  IF overload == 1
    MATH numPressed = numPressed + 1
    # SEND SYSEX
    SEND F0 CC 01 numPressed F7 +F
    # END SYSEX
    BLOCK
    EXIT
  END

  # setting arbitrary limit on number of keys pressed at a time to 10 (using 10 as comparator here because numPressed has not yet been increased)
  IF numPressed == A
    ASS J20 = 00 00 00 00 00 00 00 00 00 00
    # SEND SYSEX
    SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
    # END SYSEX
    ASS K20 = 00 00 00 00 00 00 00 00 00 00
    ASS overload = 1
    ASS numPressedTotal = 0
    # necessary so that numPressed does not go past zero by mistake, as we have not yet incremented for this key press
    MATH numPressed = numPressed + 1
    # SEND SYSEX
    SEND F0 CC 01 numPressed F7 +F
    # END SYSEX

    # TEST
    # ensure J array contains correct key values pressed on reset (0)
    # ensure K array contains correct order of keys pressed on reset (0)
    # ensure numPressed aligns with number of keys pressed on reset (0)
    # ensure numPressedTotal aligns with number of keys pressed total on reset (0)
    LOG J19 J19 # should always be 0, unless globalkey is updated
    LOG J20 J20
    LOG J21 J21
    LOG J22 J22
    LOG J23 J23
    LOG J24 J24
    LOG J25 J25
    LOG J26 J26
    LOG J27 J27
    LOG J28 J28
    LOG J29 J29
    LOG J2A J2A # should always be first value of phrase
    LOG ~~~~~~~~~~BREAK~~~~~~~~~~
    LOG K19 K19 # should always be 0
    LOG K20 K20
    LOG K21 K21
    LOG K22 K22
    LOG K23 K23
    LOG K24 K24
    LOG K25 K25
    LOG K26 K26
    LOG K27 K27
    LOG K28 K28
    LOG K29 K29
    LOG K2A K2A # should always be 0
    LOG ~~~~~~~~~~BREAK~~~~~~~~~~
    LOG numPressed numPressed
    LOG numPressedTotal numPressedTotal
    # END TEST

    BLOCK
    EXIT
  END

  # LATCH

  IF isLatch == 1
    ASS latchTiming = T0
    # TEST
    LOG latchTiming latchTiming
    LOG latchInterval latchInterval
    # END TEST
    # initLatch essentially performs timer reset, since timer is only reset on scene load
    # it prevents the overly large timer from being relevant on first ASS
    # if key press is NOT within time limit
    IF initLatch == 0
      IF latchTiming > latchInterval
        # reset arrays
        ASS J20 = 00 00 00 00 00 00 00 00 00 00
        ASS K20 = 00 00 00 00 00 00 00 00 00 00
        ASS numPressed = 0
        ASS numPressedTotal = 0
      END
    ELSE
      ASS initLatch = 0
    END
  END

  # ALL

  # store note value in first open spot in array
  MATH arpIndex = arpIndexOffset + numPressed
  ASS JI2 = M1
  ASS KI2 = numPressedTotal

  # PHRASE

  # set initial note to calculate offset
  ASS phraseVal = M1
  # SEND SYSEX
  SEND F0 CC 0B phraseVal F7 +F
  # END SYSEX

  # ALL

  # add one to notes overall pressed
  MATH numPressedTotal = numPressedTotal + 1

  # add one to current notes pressed
  # NOTE this is done before sorting to make sure proper length is parsed
  MATH numPressed = numPressed + 1
  # SEND SYSEX
  SEND F0 CC 01 numPressed F7 +F
  # END SYSEX

  # ARP

  # sort array / hashmap according to ascending, descending, order pressed
  IF arpValueModeMod < 6
    INSERTION_SORT 0 numPressed
  END
  IF arpValueModeMod > 8
    INSERTION_SORT 1 numPressed
  END
  # SEND SYSEX
  SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
  # END SYSEX

  # ALL

  IF numPressed == 1
    ASS gateOpened = 1
    # SEND SYSEX
    SEND F0 CC 0E gateOpened F7 +F
    # END SYSEX
  END
  # TEST TRY
  #IF numPressed > 1
  #  ASS gateOpened = 2
  #END
  # END TEST TRY

  # TEST
  # ensure J array contains correct key values pressed on key press
  # ensure K array contains correct order of keys pressed on key press
  # ensure numPressed aligns with number of keys pressed on key press
  # ensure numPressedTotal aligns with number of keys pressed total on key press
  # ensure gateOpened aligns with number of keys pressed total on key press
  LOG J19 J19 # should always be 0, unless globalkey is updated
  LOG J20 J20
  LOG J21 J21
  LOG J22 J22
  LOG J23 J23
  LOG J24 J24
  LOG J25 J25
  LOG J26 J26
  LOG J27 J27
  LOG J28 J28
  LOG J29 J29
  LOG J2A J2A # should always be first value of phrase
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG K19 K19 # should always be 0
  LOG K20 K20
  LOG K21 K21
  LOG K22 K22
  LOG K23 K23
  LOG K24 K24
  LOG K25 K25
  LOG K26 K26
  LOG K27 K27
  LOG K28 K28
  LOG K29 K29
  LOG K2A K2A # should always be 0
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG numPressed numPressed
  LOG numPressedTotal numPressedTotal
  LOG gateOpened gateOpened
  LOG phraseVal phraseVal
  # END TEST

  IF arpPhraseOnOffToggle == 1
    NX = XX +B
  END

END



IF MT == 80

  # if reset (key pressed limit exceeded), handle differently
  IF overload == 1
    MATH numPressed = numPressed - 1
    # SEND SYSEX
    SEND F0 CC 01 numPressed F7 +F
    # END SYSEX
    IF numPressed == 0
      ASS overload = 0
    END
    BLOCK
    EXIT
  END

  # LATCH

  IF isLatch == 1
    # TEST
    # ensure note releases are blocked if latch is on
    LOG NOTE_RELEASE_BLOCKED
    # END TEST
    BLOCK
    EXIT
  END

  # ALL (max for PHRASE)

  # find the max l value, or the most recent key pressed
  # if the k value, or note value of that max is M1, we need to change the phrase offset
  # while we are iterating, we need to set the l value of whichever key is released to zero so we can reuse that index
  WHILE iter < length
    IF KI0 > max
      ASS secondMax = max
      ASS max = KI0
    ELSE
      IF KI0 > secondMax
        ASS secondMax = KI0
      END
    END
    IF JI0 == M1
      ASS JI0 = 0
      ASS KI0 = 0
    END
    MATH iter = iter + 1
  END

  # PHRASE

  IF max == M1
    # set value equal to second most recent key pressed
    # ASS gateOpened = 1 # NOTE uncommenting this and sending sysex would restart phrase whenever key lifted
    ASS phraseVal = secondMax
    # SEND SYSEX
    SEND F0 CC 0B phraseVal F7 +F
    # END SYSEX
  END

  # ARP

  # sort array / hashmap according to ascending, descending, order pressed
  IF arpValueModeMod < 6
    INSERTION_SORT 0 numPressed
  END
  IF arpValueModeMod > 8
    INSERTION_SORT 1 numPressed
  END
  # SEND SYSEX
  SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
  # END SYSEX

  # ALL

  # subract one from current notes pressed
  # NOTE this is done after sorting to make sure any removed values are pushed out
  MATH numPressed = numPressed - 1
  # SEND SYSEX
  SEND F0 CC 01 numPressed F7 +F
  # END SYSEX
  IF numPressed == 0
    ASS J20 = 00 00 00 00 00 00 00 00 00 00
    ASS K20 = 00 00 00 00 00 00 00 00 00 00
    # SEND SYSEX
    SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
    # END SYSEX
    ASS numPressedTotal = 0
  END

  # TEST
  # ensure J array contains correct key values pressed on key release
  # ensure K array contains correct order of keys pressed on key release
  # ensure numPressed aligns with number of keys pressed on key release
  # ensure numPressedTotal aligns with number of keys pressed total on key release
  # ensure gateOpened aligns with number of keys pressed total on key release
  LOG J19 J19 # should always be 0, unless global key is updated
  LOG J20 J20
  LOG J21 J21
  LOG J22 J22
  LOG J23 J23
  LOG J24 J24
  LOG J25 J25
  LOG J26 J26
  LOG J27 J27
  LOG J28 J28
  LOG J29 J29
  LOG J2A J2A # should always be first value of phrase
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG K19 K19 # should always be 0
  LOG K20 K20
  LOG K21 K21
  LOG K22 K22
  LOG K23 K23
  LOG K24 K24
  LOG K25 K25
  LOG K26 K26
  LOG K27 K27
  LOG K28 K28
  LOG K29 K29
  LOG K2A K2A # should always be 0
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG numPressed numPressed
  LOG numPressedTotal numPressedTotal
  LOG gateOpened gateOpened
  LOG phraseVal phraseVal
  # END TEST

  IF arpPhraseOnOffToggle == 1
    NX = XX +B
  END

END

# TODO add these if statements to if statements above
IF setPhrase == 1
  IF MT == 90
    # because we're taking offset here, we need to record each step as the difference between it and the last step
    # if tempPhraseVal has a previous value (i.e. is not the first key pressed in the phrase)
    # NOTE max phrase length at this point is 32
    IF tempPhraseVal == AAAA
      ASS tempPhraseVal = M1
    END
    MATH JJC = M1 - tempPhraseVal
    MATH phraseTemp = JJC / 100
    # SEND SYSEX
    SEND F0 CC phraseIndex phraseTemp JJC F7 +F
    # END SYSEX
    ASS phraseLengthPlusOffset = phraseIndex
    # SEND SYSEX
    SEND F0 CC 0D phraseLengthPlusOffset F7 +F
    # END SYSEX
    MATH phraseIndex = phraseIndex + 1
  END
  # if phraseRest is sent
  # NOTE M1 used due to SB limiting comparisons to four indices
  IF M2 == FF 2E 57
    # assign value to 2E57, indicating a rest
    ASS JJC = 2E57
    # NOTE could remove math and hard code in 2E57
    MATH phraseTemp = JJC / 100
    # SEND SYSEX
    SEND F0 CC phraseIndex phraseTemp JJC F7 +F
    # END SYSEX
    ASS phraseLengthPlusOffset = phraseIndex
    # SEND SYSEX
    SEND F0 CC 0D phraseLengthPlusOffset F7 +F
    # END SYSEX
    MATH phraseIndex = phraseIndex + 1
  END
  # if phrase is at max limit, end setPhrase
  IF phraseIndex > 47
    ASS setPhrase = 0
    # SEND SYSEX
    SEND F0 FF 0A setPhrase F7 +F
    # END SYSEX
    ASS phraseIndex = 2A
    ASS tempPhraseVal = AAAA
    # NOTE since this message is for turning off the light, it only needs to be sent when the final note is not a rest
    # rest button handles this in xtouch
    IF J47 != 2E57
      SEND F0 FF 0A setPhrase F7 +F
    END
  END
  FX = XX +B
  # block notes if phrase is on, since keypresses then should not make a noise
  IF arpPhraseOnOffToggle == 1
    NX = XX +B
  END
  # NOTE could block whatever is inputted here, to prevent notes from passing through while the phrase is running
  # this would make sense if phrase was toggled and on, but not if this was not the case
  # TEST
  # ensure phrase is being correctly set
  # ensure setPhrase is 0 if max limit reached, otherwise 1
  # ensure tempPhraseVal is the previous value
  # ensure phraseIndex is the previous index plus one
  LOG setPhrase
  LOG J2A J2A
  LOG J2B J2B
  LOG J2C J2C
  LOG J2D J2D
  LOG J2E J2E
  LOG J2F J2F
  LOG J30 J30
  LOG J31 J31
  LOG J32 J32
  LOG J33 J33
  LOG J34 J34
  LOG J35 J35
  LOG J36 J36
  LOG J37 J37
  LOG J38 J38
  LOG J39 J39
  LOG J3A J3A
  LOG J3B J3B
  LOG J3C J3C
  LOG J3D J3D
  LOG J3E J3E
  LOG J3F J3F
  LOG J40 J40
  LOG J41 J41
  LOG J42 J42
  LOG J43 J43
  LOG J44 J44
  LOG J45 J45
  LOG J46 J46
  LOG J47 J47
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG setPhrase setPhrase
  LOG tempPhraseVal tempPhraseVal
  LOG phraseIndex phraseIndex
  LOG phraseLengthPlusOffset phraseLengthPlusOffset
  # END TEST
END

# NOTE could likely reorder everything here to be grouped in one if statement to make code more readable if desired
