# launchkey mini test code

# TEST NOTES










# launchkey mini (mk2)

# this will feed data into each channel file and will be toggled by xtouch
# if phrase and arp are off, notes will be passed through as expected

SUBROUTINE INSERTION_SORT isOrder length
  ALIAS I10 i
  ALIAS I11 j
  ALIAS I12 jPlusOne
  ALIAS I13 keyVal
  ALIAS I14 keyBool
  ALIAS I15 isSetSort
  ALIAS I16 lengthOffset

  MATH lengthOffset = length + 20

  IF isOrder == 1
    ASS i = 21
    WHILE i < lengthOffset
      ASS keyVal = KI10
      ASS keyBool = JI10
      MATH j = i - 1
      MATH jPlusOne = j + 1
      ASS isSetSort = 0
      IF j >= 20
        IF KI11 < keyVal
          ASS isSetSort = 1
        END
      END
      WHILE isSetSort == 1
        ASS KI12 = KI11
        ASS JI12 = JI11
        MATH j = j - 1
        MATH jPlusOne = j + 1
        ASS isSetSort = 0
        IF j >= 20
          IF KI11 < keyVal
            ASS isSetSort = 1
          END
        END
      END
      ASS KI12 = keyVal
      ASS JI12 = keyBool
      MATH i = i + 1
    END
  ELSE
    ASS i = 21
    WHILE i < lengthOffset
      ASS keyVal = JI10
      ASS keyBool = KI10
      MATH j = i - 1
      MATH jPlusOne = j + 1
      ASS isSetSort = 0
      IF j >= 20
        IF JI11 < keyVal
          ASS isSetSort = 1
        END
      END
      WHILE isSetSort == 1
        ASS JI12 = JI11
        ASS KI12 = KI11
        MATH j = j - 1
        MATH jPlusOne = j + 1
        ASS isSetSort = 0
        IF j >= 20
          IF JI11 < keyVal
            ASS isSetSort = 1
          END
        END
      END
      ASS JI12 = keyVal
      ASS KI12 = keyBool
      MATH i = i + 1
    END
  END
END

# J is the local storage array (database)
# TODO implement button reset

IF LOAD

  # setup init - comment out if there is a need to save global information between sessions
  # reset global array
  # TODO IF keypressed here? can that prevent extra work?

  ASS J0 = 00 # currentChannel
  ASS J1 = 00 # numPressed
  ASS J2 = 00 # arpPhraseToggle
  ASS J3 = 00 # arpPhraseOnOffToggle
  ASS J4 = 00 # tempoModeMod
  ASS J5 = 24 # tempoPulse
  ASS J6 = 00 # gateModeMod
  ASS J7 = 00 # gate
  ASS J8 = 64 # velocity
  ASS J9 = 00 # arpValueModeMod
  ASS JA = 00 # setPhrase
  ASS JB = 3C # phraseVal
  ASS JC = 2A # phraseindex
  ASS JD = 2A # phraseLengthPlusOffset
  ASS JE = 00 # gateOpened
  ASS JF = 00 # waveguideToggle
  ASS J10 = 0E # drumParams (Part 1)
  ASS J11 = 0F # drumParams (Part 2)
  ASS J12 = 10 # drumParams (Part 1+2)
  ASS J13 = 67 # drumParams (wg send) (103)
  ASS J14 = 00 # isLatch
  ASS J20 = 00 00 00 00 00 00 00 00 00 00 # arp values (J10 J11 J12 J13 J14 J15 J16 J17 J18 J19)
  ASS J2A = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # phrase sequence (J2A J2B J2C J2D J2E J2F J30 J31 J32 J33 J34 J35 J36 J37 J38 J39 ETC.)
  # TEST
  # ensure global array reset
  ASS LFF = 0
  WHILE LFF < 48
    LOG J_INDEX LFF
    LOG LFF JLFF
    MATH LFF = LFF + 1
  END
  # END TEST

  # reset xtouch lighting and params
  SEND F0 FF FF 00 00 F7 +F
  # TEST
  # ensure xtouch reset
  LOG XTOUCH_RESET
  # END TEST

  # full setup init - comment out if there is a need to save channel information between sessions
  # reset channel information
  SEND F0 CC FF 00 00 F7 +F
  # TEST
  # ensure channel information reset (will need to be done on individual files)
  LOG CHANNELS_RESET
  # END TEST

  # global variable
  ALIAS G0 currentChannel

  # end init

  # constant

  ALIAS 20 arpIndexOffset
  ALIAS C8 latchInterval

  # local
  ALIAS I0 iter
  ALIAS I2 arpIndex
  ALIAS I3 numPressedTotal
  ALIAS I4 max
  ALIAS I5 valOfMax
  ALIAS I6 secondMax
  ALIAS I7 valOfSecondMax
  ALIAS I8 tempPhraseVal
  ALIAS I9 overload
  ALIAS I17 phraseTemp # TODO
  ALIAS I18 isFirst # TODO
  ALIAS I19 latchTiming # TODO
  ALIAS I1C initLatch # TODO
  # NOTE I10 - I16 taken by insertion sort above

  # global
  ALIAS J1 numPressed
  ALIAS J2 arpPhraseToggle
  ALIAS J3 arpPhraseOnOffToggle
  ALIAS J8 velocity
  ALIAS J9 arpValueModeMod
  ALIAS JA setPhrase
  ALIAS JB phraseVal
  ALIAS JC phraseIndex
  ALIAS JD phraseLengthPlusOffset
  ALIAS JE gateOpened
  ALIAS J14 isLatch

  # assign local
  ASS K20 = 00 00 00 00 00 00 00 00 00 00

  ASS numPressedTotal = 0
  ASS arpIndex = arpIndexOffset
  # needs to be set to a value too far for both negatives and positives to reach
  ASS tempPhraseVal = AAAA
  ASS overload = 0
  ASS isFirst = 0
  ASS initLatch = 1

END

# TODO fix this - can't make it global because then it can't be recorded - or would need to save channel when recording somehow
# filter xtouch into modstep?
IF isFirst == 0
  ASS currentChannel = MC
  ASS isFirst = 1
END

# sysex reception

IF M0 == F0

  IF M2 == 02
    ASS arpPhraseToggle = M3
    # if module is currently on
    IF arpPhraseOnOffToggle == 1
      # need to open gate so that there's a smooth transition here
      ASS gateOpened = 1
      # SEND SYSEX
      SEND F0 CC 0E gateOpened F7 +F
      # END SYSEX
    END
    # TEST
    # ensure launchkey receives arpPhraseToggle
    # ensure transition between arp and phrase is smooth if module is on
    LOG arpPhraseToggle_SYSEX_RECEIVED J2
    # END TEST
    BLOCK
    EXIT
  END

  IF M2 == 03
    ASS arpPhraseOnOffToggle = M3
    # will need to send note release if latch is on
    IF isLatch == 1
      IF arpPhraseOnOffToggle == 1
        ASS iter = arpIndexOffset
        WHILE iter < arpIndex
          SEND 80 JI0 00
          MATH iter = iter + 1
        END
        # need to open gate so that there's a smooth transition here
        ASS gateOpened = 1
        # SEND SYSEX
        SEND F0 CC 0E gateOpened F7 +F
        # END SYSEX
      ELSE
        ASS iter = arpIndexOffset
        WHILE iter < arpIndex
          SEND 90 JI0 velocity
          MATH iter = iter + 1
        END
      END
    END
    # TEST
    # ensure launchkey receives arpPhraseOnOffToggle
    # ensure note release properly sent when arp/phrase turned on
    # ensure general transition with latch on to arp/phrase on is smooth
    # ensure note press properly sent when arp/phrase turned off
    # ensure general transition with latch on to arp/phrase off is smooth
    LOG arpPhraseOnOffToggle_SYSEX_RECEIVED J3
    # END TEST
    BLOCK
    EXIT
  END

  IF M2 == 08
    ASS velocity = M3
    # TEST
    # ensure launchkey receives velocity
    LOG velocity_SYSEX_RECEIVED J8
    # END TEST
    BLOCK
    EXIT
  END

  IF M2 == 09
    ASS arpValueModeMod = M3
    # TEST
    # ensure launchkey receives arpValueModeMod
    LOG arpValueModeMod_SYSEX_RECEIVED J9
    # END TEST
    BLOCK
    EXIT
  END

  # TODO should setPhrase turn latch off?
  IF M2 == 0A
    ASS setPhrase = M3
    # TEST
    # ensure launchkey receives setPhrase
    LOG setPhrase_SYSEX_RECEIVED JA
    # END TEST
    IF setPhrase == 0
      ASS phraseIndex = 2A
      ASS tempPhraseVal = AAAA
      FX = XX +B
      # TEST
      # ensure sysex resets phraseIndex when setPhrase is turned off
      LOG phraseIndex phraseIndex
      # END TEST
    END
    BLOCK
    EXIT
  END

  IF M2 == 14
    ASS isLatch = M3
      IF isLatch == 0
        ASS iter = arpIndexOffset
        WHILE iter < arpIndex
          SEND 80 JI0 00
          ASS JI0 = 0
          ASS KI0 = 0
          MATH iter = iter + 1
        END
        ASS numPressed = 0
        ASS numPressedTotal = 0
        ASS arpIndex = arpIndexOffset
        # SEND SYSEX
        SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
        # END SYSEX
        # SEND SYSEX
        SEND F0 CC 01 numPressed F7 +F
        # END SYSEX
      END
    # TEST
    # ensure launchkey receives isLatch
    # ensure note release properly sent when latch turned off
    LOG isLatch_SYSEX_RECEIVED J14
    # END TEST
    BLOCK
    EXIT
  END
END

# end sysex reception

# TODO not currently functional
IF MT == B0
  IF M1 == 6B 00
    # TODO two buttons at once? triple tap? on release

    # NOTE will need to send lighting to xtouch for sure, but setting the global channel should be enough to change routing
    # SEND sysex here

    ASS currentChannel = MC

    NX = XX +B
  END
END

IF MT == 90

  # RESET

  # if reset (key pressed limit exceeded), handle differently
  IF overload == 1
    MATH numPressed = numPressed + 1
    # SEND SYSEX
    SEND F0 CC 01 numPressed F7 +F
    # END SYSEX
    BLOCK
    EXIT
  END

  # setting arbitrary limit on number of keys pressed at a time to 10 (using 10 as comparator here because numPressed has not yet been increased)
  IF numPressed == A
    ASS J20 = 00 00 00 00 00 00 00 00 00 00
    # SEND SYSEX
    SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
    # END SYSEX
    ASS K20 = 00 00 00 00 00 00 00 00 00 00
    ASS overload = 1
    ASS numPressedTotal = 0
    ASS arpIndex = arpIndexOffset
    # necessary so that numPressed does not go past zero by mistake, as we have not yet incremented for this key press
    MATH numPressed = numPressed + 1
    # SEND SYSEX
    SEND F0 CC 01 numPressed F7 +F
    # END SYSEX
    ASS phraseVal = 3C
    # SEND SYSEX
    SEND F0 CC 0B phraseVal F7 +F
    # END SYSEX

    # TEST
    # ensure J array contains correct key values pressed on reset (0)
    # ensure K array contains correct order of keys pressed on reset (0)
    # ensure numPressed aligns with number of keys pressed on reset (0)
    # ensure numPressedTotal aligns with number of keys pressed total on reset (0)
    # ensure phraseVal reset to 3C on reset
    LOG J19 J19 # should always be 0, unless globalkey is updated
    LOG J20 J20
    LOG J21 J21
    LOG J22 J22
    LOG J23 J23
    LOG J24 J24
    LOG J25 J25
    LOG J26 J26
    LOG J27 J27
    LOG J28 J28
    LOG J29 J29
    LOG J2A J2A # should always be first value of phrase
    LOG ~~~~~~~~~~BREAK~~~~~~~~~~
    LOG K19 K19 # should always be 0
    LOG K20 K20
    LOG K21 K21
    LOG K22 K22
    LOG K23 K23
    LOG K24 K24
    LOG K25 K25
    LOG K26 K26
    LOG K27 K27
    LOG K28 K28
    LOG K29 K29
    LOG K2A K2A # should always be 0
    LOG ~~~~~~~~~~BREAK~~~~~~~~~~
    LOG numPressed numPressed
    LOG numPressedTotal numPressedTotal
    LOG phraseVal phraseVal
    # END TEST

    BLOCK
    EXIT
  END

  # LATCH

  IF isLatch == 1
    ASS latchTiming = T0
    # TEST
    # ensure latchValues are storing correctly on note press
    # ensure latchValues are reset if timing between notes is >=.1 second
    # ensure latchValues are added to if timing between notes <.1 second
    LOG latchTiming latchTiming
    LOG latchInterval latchInterval
    # END TEST
    # initLatch essentially performs timer reset, since timer is only reset on scene load
    # it prevents the overly large timer from being relevant on first ASS
    # if key press is NOT within time limit
    IF initLatch == 0
      IF latchTiming > latchInterval
        # reset arrays and send note releases
        ASS iter = arpIndexOffset
        WHILE iter < arpIndex
          # NOTE if the note value is the same as a value that has just been pressed, we need to resend the value, since that is what will be happening with any other overlapping values pressed
          SEND 80 JI0 00
          IF M1 == JI0
            SEND 90 JI0 velocity
          END
          ASS JI0 = 0
          ASS KI0 = 0
          MATH iter = iter + 1
        END
        ASS numPressed = 0
        ASS numPressedTotal = 0
        ASS arpIndex = arpIndexOffset
        # TEST
        LOG TIMING_OFF_LATCH_RESET
        # END TEST
      END
    ELSE
      ASS initLatch = 0
      # TEST
      LOG initLatch initLatch
      # END TEST
    END
  END

  # PHRASE

  # set initial note to calculate offset
  ASS phraseVal = M1
  # SEND SYSEX
  SEND F0 CC 0B phraseVal F7 +F
  # END SYSEX

  # ALL

  # add one to notes overall pressed
  MATH numPressedTotal = numPressedTotal + 1

  # store note value in first open spot in array
  # NOTE this uses arpIndex, which should be set to arpIndexOffset before first key is pressed
  # after first key is pressed, arpIndex will be increased by numPressed (see below)
  ASS JI2 = M1
  ASS KI2 = numPressedTotal

  # add one to current notes pressed
  # NOTE this is done before sorting to make sure proper length is parsed
  # this is done after array assignment so that the alignment with arpIndex is accurate in setting
  MATH numPressed = numPressed + 1
  # SEND SYSEX
  SEND F0 CC 01 numPressed F7 +F
  # END SYSEX

  # NOTE this could also be MATH arpIndex = arpIndexOffset + numPressed
  MATH arpIndex = arpIndex + 1

  # ARP

  # sort array / hashmap according to ascending, descending, order pressed
  IF arpValueModeMod < 6
    INSERTION_SORT 0 numPressed
  END
  IF arpValueModeMod > 8
    INSERTION_SORT 1 numPressed
  END
  # SEND SYSEX
  SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
  # END SYSEX

  # ALL

  IF numPressed == 1
    ASS gateOpened = 1
    # SEND SYSEX
    SEND F0 CC 0E gateOpened F7 +F
    # END SYSEX
  END
  # TEST TRY
  #IF numPressed > 1
  #  ASS gateOpened = 2
  #END
  # END TEST TRY

  # TEST
  # ensure J array contains correct key values pressed on key press
  # ensure K array contains correct order of keys pressed on key press
  # ensure numPressed aligns with number of keys pressed on key press
  # ensure numPressedTotal aligns with number of keys pressed total on key press
  # ensure gateOpened aligns with number of keys pressed total on key press
  # ensure phraseVal aligns with correct phraseVal on key press
  LOG J19 J19 # should always be 0, unless globalkey is updated
  LOG J20 J20
  LOG J21 J21
  LOG J22 J22
  LOG J23 J23
  LOG J24 J24
  LOG J25 J25
  LOG J26 J26
  LOG J27 J27
  LOG J28 J28
  LOG J29 J29
  LOG J2A J2A # should always be first value of phrase
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG K19 K19 # should always be 0
  LOG K20 K20
  LOG K21 K21
  LOG K22 K22
  LOG K23 K23
  LOG K24 K24
  LOG K25 K25
  LOG K26 K26
  LOG K27 K27
  LOG K28 K28
  LOG K29 K29
  LOG K2A K2A # should always be 0
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG numPressed numPressed
  LOG numPressedTotal numPressedTotal
  LOG gateOpened gateOpened
  LOG phraseVal phraseVal
  # END TEST

  IF arpPhraseOnOffToggle == 1
    # only block notes if setPhrase is zero - if it's one, we need the setPhrase if statement to process the note
    IF setPhrase == 0
      NX = XX +B
    END
  END

END



IF MT == 80

  # if reset (key pressed limit exceeded), handle differently
  IF overload == 1
    MATH numPressed = numPressed - 1
    # SEND SYSEX
    SEND F0 CC 01 numPressed F7 +F
    # END SYSEX
    IF numPressed == 0
      ASS overload = 0
    END
    BLOCK
    EXIT
  END

  # LATCH

  IF isLatch == 1
    # TEST
    # ensure note releases are blocked if latch is on
    LOG NOTE_RELEASE_BLOCKED
    # END TEST
    BLOCK
    EXIT
  END

  # ALL (max for PHRASE)

  # find the max l value, or the most recent key pressed
  # if the k value, or note value of that max is M1, we need to change the phrase offset
  # while we are iterating, we need to set the l value of whichever key is released to zero so we can reuse that index
  ASS max = 0
  ASS valOfMax = 0
  ASS secondMax = 0
  ASS valOfSecondMax = 0
  ASS iter = arpIndexOffset
  WHILE iter < arpIndex
    IF KI0 > max
      ASS secondMax = max
      ASS valOfSecondMax = valOfMax
      ASS max = KI0
      ASS valOfMax = JI0
    ELSE
      IF KI0 > secondMax
        ASS secondMax = KI0
        ASS valOfSecondMax = JI0
      END
    END
    IF JI0 == M1
      ASS JI0 = 0
      ASS KI0 = 0
    END
    MATH iter = iter + 1
  END

  # PHRASE

  # TEST
  LOG valOfMax valOfMax
  LOG M1 M1
  # END TEST

  IF valOfMax == M1
    # set value equal to second most recent key pressed
    # ASS gateOpened = 1 # NOTE uncommenting this and sending sysex would restart phrase whenever key lifted
    ASS phraseVal = valOfSecondMax
    # SEND SYSEX
    SEND F0 CC 0B phraseVal F7 +F
    # END SYSEX
  END

  # ARP

  # sort array / hashmap according to ascending, descending, order pressed
  IF arpValueModeMod < 6
    INSERTION_SORT 0 numPressed
  END
  IF arpValueModeMod > 8
    INSERTION_SORT 1 numPressed
  END
  # SEND SYSEX
  SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
  # END SYSEX

  # ALL

  # subract one from current notes pressed
  # NOTE this is done after sorting to make sure any removed values are pushed out
  MATH numPressed = numPressed - 1
  # SEND SYSEX
  SEND F0 CC 01 numPressed F7 +F
  # END SYSEX

  MATH arpIndex = arpIndex - 1

  IF numPressed == 0
    ASS J20 = 00 00 00 00 00 00 00 00 00 00
    # SEND SYSEX
    SEND F0 CC 20 J20 J21 J22 J23 J24 J25 J26 J27 J28 J29 F7 +F
    # END SYSEX
    ASS K20 = 00 00 00 00 00 00 00 00 00 00
    ASS numPressedTotal = 0
    ASS arpIndex = arpIndexOffset
    ASS phraseVal = 3C
    # SEND SYSEX
    SEND F0 CC 0B phraseVal F7 +F
    # END SYSEX
  END

  # TEST
  # ensure J array contains correct key values pressed on key release
  # ensure K array contains correct order of keys pressed on key release
  # ensure numPressed aligns with number of keys pressed on key release
  # ensure numPressedTotal aligns with number of keys pressed total on key release
  # ensure gateOpened aligns with number of keys pressed total on key release
  # ensure phraseVal aligns with correct phraseVal on key release
  LOG J19 J19 # should always be 0, unless global key is updated
  LOG J20 J20
  LOG J21 J21
  LOG J22 J22
  LOG J23 J23
  LOG J24 J24
  LOG J25 J25
  LOG J26 J26
  LOG J27 J27
  LOG J28 J28
  LOG J29 J29
  LOG J2A J2A # should always be first value of phrase
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG K19 K19 # should always be 0
  LOG K20 K20
  LOG K21 K21
  LOG K22 K22
  LOG K23 K23
  LOG K24 K24
  LOG K25 K25
  LOG K26 K26
  LOG K27 K27
  LOG K28 K28
  LOG K29 K29
  LOG K2A K2A # should always be 0
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG numPressed numPressed
  LOG numPressedTotal numPressedTotal
  LOG gateOpened gateOpened
  LOG phraseVal phraseVal
  # END TEST

  IF arpPhraseOnOffToggle == 1
    NX = XX +B
  END

END

# NOTE could add these if statements to if statements above - I think this is slightly more readable
IF setPhrase == 1
  IF MT == 90
    # because we're taking offset here, we need to record each step as the difference between it and the last step
    # if tempPhraseVal has a previous value (i.e. is not the first key pressed in the phrase)
    # NOTE max phrase length at this point is 30
    IF tempPhraseVal == AAAA
      ASS tempPhraseVal = M1
    END
    MATH JJC = M1 - tempPhraseVal
    MATH phraseTemp = JJC / 100
    # SEND SYSEX
    SEND F0 CC phraseIndex phraseTemp JJC F7 +F
    # END SYSEX
    ASS phraseLengthPlusOffset = phraseIndex
    # SEND SYSEX
    SEND F0 CC 0D phraseLengthPlusOffset F7 +F
    # END SYSEX
    MATH phraseIndex = phraseIndex + 1
  END
  # if phraseRest is sent
  # NOTE M1 used due to SB limiting comparisons to four indices
  IF M2 == FF 2E 57
    # assign value to 2E57, indicating a rest
    ASS JJC = 2E57
    # NOTE could remove math and hard code in 2E57
    MATH phraseTemp = JJC / 100
    # SEND SYSEX
    SEND F0 CC phraseIndex phraseTemp JJC F7 +F
    # END SYSEX
    ASS phraseLengthPlusOffset = phraseIndex
    # SEND SYSEX
    SEND F0 CC 0D phraseLengthPlusOffset F7 +F
    # END SYSEX
    MATH phraseIndex = phraseIndex + 1
  END
  # if phrase is at max limit, end setPhrase
  IF phraseIndex > 47
    ASS setPhrase = 0
    # SEND SYSEX
    SEND F0 FF 0A setPhrase F7 +F
    # END SYSEX
    ASS phraseIndex = 2A
    ASS tempPhraseVal = AAAA
  END
  FX = XX +B
  # block notes if phrase is on, since keypresses then should not make a noise
  IF arpPhraseOnOffToggle == 1
    NX = XX +B
  END
  # NOTE could block whatever is inputted here, to prevent notes from passing through while the phrase is running
  # this would make sense if phrase was toggled and on, but not if this was not the case
  # TEST
  # ensure phrase is being correctly set
  # ensure setPhrase is 0 if max limit reached, otherwise 1
  # ensure tempPhraseVal is the previous value
  # ensure phraseIndex is the previous index plus one
  LOG setPhrase
  LOG J2A J2A
  LOG J2B J2B
  LOG J2C J2C
  LOG J2D J2D
  LOG J2E J2E
  LOG J2F J2F
  LOG J30 J30
  LOG J31 J31
  LOG J32 J32
  LOG J33 J33
  LOG J34 J34
  LOG J35 J35
  LOG J36 J36
  LOG J37 J37
  LOG J38 J38
  LOG J39 J39
  LOG J3A J3A
  LOG J3B J3B
  LOG J3C J3C
  LOG J3D J3D
  LOG J3E J3E
  LOG J3F J3F
  LOG J40 J40
  LOG J41 J41
  LOG J42 J42
  LOG J43 J43
  LOG J44 J44
  LOG J45 J45
  LOG J46 J46
  LOG J47 J47
  LOG ~~~~~~~~~~BREAK~~~~~~~~~~
  LOG setPhrase setPhrase
  LOG tempPhraseVal tempPhraseVal
  LOG phraseIndex phraseIndex
  LOG phraseLengthPlusOffset phraseLengthPlusOffset
  # END TEST
END
